//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
  providedIn: 'root',
})
export class AuditLogClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getPaged(request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/paged';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPaged(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPaged(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        })
      );
  }

  protected processGetPaged(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getById(id: string): Observable<ResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/{id}';
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfAuditLog>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfAuditLog>;
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<ResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/AuditLog/{id}';
    if (id === undefined || id === null)
      throw new globalThis.Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(auditLog: AuditLog): Observable<ResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(auditLog);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfAuditLog>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfAuditLog>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<ResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByUser(userId: string, request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/by-user/{userId}';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        })
      );
  }

  protected processGetByUser(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByEntity(
    entity: string | undefined,
    entityId: string | undefined,
    request: PagedRequest
  ): Observable<ResultOfPagedResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/by-entity?';
    if (entity === null) throw new globalThis.Error("The parameter 'entity' cannot be null.");
    else if (entity !== undefined) url_ += 'entity=' + encodeURIComponent('' + entity) + '&';
    if (entityId === null) throw new globalThis.Error("The parameter 'entityId' cannot be null.");
    else if (entityId !== undefined) url_ += 'entityId=' + encodeURIComponent('' + entityId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByEntity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByEntity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        })
      );
  }

  protected processGetByEntity(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByAction(
    action: string | undefined,
    request: PagedRequest
  ): Observable<ResultOfPagedResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/by-action?';
    if (action === null) throw new globalThis.Error("The parameter 'action' cannot be null.");
    else if (action !== undefined) url_ += 'action=' + encodeURIComponent('' + action) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByAction(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByAction(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        })
      );
  }

  protected processGetByAction(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByDateRange(
    from: Date | undefined,
    to: Date | undefined,
    request: PagedRequest
  ): Observable<ResultOfPagedResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/by-date-range?';
    if (from === null) throw new globalThis.Error("The parameter 'from' cannot be null.");
    else if (from !== undefined)
      url_ += 'from=' + encodeURIComponent(from ? '' + from.toISOString() : '') + '&';
    if (to === null) throw new globalThis.Error("The parameter 'to' cannot be null.");
    else if (to !== undefined)
      url_ += 'to=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByDateRange(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByDateRange(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        })
      );
  }

  protected processGetByDateRange(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getRecent(
    count: number | undefined,
    request: PagedRequest
  ): Observable<ResultOfPagedResultOfAuditLog> {
    let url_ = this.baseUrl + '/api/AuditLog/recent?';
    if (count === null) throw new globalThis.Error("The parameter 'count' cannot be null.");
    else if (count !== undefined) url_ += 'count=' + encodeURIComponent('' + count) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRecent(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRecent(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        })
      );
  }

  protected processGetRecent(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfAuditLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getLogCountByUser(userId: string): Observable<ResultOfInteger> {
    let url_ = this.baseUrl + '/api/AuditLog/count/by-user/{userId}';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLogCountByUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLogCountByUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfInteger>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        })
      );
  }

  protected processGetLogCountByUser(response: HttpResponseBase): Observable<ResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getLogCountByAction(action: string | undefined): Observable<ResultOfInteger> {
    let url_ = this.baseUrl + '/api/AuditLog/count/by-action?';
    if (action === null) throw new globalThis.Error("The parameter 'action' cannot be null.");
    else if (action !== undefined) url_ += 'action=' + encodeURIComponent('' + action) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLogCountByAction(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLogCountByAction(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfInteger>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        })
      );
  }

  protected processGetLogCountByAction(response: HttpResponseBase): Observable<ResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getActionStatistics(
    from: Date | undefined,
    to: Date | undefined
  ): Observable<ResultOfDictionaryOfStringAndInteger> {
    let url_ = this.baseUrl + '/api/AuditLog/stats?';
    if (from === null) throw new globalThis.Error("The parameter 'from' cannot be null.");
    else if (from !== undefined)
      url_ += 'from=' + encodeURIComponent(from ? '' + from.toISOString() : '') + '&';
    if (to === null) throw new globalThis.Error("The parameter 'to' cannot be null.");
    else if (to !== undefined)
      url_ += 'to=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActionStatistics(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActionStatistics(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfDictionaryOfStringAndInteger>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfDictionaryOfStringAndInteger>;
        })
      );
  }

  protected processGetActionStatistics(
    response: HttpResponseBase
  ): Observable<ResultOfDictionaryOfStringAndInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfDictionaryOfStringAndInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class AuthClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  registerAccount(request: RegisterCommand): Observable<ResultOfRegisterResponse> {
    let url_ = this.baseUrl + '/api/Auth/register';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRegisterAccount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRegisterAccount(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfRegisterResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfRegisterResponse>;
        })
      );
  }

  protected processRegisterAccount(
    response: HttpResponseBase
  ): Observable<ResultOfRegisterResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfRegisterResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  login(request: LoginCommand): Observable<ResultOfLoginResponse> {
    let url_ = this.baseUrl + '/api/Auth/login';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfLoginResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfLoginResponse>;
        })
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<ResultOfLoginResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfLoginResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  forgotPassword(request: ForgotPasswordCommand): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Auth/forgot-password';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processForgotPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processForgotPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processForgotPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  resetPassword(request: ResetPasswordCommand): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Auth/reset-password';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  logout(request: LogoutCommand): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Auth/logout';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogout(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogout(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processLogout(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  refreshToken(request: RefreshTokenCommand): Observable<ResultOfRefreshTokenResponse> {
    let url_ = this.baseUrl + '/api/Auth/refresh-token';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfRefreshTokenResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfRefreshTokenResponse>;
        })
      );
  }

  protected processRefreshToken(
    response: HttpResponseBase
  ): Observable<ResultOfRefreshTokenResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfRefreshTokenResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class BrandClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getBrandsPaging(
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/paging?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBrandsPaging(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBrandsPaging(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetBrandsPaging(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProductCountByBrand(brandId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/product-count/{brandId}';
    if (brandId === undefined || brandId === null)
      throw new globalThis.Error("The parameter 'brandId' must be defined.");
    url_ = url_.replace('{brandId}', encodeURIComponent('' + brandId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductCountByBrand(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductCountByBrand(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetProductCountByBrand(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBrandById(brandId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/{brandId}';
    if (brandId === undefined || brandId === null)
      throw new globalThis.Error("The parameter 'brandId' must be defined.");
    url_ = url_.replace('{brandId}', encodeURIComponent('' + brandId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBrandById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBrandById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetBrandById(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateBrand(brandId: string, request: UpdateBrandCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/{brandId}';
    if (brandId === undefined || brandId === null)
      throw new globalThis.Error("The parameter 'brandId' must be defined.");
    url_ = url_.replace('{brandId}', encodeURIComponent('' + brandId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateBrand(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateBrand(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateBrand(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteBrand(brandId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/{brandId}';
    if (brandId === undefined || brandId === null)
      throw new globalThis.Error("The parameter 'brandId' must be defined.");
    url_ = url_.replace('{brandId}', encodeURIComponent('' + brandId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteBrand(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteBrand(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteBrand(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBrandByName(name: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/name/{name}';
    if (name === undefined || name === null)
      throw new globalThis.Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBrandByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBrandByName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetBrandByName(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBrandBySlug(slug: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/slug/{slug}';
    if (slug === undefined || slug === null)
      throw new globalThis.Error("The parameter 'slug' must be defined.");
    url_ = url_.replace('{slug}', encodeURIComponent('' + slug));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBrandBySlug(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBrandBySlug(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetBrandBySlug(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createBrand(request: CreateBrandCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateBrand(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateBrand(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processCreateBrand(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateBrandStatus(brandId: string, request: UpdateBrandStatusCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/Brand/status/{brandId}';
    if (brandId === undefined || brandId === null)
      throw new globalThis.Error("The parameter 'brandId' must be defined.");
    url_ = url_.replace('{brandId}', encodeURIComponent('' + brandId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateBrandStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateBrandStatus(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateBrandStatus(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class CartClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getShoppingCart(userId: string): Observable<ResultOfShoppingCartDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShoppingCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShoppingCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfShoppingCartDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfShoppingCartDto>;
        })
      );
  }

  protected processGetShoppingCart(
    response: HttpResponseBase
  ): Observable<ResultOfShoppingCartDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfShoppingCartDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createShoppingCart(userId: string): Observable<ResultOfShoppingCartDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateShoppingCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateShoppingCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfShoppingCartDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfShoppingCartDto>;
        })
      );
  }

  protected processCreateShoppingCart(
    response: HttpResponseBase
  ): Observable<ResultOfShoppingCartDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfShoppingCartDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  clearShoppingCart(userId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processClearShoppingCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processClearShoppingCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processClearShoppingCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCartTotal(userId: string): Observable<ResultOfDecimal> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/total';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCartTotal(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCartTotal(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfDecimal>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfDecimal>;
        })
      );
  }

  protected processGetCartTotal(response: HttpResponseBase): Observable<ResultOfDecimal> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfDecimal.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCartItemCount(userId: string): Observable<ResultOfInteger> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/count';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCartItemCount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCartItemCount(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfInteger>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        })
      );
  }

  protected processGetCartItemCount(response: HttpResponseBase): Observable<ResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCartSummary(userId: string): Observable<ResultOfCartSummaryDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/summary';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCartSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCartSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCartSummaryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCartSummaryDto>;
        })
      );
  }

  protected processGetCartSummary(response: HttpResponseBase): Observable<ResultOfCartSummaryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCartSummaryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getShoppingCartItems(userId: string): Observable<ResultOfListOfShoppingCartItemDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/items';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetShoppingCartItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetShoppingCartItems(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfShoppingCartItemDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfListOfShoppingCartItemDto>;
        })
      );
  }

  protected processGetShoppingCartItems(
    response: HttpResponseBase
  ): Observable<ResultOfListOfShoppingCartItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfShoppingCartItemDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addItemToCart(request: AddToCartRequest): Observable<ResultOfShoppingCartItemDto> {
    let url_ = this.baseUrl + '/api/Cart/items';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddItemToCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddItemToCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfShoppingCartItemDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfShoppingCartItemDto>;
        })
      );
  }

  protected processAddItemToCart(
    response: HttpResponseBase
  ): Observable<ResultOfShoppingCartItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfShoppingCartItemDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateCartItemQuantity(
    itemId: string,
    request: UpdateQuantityRequest
  ): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/items/{itemId}/quantity';
    if (itemId === undefined || itemId === null)
      throw new globalThis.Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCartItemQuantity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCartItemQuantity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processUpdateCartItemQuantity(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeItemFromCart(itemId: string, request: RemoveItemRequest): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/items/{itemId}';
    if (itemId === undefined || itemId === null)
      throw new globalThis.Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveItemFromCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveItemFromCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processRemoveItemFromCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeItemByProduct(
    userId: string,
    productId: string,
    variantId: string | null | undefined
  ): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/products/{productId}?';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (variantId !== undefined && variantId !== null)
      url_ += 'variantId=' + encodeURIComponent('' + variantId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveItemByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveItemByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processRemoveItemByProduct(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  validateCartItems(userId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/validate';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processValidateCartItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processValidateCartItems(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processValidateCartItems(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getWishlist(userId: string): Observable<ResultOfWishlistDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfWishlistDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfWishlistDto>;
        })
      );
  }

  protected processGetWishlist(response: HttpResponseBase): Observable<ResultOfWishlistDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfWishlistDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createWishlist(userId: string): Observable<ResultOfWishlistDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfWishlistDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfWishlistDto>;
        })
      );
  }

  protected processCreateWishlist(response: HttpResponseBase): Observable<ResultOfWishlistDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfWishlistDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getWishlistItems(userId: string): Observable<ResultOfListOfWishlistItemDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist/items';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetWishlistItems(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetWishlistItems(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfWishlistItemDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfListOfWishlistItemDto>;
        })
      );
  }

  protected processGetWishlistItems(
    response: HttpResponseBase
  ): Observable<ResultOfListOfWishlistItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfWishlistItemDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addItemToWishlist(
    userId: string,
    request: AddToWishlistRequest
  ): Observable<ResultOfWishlistItemDto> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist/items';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddItemToWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddItemToWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfWishlistItemDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfWishlistItemDto>;
        })
      );
  }

  protected processAddItemToWishlist(
    response: HttpResponseBase
  ): Observable<ResultOfWishlistItemDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfWishlistItemDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeItemFromWishlist(userId: string, itemId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist/items/{itemId}';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (itemId === undefined || itemId === null)
      throw new globalThis.Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveItemFromWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveItemFromWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processRemoveItemFromWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeItemByProductFromWishlist(
    userId: string,
    productId: string,
    variantId: string | null | undefined
  ): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist/products/{productId}?';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (variantId !== undefined && variantId !== null)
      url_ += 'variantId=' + encodeURIComponent('' + variantId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveItemByProductFromWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveItemByProductFromWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processRemoveItemByProductFromWishlist(
    response: HttpResponseBase
  ): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  isProductInWishlist(
    userId: string,
    productId: string,
    variantId: string | null | undefined
  ): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist/products/{productId}/check?';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (variantId !== undefined && variantId !== null)
      url_ += 'variantId=' + encodeURIComponent('' + variantId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processIsProductInWishlist(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processIsProductInWishlist(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processIsProductInWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  moveItemToCart(
    userId: string,
    itemId: string,
    request: MoveToCartRequest
  ): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/wishlist/items/{itemId}/move-to-cart';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    if (itemId === undefined || itemId === null)
      throw new globalThis.Error("The parameter 'itemId' must be defined.");
    url_ = url_.replace('{itemId}', encodeURIComponent('' + itemId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMoveItemToCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMoveItemToCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processMoveItemToCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  mergeCarts(userId: string, request: MergeCartsRequest): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/merge';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMergeCarts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMergeCarts(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processMergeCarts(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  applyCoupon(userId: string, request: ApplyCouponRequest): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/coupon';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApplyCoupon(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApplyCoupon(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processApplyCoupon(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeCoupon(userId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/coupon';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveCoupon(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveCoupon(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processRemoveCoupon(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  saveCartForLater(userId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/save-for-later';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSaveCartForLater(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSaveCartForLater(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processSaveCartForLater(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  restoreSavedCart(userId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Cart/users/{userId}/restore';
    if (userId === undefined || userId === null)
      throw new globalThis.Error("The parameter 'userId' must be defined.");
    url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRestoreSavedCart(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRestoreSavedCart(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processRestoreSavedCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class CategoryClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getCategoriesPaging(
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/paging?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoriesPaging(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoriesPaging(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfCategoryDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfCategoryDto>;
        })
      );
  }

  protected processGetCategoriesPaging(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProductCountByCategory(categoryId: string): Observable<ResultOfInteger> {
    let url_ = this.baseUrl + '/api/Category/product-count/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductCountByCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductCountByCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfInteger>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        })
      );
  }

  protected processGetProductCountByCategory(
    response: HttpResponseBase
  ): Observable<ResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getSubCategories(categoryId: string): Observable<ResultOfListOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/sub-categories/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetSubCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetSubCategories(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        })
      );
  }

  protected processGetSubCategories(
    response: HttpResponseBase
  ): Observable<ResultOfListOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCategoryPath(categoryId: string): Observable<ResultOfListOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/category-path/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryPath(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryPath(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        })
      );
  }

  protected processGetCategoryPath(
    response: HttpResponseBase
  ): Observable<ResultOfListOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCategoryTree(): Observable<ResultOfListOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/category-tree';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryTree(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryTree(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        })
      );
  }

  protected processGetCategoryTree(
    response: HttpResponseBase
  ): Observable<ResultOfListOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getRootCategories(): Observable<ResultOfListOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/root-categories';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRootCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRootCategories(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        })
      );
  }

  protected processGetRootCategories(
    response: HttpResponseBase
  ): Observable<ResultOfListOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getActiveCategories(): Observable<ResultOfListOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/active-categories';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActiveCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActiveCategories(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        })
      );
  }

  protected processGetActiveCategories(
    response: HttpResponseBase
  ): Observable<ResultOfListOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCategoryById(categoryId: string): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processGetCategoryById(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateCategory(
    categoryId: string,
    request: UpdateCategoryCommand
  ): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processUpdateCategory(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteCategory(categoryId: string): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processDeleteCategory(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCategoryByName(name: string): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/name/{name}';
    if (name === undefined || name === null)
      throw new globalThis.Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryByName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processGetCategoryByName(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCategoryBySlug(slug: string): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/slug/{slug}';
    if (slug === undefined || slug === null)
      throw new globalThis.Error("The parameter 'slug' must be defined.");
    url_ = url_.replace('{slug}', encodeURIComponent('' + slug));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCategoryBySlug(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCategoryBySlug(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processGetCategoryBySlug(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createCategory(request: CreateCategoryCommand): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processCreateCategory(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkCategoryExistsById(categoryId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Category';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckCategoryExistsById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckCategoryExistsById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckCategoryExistsById(
    response: HttpResponseBase
  ): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateCategoryStatus(
    categoryId: string,
    request: UpdateCategoryStatusCommand
  ): Observable<ResultOfCategoryDto> {
    let url_ = this.baseUrl + '/api/Category/status/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCategoryStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCategoryStatus(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        })
      );
  }

  protected processUpdateCategoryStatus(
    response: HttpResponseBase
  ): Observable<ResultOfCategoryDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCategoryDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkCategoryExistsByName(name: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Category/exists-by-name/{name}';
    if (name === undefined || name === null)
      throw new globalThis.Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckCategoryExistsByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckCategoryExistsByName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckCategoryExistsByName(
    response: HttpResponseBase
  ): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkCategoryHasSubCategories(categoryId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Category/has-sub-categories/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckCategoryHasSubCategories(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckCategoryHasSubCategories(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckCategoryHasSubCategories(
    response: HttpResponseBase
  ): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkCategoryInUse(categoryId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Category/in-use/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckCategoryInUse(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckCategoryInUse(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckCategoryInUse(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkIsRootCategory(categoryId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Category/is-root/{categoryId}';
    if (categoryId === undefined || categoryId === null)
      throw new globalThis.Error("The parameter 'categoryId' must be defined.");
    url_ = url_.replace('{categoryId}', encodeURIComponent('' + categoryId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckIsRootCategory(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckIsRootCategory(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckIsRootCategory(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class FileUploadClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  uploadImage(file: FileParameter | null | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/FileUpload/upload-image';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file');

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadImage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUploadImage(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  uploadMultipleImages(files: FileParameter[] | null | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/FileUpload/upload-multiple-images';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (files !== null && files !== undefined)
      files.forEach((item_) =>
        content_.append('files', item_.data, item_.fileName ? item_.fileName : 'files')
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadMultipleImages(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadMultipleImages(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUploadMultipleImages(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteImage(blobName: string | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/FileUpload/delete-image?';
    if (blobName === null) throw new globalThis.Error("The parameter 'blobName' cannot be null.");
    else if (blobName !== undefined) url_ += 'blobName=' + encodeURIComponent('' + blobName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteImage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteImage(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ImageClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  uploadImage(file: FileParameter | null | undefined): Observable<ResultOfString> {
    let url_ = this.baseUrl + '/api/Image/upload';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file');

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadImage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfString>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfString>;
        })
      );
  }

  protected processUploadImage(response: HttpResponseBase): Observable<ResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getImageUrl(blobName: string, policyName: string | undefined): Observable<ResultOfString> {
    let url_ = this.baseUrl + '/api/Image/{blobName}/url?';
    if (blobName === undefined || blobName === null)
      throw new globalThis.Error("The parameter 'blobName' must be defined.");
    url_ = url_.replace('{blobName}', encodeURIComponent('' + blobName));
    if (policyName === null)
      throw new globalThis.Error("The parameter 'policyName' cannot be null.");
    else if (policyName !== undefined)
      url_ += 'policyName=' + encodeURIComponent('' + policyName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetImageUrl(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetImageUrl(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfString>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfString>;
        })
      );
  }

  protected processGetImageUrl(response: HttpResponseBase): Observable<ResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getContainerUrl(policyName: string | undefined): Observable<ResultOfString> {
    let url_ = this.baseUrl + '/api/Image/container/url?';
    if (policyName === null)
      throw new globalThis.Error("The parameter 'policyName' cannot be null.");
    else if (policyName !== undefined)
      url_ += 'policyName=' + encodeURIComponent('' + policyName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContainerUrl(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContainerUrl(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfString>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfString>;
        })
      );
  }

  protected processGetContainerUrl(response: HttpResponseBase): Observable<ResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateImage(
    blobName: string,
    file: FileParameter | null | undefined
  ): Observable<ResultOfString> {
    let url_ = this.baseUrl + '/api/Image/{blobName}';
    if (blobName === undefined || blobName === null)
      throw new globalThis.Error("The parameter 'blobName' must be defined.");
    url_ = url_.replace('{blobName}', encodeURIComponent('' + blobName));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append('file', file.data, file.fileName ? file.fileName : 'file');

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateImage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfString>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfString>;
        })
      );
  }

  protected processUpdateImage(response: HttpResponseBase): Observable<ResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteImage(blobName: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Image/{blobName}';
    if (blobName === undefined || blobName === null)
      throw new globalThis.Error("The parameter 'blobName' must be defined.");
    url_ = url_.replace('{blobName}', encodeURIComponent('' + blobName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteImage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteImage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDeleteImage(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  imageExists(blobName: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/Image/{blobName}/exists';
    if (blobName === undefined || blobName === null)
      throw new globalThis.Error("The parameter 'blobName' must be defined.");
    url_ = url_.replace('{blobName}', encodeURIComponent('' + blobName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processImageExists(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processImageExists(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processImageExists(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getImageMetadata(blobName: string): Observable<ResultOfObject> {
    let url_ = this.baseUrl + '/api/Image/{blobName}/metadata';
    if (blobName === undefined || blobName === null)
      throw new globalThis.Error("The parameter 'blobName' must be defined.");
    url_ = url_.replace('{blobName}', encodeURIComponent('' + blobName));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetImageMetadata(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetImageMetadata(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfObject>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfObject>;
        })
      );
  }

  protected processGetImageMetadata(response: HttpResponseBase): Observable<ResultOfObject> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfObject.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  listImages(prefix: string | undefined): Observable<ResultOfListOfString> {
    let url_ = this.baseUrl + '/api/Image/list?';
    if (prefix === null) throw new globalThis.Error("The parameter 'prefix' cannot be null.");
    else if (prefix !== undefined) url_ += 'prefix=' + encodeURIComponent('' + prefix) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processListImages(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processListImages(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfString>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfString>;
        })
      );
  }

  protected processListImages(response: HttpResponseBase): Observable<ResultOfListOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  uploadMultipleImages(
    files: FileParameter[] | null | undefined
  ): Observable<ResultOfListOfString> {
    let url_ = this.baseUrl + '/api/Image/upload-multiple';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (files !== null && files !== undefined)
      files.forEach((item_) =>
        content_.append('files', item_.data, item_.fileName ? item_.fileName : 'files')
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadMultipleImages(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadMultipleImages(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfListOfString>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfListOfString>;
        })
      );
  }

  protected processUploadMultipleImages(
    response: HttpResponseBase
  ): Observable<ResultOfListOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfListOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductAttributeClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  checkAttributeExistsById(attributeId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductAttribute/exists-by-id/{attributeId}';
    if (attributeId === undefined || attributeId === null)
      throw new globalThis.Error("The parameter 'attributeId' must be defined.");
    url_ = url_.replace('{attributeId}', encodeURIComponent('' + attributeId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckAttributeExistsById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckAttributeExistsById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckAttributeExistsById(
    response: HttpResponseBase
  ): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkAttributeExistsByName(name: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductAttribute/exists-by-name/{name}';
    if (name === undefined || name === null)
      throw new globalThis.Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckAttributeExistsByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckAttributeExistsByName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckAttributeExistsByName(
    response: HttpResponseBase
  ): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  checkAttributeInUse(attributeId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductAttribute/in-use/{attributeId}';
    if (attributeId === undefined || attributeId === null)
      throw new globalThis.Error("The parameter 'attributeId' must be defined.");
    url_ = url_.replace('{attributeId}', encodeURIComponent('' + attributeId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCheckAttributeInUse(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCheckAttributeInUse(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processCheckAttributeInUse(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAllAttributes(): Observable<ResultOfPagedResultOfProductAttributeDto> {
    let url_ = this.baseUrl + '/api/ProductAttribute/all';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllAttributes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllAttributes(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        })
      );
  }

  protected processGetAllAttributes(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductAttributeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAttributeById(attributeId: string): Observable<ResultOfProductAttributeDto> {
    let url_ = this.baseUrl + '/api/ProductAttribute/by-id/{attributeId}';
    if (attributeId === undefined || attributeId === null)
      throw new globalThis.Error("The parameter 'attributeId' must be defined.");
    url_ = url_.replace('{attributeId}', encodeURIComponent('' + attributeId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAttributeById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAttributeById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfProductAttributeDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfProductAttributeDto>;
        })
      );
  }

  protected processGetAttributeById(
    response: HttpResponseBase
  ): Observable<ResultOfProductAttributeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfProductAttributeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAttributeByName(name: string): Observable<ResultOfProductAttributeDto> {
    let url_ = this.baseUrl + '/api/ProductAttribute/by-name/{name}';
    if (name === undefined || name === null)
      throw new globalThis.Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAttributeByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAttributeByName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfProductAttributeDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfProductAttributeDto>;
        })
      );
  }

  protected processGetAttributeByName(
    response: HttpResponseBase
  ): Observable<ResultOfProductAttributeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfProductAttributeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAttributesByType(
    attributeType: number | undefined,
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductAttributeDto> {
    let url_ = this.baseUrl + '/api/ProductAttribute/by-type?';
    if (attributeType === null)
      throw new globalThis.Error("The parameter 'attributeType' cannot be null.");
    else if (attributeType !== undefined)
      url_ += 'attributeType=' + encodeURIComponent('' + attributeType) + '&';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAttributesByType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAttributesByType(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        })
      );
  }

  protected processGetAttributesByType(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductAttributeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getRequiredAttributes(
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductAttributeDto> {
    let url_ = this.baseUrl + '/api/ProductAttribute/required?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRequiredAttributes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRequiredAttributes(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        })
      );
  }

  protected processGetRequiredAttributes(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductAttributeDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createAttribute(
    command: CreateProductAttributeCommand
  ): Observable<ResultOfCreateProductAttributeResponse> {
    let url_ = this.baseUrl + '/api/ProductAttribute/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateAttribute(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateAttribute(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfCreateProductAttributeResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfCreateProductAttributeResponse>;
        })
      );
  }

  protected processCreateAttribute(
    response: HttpResponseBase
  ): Observable<ResultOfCreateProductAttributeResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductAttributeResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateAttribute(
    command: UpdateProductAttributeCommand
  ): Observable<ResultOfUpdateProductAttributeResponse> {
    let url_ = this.baseUrl + '/api/ProductAttribute/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateAttribute(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateAttribute(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfUpdateProductAttributeResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfUpdateProductAttributeResponse>;
        })
      );
  }

  protected processUpdateAttribute(
    response: HttpResponseBase
  ): Observable<ResultOfUpdateProductAttributeResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfUpdateProductAttributeResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteAttribute(attributeId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductAttribute/delete/{attributeId}';
    if (attributeId === undefined || attributeId === null)
      throw new globalThis.Error("The parameter 'attributeId' must be defined.");
    url_ = url_.replace('{attributeId}', encodeURIComponent('' + attributeId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteAttribute(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteAttribute(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDeleteAttribute(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductAttributeValueClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getById(valueId: string): Observable<ResultOfProductAttributeValueDto> {
    let url_ = this.baseUrl + '/api/ProductAttributeValue/by-id/{valueId}';
    if (valueId === undefined || valueId === null)
      throw new globalThis.Error("The parameter 'valueId' must be defined.");
    url_ = url_.replace('{valueId}', encodeURIComponent('' + valueId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfProductAttributeValueDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfProductAttributeValueDto>;
        })
      );
  }

  protected processGetById(
    response: HttpResponseBase
  ): Observable<ResultOfProductAttributeValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfProductAttributeValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByProduct(
    productId: string,
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
    let url_ = this.baseUrl + '/api/ProductAttributeValue/by-product/{productId}?';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
        })
      );
  }

  protected processGetByProduct(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductAttributeValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByAttribute(
    attributeId: string,
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
    let url_ = this.baseUrl + '/api/ProductAttributeValue/by-attribute/{attributeId}?';
    if (attributeId === undefined || attributeId === null)
      throw new globalThis.Error("The parameter 'attributeId' must be defined.");
    url_ = url_.replace('{attributeId}', encodeURIComponent('' + attributeId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByAttribute(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByAttribute(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
        })
      );
  }

  protected processGetByAttribute(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductAttributeValueDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(
    command: CreateProductAttributeValueCommand
  ): Observable<ResultOfCreateProductAttributeValueResponse> {
    let url_ = this.baseUrl + '/api/ProductAttributeValue/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfCreateProductAttributeValueResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfCreateProductAttributeValueResponse>;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<ResultOfCreateProductAttributeValueResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductAttributeValueResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    command: UpdateProductAttributeValueCommand
  ): Observable<ResultOfUpdateProductAttributeValueResponse> {
    let url_ = this.baseUrl + '/api/ProductAttributeValue/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfUpdateProductAttributeValueResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfUpdateProductAttributeValueResponse>;
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ResultOfUpdateProductAttributeValueResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfUpdateProductAttributeValueResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(valueId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductAttributeValue/delete/{valueId}';
    if (valueId === undefined || valueId === null)
      throw new globalThis.Error("The parameter 'valueId' must be defined.");
    url_ = url_.replace('{valueId}', encodeURIComponent('' + valueId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  create(
    name: string | undefined,
    slug: string | null | undefined,
    sku: string | undefined,
    description: string | undefined,
    shortDescription: string | null | undefined,
    price: number | undefined,
    discountPrice: number | null | undefined,
    cost: number | null | undefined,
    stockQuantity: number | undefined,
    minStockLevel: number | undefined,
    weight: number | null | undefined,
    dimensions: string | null | undefined,
    categoryId: string | undefined,
    brandId: string | null | undefined,
    status: number | undefined,
    isFeatured: boolean | undefined,
    isDigital: boolean | undefined,
    metaTitle: string | null | undefined,
    metaDescription: string | null | undefined,
    imageFiles: FileParameter[] | null | undefined,
    imageAltTexts: string[] | null | undefined,
    imageDisplayOrders: number[] | null | undefined,
    imageIsPrimary: boolean[] | null | undefined,
    variants: CreateProductVariantRequest[] | null | undefined,
    attributes: CreateProductAttributeValueRequest[] | null | undefined,
    tagIds: string[] | null | undefined
  ): Observable<ResultOfCreateProductResponse> {
    let url_ = this.baseUrl + '/api/Product/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (name === null || name === undefined)
      throw new globalThis.Error("The parameter 'name' cannot be null.");
    else content_.append('Name', name.toString());
    if (slug !== null && slug !== undefined) content_.append('Slug', slug.toString());
    if (sku === null || sku === undefined)
      throw new globalThis.Error("The parameter 'sku' cannot be null.");
    else content_.append('Sku', sku.toString());
    if (description === null || description === undefined)
      throw new globalThis.Error("The parameter 'description' cannot be null.");
    else content_.append('Description', description.toString());
    if (shortDescription !== null && shortDescription !== undefined)
      content_.append('ShortDescription', shortDescription.toString());
    if (price === null || price === undefined)
      throw new globalThis.Error("The parameter 'price' cannot be null.");
    else content_.append('Price', price.toString());
    if (discountPrice !== null && discountPrice !== undefined)
      content_.append('DiscountPrice', discountPrice.toString());
    if (cost !== null && cost !== undefined) content_.append('Cost', cost.toString());
    if (stockQuantity === null || stockQuantity === undefined)
      throw new globalThis.Error("The parameter 'stockQuantity' cannot be null.");
    else content_.append('StockQuantity', stockQuantity.toString());
    if (minStockLevel === null || minStockLevel === undefined)
      throw new globalThis.Error("The parameter 'minStockLevel' cannot be null.");
    else content_.append('MinStockLevel', minStockLevel.toString());
    if (weight !== null && weight !== undefined) content_.append('Weight', weight.toString());
    if (dimensions !== null && dimensions !== undefined)
      content_.append('Dimensions', dimensions.toString());
    if (categoryId === null || categoryId === undefined)
      throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
    else content_.append('CategoryId', categoryId.toString());
    if (brandId !== null && brandId !== undefined) content_.append('BrandId', brandId.toString());
    if (status === null || status === undefined)
      throw new globalThis.Error("The parameter 'status' cannot be null.");
    else content_.append('Status', status.toString());
    if (isFeatured === null || isFeatured === undefined)
      throw new globalThis.Error("The parameter 'isFeatured' cannot be null.");
    else content_.append('IsFeatured', isFeatured.toString());
    if (isDigital === null || isDigital === undefined)
      throw new globalThis.Error("The parameter 'isDigital' cannot be null.");
    else content_.append('IsDigital', isDigital.toString());
    if (metaTitle !== null && metaTitle !== undefined)
      content_.append('MetaTitle', metaTitle.toString());
    if (metaDescription !== null && metaDescription !== undefined)
      content_.append('MetaDescription', metaDescription.toString());
    if (imageFiles !== null && imageFiles !== undefined)
      imageFiles.forEach((item_) =>
        content_.append('ImageFiles', item_.data, item_.fileName ? item_.fileName : 'ImageFiles')
      );
    if (imageAltTexts !== null && imageAltTexts !== undefined)
      imageAltTexts.forEach((item_) => content_.append('ImageAltTexts', item_.toString()));
    if (imageDisplayOrders !== null && imageDisplayOrders !== undefined)
      imageDisplayOrders.forEach((item_) =>
        content_.append('ImageDisplayOrders', item_.toString())
      );
    if (imageIsPrimary !== null && imageIsPrimary !== undefined)
      imageIsPrimary.forEach((item_) => content_.append('ImageIsPrimary', item_.toString()));
    if (variants !== null && variants !== undefined)
      variants.forEach((item_) => content_.append('Variants', item_.toString()));
    if (attributes !== null && attributes !== undefined)
      attributes.forEach((item_) => content_.append('Attributes', item_.toString()));
    if (tagIds !== null && tagIds !== undefined)
      tagIds.forEach((item_) => content_.append('TagIds', item_.toString()));

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCreateProductResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfCreateProductResponse>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createWithUrls(command: CreateProductCommand): Observable<ResultOfCreateProductResponse> {
    let url_ = this.baseUrl + '/api/Product/create-with-urls';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateWithUrls(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateWithUrls(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCreateProductResponse>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfCreateProductResponse>;
        })
      );
  }

  protected processCreateWithUrls(
    response: HttpResponseBase
  ): Observable<ResultOfCreateProductResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProductsPaging(
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductBaseResponse> {
    let url_ = this.baseUrl + '/api/Product/paging?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductsPaging(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductsPaging(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductBaseResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductBaseResponse>;
        })
      );
  }

  protected processGetProductsPaging(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductBaseResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductBaseResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductImageClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getById(imageId: string): Observable<ResultOfProductImageDto> {
    let url_ = this.baseUrl + '/api/ProductImage/by-id/{imageId}';
    if (imageId === undefined || imageId === null)
      throw new globalThis.Error("The parameter 'imageId' must be defined.");
    url_ = url_.replace('{imageId}', encodeURIComponent('' + imageId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfProductImageDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfProductImageDto>;
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<ResultOfProductImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfProductImageDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByProduct(
    productId: string,
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductImageDto> {
    let url_ = this.baseUrl + '/api/ProductImage/by-product/{productId}?';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductImageDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductImageDto>;
        })
      );
  }

  protected processGetByProduct(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductImageDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductImageDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(command: CreateProductImageCommand): Observable<ResultOfCreateProductImageResponse> {
    let url_ = this.baseUrl + '/api/ProductImage/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCreateProductImageResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfCreateProductImageResponse>;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<ResultOfCreateProductImageResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductImageResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(command: UpdateProductImageCommand): Observable<ResultOfUpdateProductImageResponse> {
    let url_ = this.baseUrl + '/api/ProductImage/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfUpdateProductImageResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfUpdateProductImageResponse>;
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ResultOfUpdateProductImageResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfUpdateProductImageResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  setPrimary(imageId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductImage/set-primary/{imageId}';
    if (imageId === undefined || imageId === null)
      throw new globalThis.Error("The parameter 'imageId' must be defined.");
    url_ = url_.replace('{imageId}', encodeURIComponent('' + imageId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSetPrimary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSetPrimary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processSetPrimary(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(imageId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductImage/delete/{imageId}';
    if (imageId === undefined || imageId === null)
      throw new globalThis.Error("The parameter 'imageId' must be defined.");
    url_ = url_.replace('{imageId}', encodeURIComponent('' + imageId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductQuestionClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getById(questionId: string): Observable<ResultOfProductQuestionDto> {
    let url_ = this.baseUrl + '/api/ProductQuestion/by-id/{questionId}';
    if (questionId === undefined || questionId === null)
      throw new globalThis.Error("The parameter 'questionId' must be defined.");
    url_ = url_.replace('{questionId}', encodeURIComponent('' + questionId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfProductQuestionDto>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ResultOfProductQuestionDto>;
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<ResultOfProductQuestionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfProductQuestionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByProduct(
    productId: string,
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductQuestionDto> {
    let url_ = this.baseUrl + '/api/ProductQuestion/by-product/{productId}?';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
        })
      );
  }

  protected processGetByProduct(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductQuestionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductQuestionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getUnanswered(
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<ResultOfPagedResultOfProductQuestionDto> {
    let url_ = this.baseUrl + '/api/ProductQuestion/unanswered?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUnanswered(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUnanswered(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
        })
      );
  }

  protected processGetUnanswered(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductQuestionDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductQuestionDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(command: CreateProductQuestionCommand): Observable<ResultOfCreateProductQuestionResponse> {
    let url_ = this.baseUrl + '/api/ProductQuestion/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfCreateProductQuestionResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfCreateProductQuestionResponse>;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<ResultOfCreateProductQuestionResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductQuestionResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(command: UpdateProductQuestionCommand): Observable<ResultOfUpdateProductQuestionResponse> {
    let url_ = this.baseUrl + '/api/ProductQuestion/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfUpdateProductQuestionResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfUpdateProductQuestionResponse>;
        })
      );
  }

  protected processUpdate(
    response: HttpResponseBase
  ): Observable<ResultOfUpdateProductQuestionResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfUpdateProductQuestionResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  answer(command: AnswerProductQuestionCommand): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductQuestion/answer';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAnswer(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAnswer(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processAnswer(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(questionId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductQuestion/delete/{questionId}';
    if (questionId === undefined || questionId === null)
      throw new globalThis.Error("The parameter 'questionId' must be defined.");
    url_ = url_.replace('{questionId}', encodeURIComponent('' + questionId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductTagAssignmentClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  assignTagToProduct(request: AssignTagToProductCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTagAssignment';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignTagToProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignTagToProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processAssignTagToProduct(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeTagFromProduct(productId: string, tagId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTagAssignment/{productId}/{tagId}';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (tagId === undefined || tagId === null)
      throw new globalThis.Error("The parameter 'tagId' must be defined.");
    url_ = url_.replace('{tagId}', encodeURIComponent('' + tagId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveTagFromProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveTagFromProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processRemoveTagFromProduct(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeAllTagsFromProduct(productId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTagAssignment/product/{productId}';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveAllTagsFromProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveAllTagsFromProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processRemoveAllTagsFromProduct(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByProduct(
    productId: string,
    page: number | undefined,
    pageSize: number | undefined,
    sortBy: string | null | undefined,
    sortDirection: string | null | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTagAssignment/product/{productId}?';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'pageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection !== undefined && sortDirection !== null)
      url_ += 'sortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetByProduct(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByTag(
    tagId: string,
    page: number | undefined,
    pageSize: number | undefined,
    sortBy: string | null | undefined,
    sortDirection: string | null | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTagAssignment/tag/{tagId}?';
    if (tagId === undefined || tagId === null)
      throw new globalThis.Error("The parameter 'tagId' must be defined.");
    url_ = url_.replace('{tagId}', encodeURIComponent('' + tagId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'pageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection !== undefined && sortDirection !== null)
      url_ += 'sortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByTag(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByTag(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetByTag(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductTagClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  getProductTagsPaging(
    page: number | undefined,
    pageSize: number | undefined,
    search: string | null | undefined,
    sortBy: string | null | undefined,
    sortDirection: SortDirection | undefined,
    filters: FilterCriteria[] | undefined,
    entityType: string | null | undefined,
    availableFields: SearchableField[] | null | undefined,
    hasFilters: boolean | undefined,
    hasSearch: boolean | undefined,
    hasSorting: boolean | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTag/paging?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'Page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'PageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection === null)
      throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
    else if (sortDirection !== undefined)
      url_ += 'SortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (filters === null) throw new globalThis.Error("The parameter 'filters' cannot be null.");
    else if (filters !== undefined)
      filters &&
        filters.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'Filters[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (entityType !== undefined && entityType !== null)
      url_ += 'EntityType=' + encodeURIComponent('' + entityType) + '&';
    if (availableFields !== undefined && availableFields !== null)
      availableFields &&
        availableFields.forEach((item, index) => {
          for (const attr in item)
            if (item.hasOwnProperty(attr)) {
              url_ +=
                'AvailableFields[' +
                index +
                '].' +
                attr +
                '=' +
                encodeURIComponent('' + (item as any)[attr]) +
                '&';
            }
        });
    if (hasFilters === null)
      throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
    else if (hasFilters !== undefined)
      url_ += 'HasFilters=' + encodeURIComponent('' + hasFilters) + '&';
    if (hasSearch === null) throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
    else if (hasSearch !== undefined)
      url_ += 'HasSearch=' + encodeURIComponent('' + hasSearch) + '&';
    if (hasSorting === null)
      throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
    else if (hasSorting !== undefined)
      url_ += 'HasSorting=' + encodeURIComponent('' + hasSorting) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductTagsPaging(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductTagsPaging(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetProductTagsPaging(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProductTagById(tagId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTag/{tagId}';
    if (tagId === undefined || tagId === null)
      throw new globalThis.Error("The parameter 'tagId' must be defined.");
    url_ = url_.replace('{tagId}', encodeURIComponent('' + tagId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductTagById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductTagById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetProductTagById(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateProductTag(tagId: string, request: UpdateProductTagCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTag/{tagId}';
    if (tagId === undefined || tagId === null)
      throw new globalThis.Error("The parameter 'tagId' must be defined.");
    url_ = url_.replace('{tagId}', encodeURIComponent('' + tagId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateProductTag(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateProductTag(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateProductTag(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteProductTag(tagId: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTag/{tagId}';
    if (tagId === undefined || tagId === null)
      throw new globalThis.Error("The parameter 'tagId' must be defined.");
    url_ = url_.replace('{tagId}', encodeURIComponent('' + tagId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteProductTag(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteProductTag(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteProductTag(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProductTagByName(name: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTag/name/{name}';
    if (name === undefined || name === null)
      throw new globalThis.Error("The parameter 'name' must be defined.");
    url_ = url_.replace('{name}', encodeURIComponent('' + name));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProductTagByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProductTagByName(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processGetProductTagByName(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createProductTag(request: CreateProductTagCommand): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/ProductTag';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateProductTag(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateProductTag(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processCreateProductTag(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

@Injectable({
  providedIn: 'root',
})
export class ProductVariantClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? 'https://localhost:44394';
  }

  createVariant(
    command: CreateProductVariantCommand
  ): Observable<ResultOfCreateProductVariantResponse> {
    let url_ = this.baseUrl + '/api/ProductVariant/create';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateVariant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateVariant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfCreateProductVariantResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfCreateProductVariantResponse>;
        })
      );
  }

  protected processCreateVariant(
    response: HttpResponseBase
  ): Observable<ResultOfCreateProductVariantResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfCreateProductVariantResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateVariant(
    command: UpdateProductVariantCommand
  ): Observable<ResultOfUpdateProductVariantResponse> {
    let url_ = this.baseUrl + '/api/ProductVariant/update';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateVariant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateVariant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfUpdateProductVariantResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfUpdateProductVariantResponse>;
        })
      );
  }

  protected processUpdateVariant(
    response: HttpResponseBase
  ): Observable<ResultOfUpdateProductVariantResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfUpdateProductVariantResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteVariant(variantId: string): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductVariant/delete/{variantId}';
    if (variantId === undefined || variantId === null)
      throw new globalThis.Error("The parameter 'variantId' must be defined.");
    url_ = url_.replace('{variantId}', encodeURIComponent('' + variantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteVariant(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteVariant(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processDeleteVariant(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateVariantStock(command: UpdateProductVariantStockCommand): Observable<ResultOfBoolean> {
    let url_ = this.baseUrl + '/api/ProductVariant/update-stock';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateVariantStock(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateVariantStock(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfBoolean>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        })
      );
  }

  protected processUpdateVariantStock(response: HttpResponseBase): Observable<ResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getById(variantId: string): Observable<ResultOfProductVariantDto> {
    let url_ = this.baseUrl + '/api/ProductVariant/by-id/{variantId}';
    if (variantId === undefined || variantId === null)
      throw new globalThis.Error("The parameter 'variantId' must be defined.");
    url_ = url_.replace('{variantId}', encodeURIComponent('' + variantId));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetById(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ResultOfProductVariantDto>;
            }
          } else return _observableThrow(response_) as any as Observable<ResultOfProductVariantDto>;
        })
      );
  }

  protected processGetById(response: HttpResponseBase): Observable<ResultOfProductVariantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfProductVariantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByProduct(
    productId: string,
    page: number | undefined,
    pageSize: number | undefined,
    sortBy: string | null | undefined,
    sortDirection: string | null | undefined
  ): Observable<ResultOfPagedResultOfProductVariantDto> {
    let url_ = this.baseUrl + '/api/ProductVariant/product/{productId}?';
    if (productId === undefined || productId === null)
      throw new globalThis.Error("The parameter 'productId' must be defined.");
    url_ = url_.replace('{productId}', encodeURIComponent('' + productId));
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'pageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection !== undefined && sortDirection !== null)
      url_ += 'sortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByProduct(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByProduct(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
        })
      );
  }

  protected processGetByProduct(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductVariantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductVariantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getLowStock(
    page: number | undefined,
    pageSize: number | undefined,
    sortBy: string | null | undefined,
    sortDirection: string | null | undefined,
    threshold: number | undefined
  ): Observable<ResultOfPagedResultOfProductVariantDto> {
    let url_ = this.baseUrl + '/api/ProductVariant/low-stock?';
    if (page === null) throw new globalThis.Error("The parameter 'page' cannot be null.");
    else if (page !== undefined) url_ += 'page=' + encodeURIComponent('' + page) + '&';
    if (pageSize === null) throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
    else if (pageSize !== undefined) url_ += 'pageSize=' + encodeURIComponent('' + pageSize) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'sortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (sortDirection !== undefined && sortDirection !== null)
      url_ += 'sortDirection=' + encodeURIComponent('' + sortDirection) + '&';
    if (threshold === null) throw new globalThis.Error("The parameter 'threshold' cannot be null.");
    else if (threshold !== undefined)
      url_ += 'threshold=' + encodeURIComponent('' + threshold) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLowStock(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLowStock(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
        })
      );
  }

  protected processGetLowStock(
    response: HttpResponseBase
  ): Observable<ResultOfPagedResultOfProductVariantDto> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ResultOfPagedResultOfProductVariantDto.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export class ResultOfPagedResultOfAuditLog implements IResultOfPagedResultOfAuditLog {
  isSuccess?: boolean;
  data?: PagedResultOfAuditLog | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfAuditLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? PagedResultOfAuditLog.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfAuditLog {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfAuditLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfAuditLog {
  isSuccess?: boolean;
  data?: PagedResultOfAuditLog | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfAuditLog implements IPagedResultOfAuditLog {
  items?: AuditLog[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfAuditLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AuditLog.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfAuditLog {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfAuditLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfAuditLog {
  items?: AuditLog[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class AuditLog implements IAuditLog {
  auditId?: string;
  userId?: string | undefined;
  action!: string;
  entity?: string | undefined;
  entityId?: string | undefined;
  detail?: string | undefined;
  createdAt?: Date;
  user?: User | undefined;

  constructor(data?: IAuditLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.auditId = _data['auditId'];
      this.userId = _data['userId'];
      this.action = _data['action'];
      this.entity = _data['entity'];
      this.entityId = _data['entityId'];
      this.detail = _data['detail'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): AuditLog {
    data = typeof data === 'object' ? data : {};
    let result = new AuditLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['auditId'] = this.auditId;
    data['userId'] = this.userId;
    data['action'] = this.action;
    data['entity'] = this.entity;
    data['entityId'] = this.entityId;
    data['detail'] = this.detail;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IAuditLog {
  auditId?: string;
  userId?: string | undefined;
  action: string;
  entity?: string | undefined;
  entityId?: string | undefined;
  detail?: string | undefined;
  createdAt?: Date;
  user?: User | undefined;
}

export class User implements IUser {
  userId?: string;
  email!: string;
  passwordHash!: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phoneNumber?: string | undefined;
  dateOfBirth?: Date | undefined;
  username!: string;
  status?: number;
  emailVerified?: boolean;
  phoneVerified?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  lastLoginAt?: Date | undefined;
  failedLoginAttempts?: number;
  lastFailedLogin?: Date | undefined;
  lockedUntil?: Date | undefined;
  userRoleAssignments?: UserRoleAssignment[];
  userAddresses?: UserAddress[];
  userSessions?: UserSession[];
  auditLogs?: AuditLog[];
  refreshTokens?: RefreshToken[];
  shoppingCarts?: ShoppingCart[];
  wishlists?: Wishlist[];
  abandonedCarts?: AbandonedCart[];
  orders?: Order[];
  couponUsages?: CouponUsage[];
  rewardPoints?: RewardPoint[];
  productReviews?: ProductReview[];

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.email = _data['email'];
      this.passwordHash = _data['passwordHash'];
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
      this.phoneNumber = _data['phoneNumber'];
      this.dateOfBirth = _data['dateOfBirth']
        ? new Date(_data['dateOfBirth'].toString())
        : (undefined as any);
      this.username = _data['username'];
      this.status = _data['status'];
      this.emailVerified = _data['emailVerified'];
      this.phoneVerified = _data['phoneVerified'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.lastLoginAt = _data['lastLoginAt']
        ? new Date(_data['lastLoginAt'].toString())
        : (undefined as any);
      this.failedLoginAttempts = _data['failedLoginAttempts'];
      this.lastFailedLogin = _data['lastFailedLogin']
        ? new Date(_data['lastFailedLogin'].toString())
        : (undefined as any);
      this.lockedUntil = _data['lockedUntil']
        ? new Date(_data['lockedUntil'].toString())
        : (undefined as any);
      if (Array.isArray(_data['userRoleAssignments'])) {
        this.userRoleAssignments = [] as any;
        for (let item of _data['userRoleAssignments'])
          this.userRoleAssignments!.push(UserRoleAssignment.fromJS(item));
      }
      if (Array.isArray(_data['userAddresses'])) {
        this.userAddresses = [] as any;
        for (let item of _data['userAddresses']) this.userAddresses!.push(UserAddress.fromJS(item));
      }
      if (Array.isArray(_data['userSessions'])) {
        this.userSessions = [] as any;
        for (let item of _data['userSessions']) this.userSessions!.push(UserSession.fromJS(item));
      }
      if (Array.isArray(_data['auditLogs'])) {
        this.auditLogs = [] as any;
        for (let item of _data['auditLogs']) this.auditLogs!.push(AuditLog.fromJS(item));
      }
      if (Array.isArray(_data['refreshTokens'])) {
        this.refreshTokens = [] as any;
        for (let item of _data['refreshTokens'])
          this.refreshTokens!.push(RefreshToken.fromJS(item));
      }
      if (Array.isArray(_data['shoppingCarts'])) {
        this.shoppingCarts = [] as any;
        for (let item of _data['shoppingCarts'])
          this.shoppingCarts!.push(ShoppingCart.fromJS(item));
      }
      if (Array.isArray(_data['wishlists'])) {
        this.wishlists = [] as any;
        for (let item of _data['wishlists']) this.wishlists!.push(Wishlist.fromJS(item));
      }
      if (Array.isArray(_data['abandonedCarts'])) {
        this.abandonedCarts = [] as any;
        for (let item of _data['abandonedCarts'])
          this.abandonedCarts!.push(AbandonedCart.fromJS(item));
      }
      if (Array.isArray(_data['orders'])) {
        this.orders = [] as any;
        for (let item of _data['orders']) this.orders!.push(Order.fromJS(item));
      }
      if (Array.isArray(_data['couponUsages'])) {
        this.couponUsages = [] as any;
        for (let item of _data['couponUsages']) this.couponUsages!.push(CouponUsage.fromJS(item));
      }
      if (Array.isArray(_data['rewardPoints'])) {
        this.rewardPoints = [] as any;
        for (let item of _data['rewardPoints']) this.rewardPoints!.push(RewardPoint.fromJS(item));
      }
      if (Array.isArray(_data['productReviews'])) {
        this.productReviews = [] as any;
        for (let item of _data['productReviews'])
          this.productReviews!.push(ProductReview.fromJS(item));
      }
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['email'] = this.email;
    data['passwordHash'] = this.passwordHash;
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    data['phoneNumber'] = this.phoneNumber;
    data['dateOfBirth'] = this.dateOfBirth ? this.dateOfBirth.toISOString() : (undefined as any);
    data['username'] = this.username;
    data['status'] = this.status;
    data['emailVerified'] = this.emailVerified;
    data['phoneVerified'] = this.phoneVerified;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['lastLoginAt'] = this.lastLoginAt ? this.lastLoginAt.toISOString() : (undefined as any);
    data['failedLoginAttempts'] = this.failedLoginAttempts;
    data['lastFailedLogin'] = this.lastFailedLogin
      ? this.lastFailedLogin.toISOString()
      : (undefined as any);
    data['lockedUntil'] = this.lockedUntil ? this.lockedUntil.toISOString() : (undefined as any);
    if (Array.isArray(this.userRoleAssignments)) {
      data['userRoleAssignments'] = [];
      for (let item of this.userRoleAssignments)
        data['userRoleAssignments'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.userAddresses)) {
      data['userAddresses'] = [];
      for (let item of this.userAddresses)
        data['userAddresses'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.userSessions)) {
      data['userSessions'] = [];
      for (let item of this.userSessions)
        data['userSessions'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.auditLogs)) {
      data['auditLogs'] = [];
      for (let item of this.auditLogs)
        data['auditLogs'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.refreshTokens)) {
      data['refreshTokens'] = [];
      for (let item of this.refreshTokens)
        data['refreshTokens'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.shoppingCarts)) {
      data['shoppingCarts'] = [];
      for (let item of this.shoppingCarts)
        data['shoppingCarts'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.wishlists)) {
      data['wishlists'] = [];
      for (let item of this.wishlists)
        data['wishlists'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.abandonedCarts)) {
      data['abandonedCarts'] = [];
      for (let item of this.abandonedCarts)
        data['abandonedCarts'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.orders)) {
      data['orders'] = [];
      for (let item of this.orders) data['orders'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.couponUsages)) {
      data['couponUsages'] = [];
      for (let item of this.couponUsages)
        data['couponUsages'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.rewardPoints)) {
      data['rewardPoints'] = [];
      for (let item of this.rewardPoints)
        data['rewardPoints'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.productReviews)) {
      data['productReviews'] = [];
      for (let item of this.productReviews)
        data['productReviews'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IUser {
  userId?: string;
  email: string;
  passwordHash: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  phoneNumber?: string | undefined;
  dateOfBirth?: Date | undefined;
  username: string;
  status?: number;
  emailVerified?: boolean;
  phoneVerified?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  lastLoginAt?: Date | undefined;
  failedLoginAttempts?: number;
  lastFailedLogin?: Date | undefined;
  lockedUntil?: Date | undefined;
  userRoleAssignments?: UserRoleAssignment[];
  userAddresses?: UserAddress[];
  userSessions?: UserSession[];
  auditLogs?: AuditLog[];
  refreshTokens?: RefreshToken[];
  shoppingCarts?: ShoppingCart[];
  wishlists?: Wishlist[];
  abandonedCarts?: AbandonedCart[];
  orders?: Order[];
  couponUsages?: CouponUsage[];
  rewardPoints?: RewardPoint[];
  productReviews?: ProductReview[];
}

export class UserRoleAssignment implements IUserRoleAssignment {
  userId?: string;
  roleId?: string;
  assignedAt?: Date;
  assignedBy?: string;
  user?: User;
  role?: UserRole;
  assignedByUser?: User;

  constructor(data?: IUserRoleAssignment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.roleId = _data['roleId'];
      this.assignedAt = _data['assignedAt']
        ? new Date(_data['assignedAt'].toString())
        : (undefined as any);
      this.assignedBy = _data['assignedBy'];
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      this.role = _data['role'] ? UserRole.fromJS(_data['role']) : (undefined as any);
      this.assignedByUser = _data['assignedByUser']
        ? User.fromJS(_data['assignedByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): UserRoleAssignment {
    data = typeof data === 'object' ? data : {};
    let result = new UserRoleAssignment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['roleId'] = this.roleId;
    data['assignedAt'] = this.assignedAt ? this.assignedAt.toISOString() : (undefined as any);
    data['assignedBy'] = this.assignedBy;
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    data['role'] = this.role ? this.role.toJSON() : (undefined as any);
    data['assignedByUser'] = this.assignedByUser
      ? this.assignedByUser.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IUserRoleAssignment {
  userId?: string;
  roleId?: string;
  assignedAt?: Date;
  assignedBy?: string;
  user?: User;
  role?: UserRole;
  assignedByUser?: User;
}

export class UserRole implements IUserRole {
  roleId?: string;
  roleName!: string;
  description?: string | undefined;
  createdAt?: Date;

  constructor(data?: IUserRole) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.roleId = _data['roleId'];
      this.roleName = _data['roleName'];
      this.description = _data['description'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): UserRole {
    data = typeof data === 'object' ? data : {};
    let result = new UserRole();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['roleId'] = this.roleId;
    data['roleName'] = this.roleName;
    data['description'] = this.description;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IUserRole {
  roleId?: string;
  roleName: string;
  description?: string | undefined;
  createdAt?: Date;
}

export class UserAddress implements IUserAddress {
  addressId?: string;
  userId?: string;
  addressType?: number;
  addressLine1!: string;
  addressLine2?: string | undefined;
  city!: string;
  state!: string;
  zipCode!: string;
  country!: string;
  isDefault?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  user?: User;

  constructor(data?: IUserAddress) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.addressId = _data['addressId'];
      this.userId = _data['userId'];
      this.addressType = _data['addressType'];
      this.addressLine1 = _data['addressLine1'];
      this.addressLine2 = _data['addressLine2'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.zipCode = _data['zipCode'];
      this.country = _data['country'];
      this.isDefault = _data['isDefault'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): UserAddress {
    data = typeof data === 'object' ? data : {};
    let result = new UserAddress();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['addressId'] = this.addressId;
    data['userId'] = this.userId;
    data['addressType'] = this.addressType;
    data['addressLine1'] = this.addressLine1;
    data['addressLine2'] = this.addressLine2;
    data['city'] = this.city;
    data['state'] = this.state;
    data['zipCode'] = this.zipCode;
    data['country'] = this.country;
    data['isDefault'] = this.isDefault;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IUserAddress {
  addressId?: string;
  userId?: string;
  addressType?: number;
  addressLine1: string;
  addressLine2?: string | undefined;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  isDefault?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  user?: User;
}

export class UserSession implements IUserSession {
  sessionId?: string;
  userId?: string | undefined;
  sessionToken!: string;
  deviceInfo?: string | undefined;
  ipAddress?: string | undefined;
  createdAt?: Date;
  expiresAt?: Date | undefined;
  revoked?: boolean;
  user?: User | undefined;

  constructor(data?: IUserSession) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sessionId = _data['sessionId'];
      this.userId = _data['userId'];
      this.sessionToken = _data['sessionToken'];
      this.deviceInfo = _data['deviceInfo'];
      this.ipAddress = _data['ipAddress'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.expiresAt = _data['expiresAt']
        ? new Date(_data['expiresAt'].toString())
        : (undefined as any);
      this.revoked = _data['revoked'];
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): UserSession {
    data = typeof data === 'object' ? data : {};
    let result = new UserSession();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sessionId'] = this.sessionId;
    data['userId'] = this.userId;
    data['sessionToken'] = this.sessionToken;
    data['deviceInfo'] = this.deviceInfo;
    data['ipAddress'] = this.ipAddress;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['expiresAt'] = this.expiresAt ? this.expiresAt.toISOString() : (undefined as any);
    data['revoked'] = this.revoked;
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IUserSession {
  sessionId?: string;
  userId?: string | undefined;
  sessionToken: string;
  deviceInfo?: string | undefined;
  ipAddress?: string | undefined;
  createdAt?: Date;
  expiresAt?: Date | undefined;
  revoked?: boolean;
  user?: User | undefined;
}

export class RefreshToken implements IRefreshToken {
  tokenId?: string;
  userId?: string;
  refreshTokenValue!: string;
  expiresAt?: Date;
  revoked?: boolean;
  createdAt?: Date;
  createdByIp?: string | undefined;
  replacedByToken?: string | undefined;
  user?: User;

  constructor(data?: IRefreshToken) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tokenId = _data['tokenId'];
      this.userId = _data['userId'];
      this.refreshTokenValue = _data['refreshTokenValue'];
      this.expiresAt = _data['expiresAt']
        ? new Date(_data['expiresAt'].toString())
        : (undefined as any);
      this.revoked = _data['revoked'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.createdByIp = _data['createdByIp'];
      this.replacedByToken = _data['replacedByToken'];
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): RefreshToken {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshToken();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tokenId'] = this.tokenId;
    data['userId'] = this.userId;
    data['refreshTokenValue'] = this.refreshTokenValue;
    data['expiresAt'] = this.expiresAt ? this.expiresAt.toISOString() : (undefined as any);
    data['revoked'] = this.revoked;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['createdByIp'] = this.createdByIp;
    data['replacedByToken'] = this.replacedByToken;
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IRefreshToken {
  tokenId?: string;
  userId?: string;
  refreshTokenValue: string;
  expiresAt?: Date;
  revoked?: boolean;
  createdAt?: Date;
  createdByIp?: string | undefined;
  replacedByToken?: string | undefined;
  user?: User;
}

export class ShoppingCart implements IShoppingCart {
  cartId?: string;
  userId?: string | undefined;
  sessionId?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  user?: User | undefined;
  shoppingCartItems?: ShoppingCartItem[];

  constructor(data?: IShoppingCart) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cartId = _data['cartId'];
      this.userId = _data['userId'];
      this.sessionId = _data['sessionId'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      if (Array.isArray(_data['shoppingCartItems'])) {
        this.shoppingCartItems = [] as any;
        for (let item of _data['shoppingCartItems'])
          this.shoppingCartItems!.push(ShoppingCartItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ShoppingCart {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCart();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cartId'] = this.cartId;
    data['userId'] = this.userId;
    data['sessionId'] = this.sessionId;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    if (Array.isArray(this.shoppingCartItems)) {
      data['shoppingCartItems'] = [];
      for (let item of this.shoppingCartItems)
        data['shoppingCartItems'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IShoppingCart {
  cartId?: string;
  userId?: string | undefined;
  sessionId?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  user?: User | undefined;
  shoppingCartItems?: ShoppingCartItem[];
}

export class ShoppingCartItem implements IShoppingCartItem {
  cartItemId?: string;
  cartId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  quantity?: number;
  unitPrice!: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  shoppingCart?: ShoppingCart;
  product?: Product;
  productVariant?: ProductVariant | undefined;

  constructor(data?: IShoppingCartItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cartItemId = _data['cartItemId'];
      this.cartId = _data['cartId'];
      this.productId = _data['productId'];
      this.productVariantId = _data['productVariantId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.shoppingCart = _data['shoppingCart']
        ? ShoppingCart.fromJS(_data['shoppingCart'])
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.productVariant = _data['productVariant']
        ? ProductVariant.fromJS(_data['productVariant'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ShoppingCartItem {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cartItemId'] = this.cartItemId;
    data['cartId'] = this.cartId;
    data['productId'] = this.productId;
    data['productVariantId'] = this.productVariantId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['productVariant'] = this.productVariant
      ? this.productVariant.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IShoppingCartItem {
  cartItemId?: string;
  cartId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  quantity?: number;
  unitPrice: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  shoppingCart?: ShoppingCart;
  product?: Product;
  productVariant?: ProductVariant | undefined;
}

export class Product implements IProduct {
  productId?: string;
  name!: string;
  slug?: string | undefined;
  sku!: string;
  description!: string;
  shortDescription?: string | undefined;
  price!: number;
  discountPrice?: number | undefined;
  cost?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  categoryId?: string;
  brandId?: string | undefined;
  status?: number;
  isFeatured?: boolean;
  isDigital?: boolean;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  category?: Category;
  brand?: Brand | undefined;
  createdByUser?: User;
  updatedByUser?: User | undefined;
  productImages?: ProductImage[];
  productAttributeValues?: ProductAttributeValue[];
  productVariants?: ProductVariant[];
  productTagAssignments?: ProductTagAssignment[];
  productQuestions?: ProductQuestion[];
  reviews?: ProductReview[];
  stockMovements?: StockMovement[];

  constructor(data?: IProduct) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.sku = _data['sku'];
      this.description = _data['description'];
      this.shortDescription = _data['shortDescription'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.cost = _data['cost'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.categoryId = _data['categoryId'];
      this.brandId = _data['brandId'];
      this.status = _data['status'];
      this.isFeatured = _data['isFeatured'];
      this.isDigital = _data['isDigital'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.updatedBy = _data['updatedBy'];
      this.category = _data['category'] ? Category.fromJS(_data['category']) : (undefined as any);
      this.brand = _data['brand'] ? Brand.fromJS(_data['brand']) : (undefined as any);
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      this.updatedByUser = _data['updatedByUser']
        ? User.fromJS(_data['updatedByUser'])
        : (undefined as any);
      if (Array.isArray(_data['productImages'])) {
        this.productImages = [] as any;
        for (let item of _data['productImages'])
          this.productImages!.push(ProductImage.fromJS(item));
      }
      if (Array.isArray(_data['productAttributeValues'])) {
        this.productAttributeValues = [] as any;
        for (let item of _data['productAttributeValues'])
          this.productAttributeValues!.push(ProductAttributeValue.fromJS(item));
      }
      if (Array.isArray(_data['productVariants'])) {
        this.productVariants = [] as any;
        for (let item of _data['productVariants'])
          this.productVariants!.push(ProductVariant.fromJS(item));
      }
      if (Array.isArray(_data['productTagAssignments'])) {
        this.productTagAssignments = [] as any;
        for (let item of _data['productTagAssignments'])
          this.productTagAssignments!.push(ProductTagAssignment.fromJS(item));
      }
      if (Array.isArray(_data['productQuestions'])) {
        this.productQuestions = [] as any;
        for (let item of _data['productQuestions'])
          this.productQuestions!.push(ProductQuestion.fromJS(item));
      }
      if (Array.isArray(_data['reviews'])) {
        this.reviews = [] as any;
        for (let item of _data['reviews']) this.reviews!.push(ProductReview.fromJS(item));
      }
      if (Array.isArray(_data['stockMovements'])) {
        this.stockMovements = [] as any;
        for (let item of _data['stockMovements'])
          this.stockMovements!.push(StockMovement.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Product {
    data = typeof data === 'object' ? data : {};
    let result = new Product();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['sku'] = this.sku;
    data['description'] = this.description;
    data['shortDescription'] = this.shortDescription;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['cost'] = this.cost;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['categoryId'] = this.categoryId;
    data['brandId'] = this.brandId;
    data['status'] = this.status;
    data['isFeatured'] = this.isFeatured;
    data['isDigital'] = this.isDigital;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['updatedBy'] = this.updatedBy;
    data['category'] = this.category ? this.category.toJSON() : (undefined as any);
    data['brand'] = this.brand ? this.brand.toJSON() : (undefined as any);
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    data['updatedByUser'] = this.updatedByUser ? this.updatedByUser.toJSON() : (undefined as any);
    if (Array.isArray(this.productImages)) {
      data['productImages'] = [];
      for (let item of this.productImages)
        data['productImages'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.productAttributeValues)) {
      data['productAttributeValues'] = [];
      for (let item of this.productAttributeValues)
        data['productAttributeValues'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.productVariants)) {
      data['productVariants'] = [];
      for (let item of this.productVariants)
        data['productVariants'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.productTagAssignments)) {
      data['productTagAssignments'] = [];
      for (let item of this.productTagAssignments)
        data['productTagAssignments'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.productQuestions)) {
      data['productQuestions'] = [];
      for (let item of this.productQuestions)
        data['productQuestions'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.reviews)) {
      data['reviews'] = [];
      for (let item of this.reviews)
        data['reviews'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.stockMovements)) {
      data['stockMovements'] = [];
      for (let item of this.stockMovements)
        data['stockMovements'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IProduct {
  productId?: string;
  name: string;
  slug?: string | undefined;
  sku: string;
  description: string;
  shortDescription?: string | undefined;
  price: number;
  discountPrice?: number | undefined;
  cost?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  categoryId?: string;
  brandId?: string | undefined;
  status?: number;
  isFeatured?: boolean;
  isDigital?: boolean;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  category?: Category;
  brand?: Brand | undefined;
  createdByUser?: User;
  updatedByUser?: User | undefined;
  productImages?: ProductImage[];
  productAttributeValues?: ProductAttributeValue[];
  productVariants?: ProductVariant[];
  productTagAssignments?: ProductTagAssignment[];
  productQuestions?: ProductQuestion[];
  reviews?: ProductReview[];
  stockMovements?: StockMovement[];
}

export class Category implements ICategory {
  categoryId?: string;
  name!: string;
  slug?: string | undefined;
  description?: string | undefined;
  imageUrl?: string | undefined;
  parentCategoryId?: string | undefined;
  displayOrder?: number;
  status?: number;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  parentCategory?: Category | undefined;
  subCategories?: Category[];
  products?: Product[];
  createdByUser?: User;
  updatedByUser?: User | undefined;

  constructor(data?: ICategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId = _data['categoryId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.imageUrl = _data['imageUrl'];
      this.parentCategoryId = _data['parentCategoryId'];
      this.displayOrder = _data['displayOrder'];
      this.status = _data['status'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.updatedBy = _data['updatedBy'];
      this.parentCategory = _data['parentCategory']
        ? Category.fromJS(_data['parentCategory'])
        : (undefined as any);
      if (Array.isArray(_data['subCategories'])) {
        this.subCategories = [] as any;
        for (let item of _data['subCategories']) this.subCategories!.push(Category.fromJS(item));
      }
      if (Array.isArray(_data['products'])) {
        this.products = [] as any;
        for (let item of _data['products']) this.products!.push(Product.fromJS(item));
      }
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      this.updatedByUser = _data['updatedByUser']
        ? User.fromJS(_data['updatedByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === 'object' ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['categoryId'] = this.categoryId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['imageUrl'] = this.imageUrl;
    data['parentCategoryId'] = this.parentCategoryId;
    data['displayOrder'] = this.displayOrder;
    data['status'] = this.status;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['updatedBy'] = this.updatedBy;
    data['parentCategory'] = this.parentCategory
      ? this.parentCategory.toJSON()
      : (undefined as any);
    if (Array.isArray(this.subCategories)) {
      data['subCategories'] = [];
      for (let item of this.subCategories)
        data['subCategories'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.products)) {
      data['products'] = [];
      for (let item of this.products)
        data['products'].push(item ? item.toJSON() : (undefined as any));
    }
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    data['updatedByUser'] = this.updatedByUser ? this.updatedByUser.toJSON() : (undefined as any);
    return data;
  }
}

export interface ICategory {
  categoryId?: string;
  name: string;
  slug?: string | undefined;
  description?: string | undefined;
  imageUrl?: string | undefined;
  parentCategoryId?: string | undefined;
  displayOrder?: number;
  status?: number;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  parentCategory?: Category | undefined;
  subCategories?: Category[];
  products?: Product[];
  createdByUser?: User;
  updatedByUser?: User | undefined;
}

export class Brand implements IBrand {
  brandId?: string;
  name!: string;
  slug?: string | undefined;
  description?: string | undefined;
  logoUrl?: string | undefined;
  website?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  products?: Product[];
  createdByUser?: User;
  updatedByUser?: User | undefined;

  constructor(data?: IBrand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.brandId = _data['brandId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.logoUrl = _data['logoUrl'];
      this.website = _data['website'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.updatedBy = _data['updatedBy'];
      if (Array.isArray(_data['products'])) {
        this.products = [] as any;
        for (let item of _data['products']) this.products!.push(Product.fromJS(item));
      }
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      this.updatedByUser = _data['updatedByUser']
        ? User.fromJS(_data['updatedByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): Brand {
    data = typeof data === 'object' ? data : {};
    let result = new Brand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['brandId'] = this.brandId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['logoUrl'] = this.logoUrl;
    data['website'] = this.website;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['updatedBy'] = this.updatedBy;
    if (Array.isArray(this.products)) {
      data['products'] = [];
      for (let item of this.products)
        data['products'].push(item ? item.toJSON() : (undefined as any));
    }
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    data['updatedByUser'] = this.updatedByUser ? this.updatedByUser.toJSON() : (undefined as any);
    return data;
  }
}

export interface IBrand {
  brandId?: string;
  name: string;
  slug?: string | undefined;
  description?: string | undefined;
  logoUrl?: string | undefined;
  website?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  products?: Product[];
  createdByUser?: User;
  updatedByUser?: User | undefined;
}

export class ProductImage implements IProductImage {
  imageId?: string;
  productId?: string;
  imageUrl!: string;
  altText?: string | undefined;
  displayOrder?: number;
  isPrimary?: boolean;
  createdAt?: Date;
  product?: Product;

  constructor(data?: IProductImage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.imageId = _data['imageId'];
      this.productId = _data['productId'];
      this.imageUrl = _data['imageUrl'];
      this.altText = _data['altText'];
      this.displayOrder = _data['displayOrder'];
      this.isPrimary = _data['isPrimary'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
    }
  }

  static fromJS(data: any): ProductImage {
    data = typeof data === 'object' ? data : {};
    let result = new ProductImage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['imageId'] = this.imageId;
    data['productId'] = this.productId;
    data['imageUrl'] = this.imageUrl;
    data['altText'] = this.altText;
    data['displayOrder'] = this.displayOrder;
    data['isPrimary'] = this.isPrimary;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    return data;
  }
}

export interface IProductImage {
  imageId?: string;
  productId?: string;
  imageUrl: string;
  altText?: string | undefined;
  displayOrder?: number;
  isPrimary?: boolean;
  createdAt?: Date;
  product?: Product;
}

export class ProductAttributeValue implements IProductAttributeValue {
  valueId?: string;
  productId?: string;
  attributeId?: string;
  value!: string;
  createdAt?: Date;
  product?: Product;
  attribute?: ProductAttribute;

  constructor(data?: IProductAttributeValue) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.valueId = _data['valueId'];
      this.productId = _data['productId'];
      this.attributeId = _data['attributeId'];
      this.value = _data['value'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.attribute = _data['attribute']
        ? ProductAttribute.fromJS(_data['attribute'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductAttributeValue {
    data = typeof data === 'object' ? data : {};
    let result = new ProductAttributeValue();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['valueId'] = this.valueId;
    data['productId'] = this.productId;
    data['attributeId'] = this.attributeId;
    data['value'] = this.value;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['attribute'] = this.attribute ? this.attribute.toJSON() : (undefined as any);
    return data;
  }
}

export interface IProductAttributeValue {
  valueId?: string;
  productId?: string;
  attributeId?: string;
  value: string;
  createdAt?: Date;
  product?: Product;
  attribute?: ProductAttribute;
}

export class ProductAttribute implements IProductAttribute {
  attributeId?: string;
  name!: string;
  displayName!: string;
  attributeType?: number;
  isRequired?: boolean;
  displayOrder?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  productAttributeValues?: ProductAttributeValue[];

  constructor(data?: IProductAttribute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attributeId = _data['attributeId'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.attributeType = _data['attributeType'];
      this.isRequired = _data['isRequired'];
      this.displayOrder = _data['displayOrder'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['productAttributeValues'])) {
        this.productAttributeValues = [] as any;
        for (let item of _data['productAttributeValues'])
          this.productAttributeValues!.push(ProductAttributeValue.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductAttribute {
    data = typeof data === 'object' ? data : {};
    let result = new ProductAttribute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['attributeId'] = this.attributeId;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['attributeType'] = this.attributeType;
    data['isRequired'] = this.isRequired;
    data['displayOrder'] = this.displayOrder;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    if (Array.isArray(this.productAttributeValues)) {
      data['productAttributeValues'] = [];
      for (let item of this.productAttributeValues)
        data['productAttributeValues'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IProductAttribute {
  attributeId?: string;
  name: string;
  displayName: string;
  attributeType?: number;
  isRequired?: boolean;
  displayOrder?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  productAttributeValues?: ProductAttributeValue[];
}

export class ProductVariant implements IProductVariant {
  variantId?: string;
  productId?: string;
  sku!: string;
  name!: string;
  price!: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  weight?: number | undefined;
  imageUrl?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  product?: Product;
  variantAttributeValues?: ProductAttributeValue[];

  constructor(data?: IProductVariant) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.variantId = _data['variantId'];
      this.productId = _data['productId'];
      this.sku = _data['sku'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.stockQuantity = _data['stockQuantity'];
      this.weight = _data['weight'];
      this.imageUrl = _data['imageUrl'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      if (Array.isArray(_data['variantAttributeValues'])) {
        this.variantAttributeValues = [] as any;
        for (let item of _data['variantAttributeValues'])
          this.variantAttributeValues!.push(ProductAttributeValue.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductVariant {
    data = typeof data === 'object' ? data : {};
    let result = new ProductVariant();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['variantId'] = this.variantId;
    data['productId'] = this.productId;
    data['sku'] = this.sku;
    data['name'] = this.name;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['stockQuantity'] = this.stockQuantity;
    data['weight'] = this.weight;
    data['imageUrl'] = this.imageUrl;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    if (Array.isArray(this.variantAttributeValues)) {
      data['variantAttributeValues'] = [];
      for (let item of this.variantAttributeValues)
        data['variantAttributeValues'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IProductVariant {
  variantId?: string;
  productId?: string;
  sku: string;
  name: string;
  price: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  weight?: number | undefined;
  imageUrl?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  product?: Product;
  variantAttributeValues?: ProductAttributeValue[];
}

export class ProductTagAssignment implements IProductTagAssignment {
  productId?: string;
  tagId?: string;
  product?: Product;
  productTag?: ProductTag;

  constructor(data?: IProductTagAssignment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.productTag = _data['productTag']
        ? ProductTag.fromJS(_data['productTag'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductTagAssignment {
    data = typeof data === 'object' ? data : {};
    let result = new ProductTagAssignment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['productTag'] = this.productTag ? this.productTag.toJSON() : (undefined as any);
    return data;
  }
}

export interface IProductTagAssignment {
  productId?: string;
  tagId?: string;
  product?: Product;
  productTag?: ProductTag;
}

export class ProductTag implements IProductTag {
  tagId?: string;
  name!: string;
  slug?: string | undefined;
  description?: string | undefined;
  createdAt?: Date;
  productTagAssignments?: ProductTagAssignment[];

  constructor(data?: IProductTag) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tagId = _data['tagId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['productTagAssignments'])) {
        this.productTagAssignments = [] as any;
        for (let item of _data['productTagAssignments'])
          this.productTagAssignments!.push(ProductTagAssignment.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductTag {
    data = typeof data === 'object' ? data : {};
    let result = new ProductTag();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tagId'] = this.tagId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    if (Array.isArray(this.productTagAssignments)) {
      data['productTagAssignments'] = [];
      for (let item of this.productTagAssignments)
        data['productTagAssignments'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IProductTag {
  tagId?: string;
  name: string;
  slug?: string | undefined;
  description?: string | undefined;
  createdAt?: Date;
  productTagAssignments?: ProductTagAssignment[];
}

export class ProductQuestion implements IProductQuestion {
  questionId?: string;
  productId?: string;
  userId?: string | undefined;
  question!: string;
  answer?: string | undefined;
  answeredBy?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  product?: Product;
  user?: User | undefined;
  answeredByUser?: User | undefined;

  constructor(data?: IProductQuestion) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.productId = _data['productId'];
      this.userId = _data['userId'];
      this.question = _data['question'];
      this.answer = _data['answer'];
      this.answeredBy = _data['answeredBy'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      this.answeredByUser = _data['answeredByUser']
        ? User.fromJS(_data['answeredByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductQuestion {
    data = typeof data === 'object' ? data : {};
    let result = new ProductQuestion();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    data['question'] = this.question;
    data['answer'] = this.answer;
    data['answeredBy'] = this.answeredBy;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    data['answeredByUser'] = this.answeredByUser
      ? this.answeredByUser.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IProductQuestion {
  questionId?: string;
  productId?: string;
  userId?: string | undefined;
  question: string;
  answer?: string | undefined;
  answeredBy?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  product?: Product;
  user?: User | undefined;
  answeredByUser?: User | undefined;
}

export class ProductReview implements IProductReview {
  reviewId?: string;
  productId?: string;
  userId?: string;
  orderId?: string | undefined;
  rating!: number;
  title?: string | undefined;
  content?: string | undefined;
  isVerifiedPurchase?: boolean;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  product?: Product;
  user?: User;
  order?: Order | undefined;
  reviewImages?: ReviewImage[];
  reviewVotes?: ReviewVote[];
  reviewReports?: ReviewReport[];

  constructor(data?: IProductReview) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reviewId = _data['reviewId'];
      this.productId = _data['productId'];
      this.userId = _data['userId'];
      this.orderId = _data['orderId'];
      this.rating = _data['rating'];
      this.title = _data['title'];
      this.content = _data['content'];
      this.isVerifiedPurchase = _data['isVerifiedPurchase'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
      if (Array.isArray(_data['reviewImages'])) {
        this.reviewImages = [] as any;
        for (let item of _data['reviewImages']) this.reviewImages!.push(ReviewImage.fromJS(item));
      }
      if (Array.isArray(_data['reviewVotes'])) {
        this.reviewVotes = [] as any;
        for (let item of _data['reviewVotes']) this.reviewVotes!.push(ReviewVote.fromJS(item));
      }
      if (Array.isArray(_data['reviewReports'])) {
        this.reviewReports = [] as any;
        for (let item of _data['reviewReports'])
          this.reviewReports!.push(ReviewReport.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductReview {
    data = typeof data === 'object' ? data : {};
    let result = new ProductReview();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reviewId'] = this.reviewId;
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    data['orderId'] = this.orderId;
    data['rating'] = this.rating;
    data['title'] = this.title;
    data['content'] = this.content;
    data['isVerifiedPurchase'] = this.isVerifiedPurchase;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    if (Array.isArray(this.reviewImages)) {
      data['reviewImages'] = [];
      for (let item of this.reviewImages)
        data['reviewImages'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.reviewVotes)) {
      data['reviewVotes'] = [];
      for (let item of this.reviewVotes)
        data['reviewVotes'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.reviewReports)) {
      data['reviewReports'] = [];
      for (let item of this.reviewReports)
        data['reviewReports'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IProductReview {
  reviewId?: string;
  productId?: string;
  userId?: string;
  orderId?: string | undefined;
  rating: number;
  title?: string | undefined;
  content?: string | undefined;
  isVerifiedPurchase?: boolean;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  product?: Product;
  user?: User;
  order?: Order | undefined;
  reviewImages?: ReviewImage[];
  reviewVotes?: ReviewVote[];
  reviewReports?: ReviewReport[];
}

export class Order implements IOrder {
  orderId?: string;
  orderNumber!: string;
  userId?: string;
  orderDate?: Date;
  subTotal!: number;
  taxAmount?: number;
  shippingAmount?: number;
  discountAmount?: number;
  totalAmount!: number;
  status?: number;
  paymentStatus?: number;
  paymentMethod?: number;
  shippingFirstName!: string;
  shippingLastName!: string;
  shippingEmail!: string;
  shippingPhone?: string | undefined;
  shippingAddress!: string;
  shippingCity!: string;
  shippingState!: string;
  shippingZipCode!: string;
  shippingCountry!: string;
  billingFirstName!: string;
  billingLastName!: string;
  billingEmail!: string;
  billingPhone?: string | undefined;
  billingAddress!: string;
  billingCity!: string;
  billingState!: string;
  billingZipCode!: string;
  billingCountry!: string;
  notes?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  deliveredAt?: Date | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string | undefined;
  user?: User;
  createdByUser?: User | undefined;
  orderItems?: OrderItem[];
  orderStatusHistories?: OrderStatusHistory[];
  orderPayments?: OrderPayment[];
  orderShipments?: OrderShipment[];
  orderRefunds?: OrderRefund[];

  constructor(data?: IOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderId = _data['orderId'];
      this.orderNumber = _data['orderNumber'];
      this.userId = _data['userId'];
      this.orderDate = _data['orderDate']
        ? new Date(_data['orderDate'].toString())
        : (undefined as any);
      this.subTotal = _data['subTotal'];
      this.taxAmount = _data['taxAmount'];
      this.shippingAmount = _data['shippingAmount'];
      this.discountAmount = _data['discountAmount'];
      this.totalAmount = _data['totalAmount'];
      this.status = _data['status'];
      this.paymentStatus = _data['paymentStatus'];
      this.paymentMethod = _data['paymentMethod'];
      this.shippingFirstName = _data['shippingFirstName'];
      this.shippingLastName = _data['shippingLastName'];
      this.shippingEmail = _data['shippingEmail'];
      this.shippingPhone = _data['shippingPhone'];
      this.shippingAddress = _data['shippingAddress'];
      this.shippingCity = _data['shippingCity'];
      this.shippingState = _data['shippingState'];
      this.shippingZipCode = _data['shippingZipCode'];
      this.shippingCountry = _data['shippingCountry'];
      this.billingFirstName = _data['billingFirstName'];
      this.billingLastName = _data['billingLastName'];
      this.billingEmail = _data['billingEmail'];
      this.billingPhone = _data['billingPhone'];
      this.billingAddress = _data['billingAddress'];
      this.billingCity = _data['billingCity'];
      this.billingState = _data['billingState'];
      this.billingZipCode = _data['billingZipCode'];
      this.billingCountry = _data['billingCountry'];
      this.notes = _data['notes'];
      this.estimatedDeliveryDate = _data['estimatedDeliveryDate']
        ? new Date(_data['estimatedDeliveryDate'].toString())
        : (undefined as any);
      this.deliveredAt = _data['deliveredAt']
        ? new Date(_data['deliveredAt'].toString())
        : (undefined as any);
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      if (Array.isArray(_data['orderItems'])) {
        this.orderItems = [] as any;
        for (let item of _data['orderItems']) this.orderItems!.push(OrderItem.fromJS(item));
      }
      if (Array.isArray(_data['orderStatusHistories'])) {
        this.orderStatusHistories = [] as any;
        for (let item of _data['orderStatusHistories'])
          this.orderStatusHistories!.push(OrderStatusHistory.fromJS(item));
      }
      if (Array.isArray(_data['orderPayments'])) {
        this.orderPayments = [] as any;
        for (let item of _data['orderPayments'])
          this.orderPayments!.push(OrderPayment.fromJS(item));
      }
      if (Array.isArray(_data['orderShipments'])) {
        this.orderShipments = [] as any;
        for (let item of _data['orderShipments'])
          this.orderShipments!.push(OrderShipment.fromJS(item));
      }
      if (Array.isArray(_data['orderRefunds'])) {
        this.orderRefunds = [] as any;
        for (let item of _data['orderRefunds']) this.orderRefunds!.push(OrderRefund.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Order {
    data = typeof data === 'object' ? data : {};
    let result = new Order();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderId'] = this.orderId;
    data['orderNumber'] = this.orderNumber;
    data['userId'] = this.userId;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : (undefined as any);
    data['subTotal'] = this.subTotal;
    data['taxAmount'] = this.taxAmount;
    data['shippingAmount'] = this.shippingAmount;
    data['discountAmount'] = this.discountAmount;
    data['totalAmount'] = this.totalAmount;
    data['status'] = this.status;
    data['paymentStatus'] = this.paymentStatus;
    data['paymentMethod'] = this.paymentMethod;
    data['shippingFirstName'] = this.shippingFirstName;
    data['shippingLastName'] = this.shippingLastName;
    data['shippingEmail'] = this.shippingEmail;
    data['shippingPhone'] = this.shippingPhone;
    data['shippingAddress'] = this.shippingAddress;
    data['shippingCity'] = this.shippingCity;
    data['shippingState'] = this.shippingState;
    data['shippingZipCode'] = this.shippingZipCode;
    data['shippingCountry'] = this.shippingCountry;
    data['billingFirstName'] = this.billingFirstName;
    data['billingLastName'] = this.billingLastName;
    data['billingEmail'] = this.billingEmail;
    data['billingPhone'] = this.billingPhone;
    data['billingAddress'] = this.billingAddress;
    data['billingCity'] = this.billingCity;
    data['billingState'] = this.billingState;
    data['billingZipCode'] = this.billingZipCode;
    data['billingCountry'] = this.billingCountry;
    data['notes'] = this.notes;
    data['estimatedDeliveryDate'] = this.estimatedDeliveryDate
      ? this.estimatedDeliveryDate.toISOString()
      : (undefined as any);
    data['deliveredAt'] = this.deliveredAt ? this.deliveredAt.toISOString() : (undefined as any);
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    if (Array.isArray(this.orderItems)) {
      data['orderItems'] = [];
      for (let item of this.orderItems)
        data['orderItems'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.orderStatusHistories)) {
      data['orderStatusHistories'] = [];
      for (let item of this.orderStatusHistories)
        data['orderStatusHistories'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.orderPayments)) {
      data['orderPayments'] = [];
      for (let item of this.orderPayments)
        data['orderPayments'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.orderShipments)) {
      data['orderShipments'] = [];
      for (let item of this.orderShipments)
        data['orderShipments'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.orderRefunds)) {
      data['orderRefunds'] = [];
      for (let item of this.orderRefunds)
        data['orderRefunds'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IOrder {
  orderId?: string;
  orderNumber: string;
  userId?: string;
  orderDate?: Date;
  subTotal: number;
  taxAmount?: number;
  shippingAmount?: number;
  discountAmount?: number;
  totalAmount: number;
  status?: number;
  paymentStatus?: number;
  paymentMethod?: number;
  shippingFirstName: string;
  shippingLastName: string;
  shippingEmail: string;
  shippingPhone?: string | undefined;
  shippingAddress: string;
  shippingCity: string;
  shippingState: string;
  shippingZipCode: string;
  shippingCountry: string;
  billingFirstName: string;
  billingLastName: string;
  billingEmail: string;
  billingPhone?: string | undefined;
  billingAddress: string;
  billingCity: string;
  billingState: string;
  billingZipCode: string;
  billingCountry: string;
  notes?: string | undefined;
  estimatedDeliveryDate?: Date | undefined;
  deliveredAt?: Date | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string | undefined;
  user?: User;
  createdByUser?: User | undefined;
  orderItems?: OrderItem[];
  orderStatusHistories?: OrderStatusHistory[];
  orderPayments?: OrderPayment[];
  orderShipments?: OrderShipment[];
  orderRefunds?: OrderRefund[];
}

export class OrderItem implements IOrderItem {
  orderItemId?: string;
  orderId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  productName!: string;
  productSku!: string;
  quantity?: number;
  unitPrice!: number;
  totalPrice!: number;
  order?: Order;
  product?: Product;
  productVariant?: ProductVariant | undefined;
  shipmentItems?: ShipmentItem[];

  constructor(data?: IOrderItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.orderItemId = _data['orderItemId'];
      this.orderId = _data['orderId'];
      this.productId = _data['productId'];
      this.productVariantId = _data['productVariantId'];
      this.productName = _data['productName'];
      this.productSku = _data['productSku'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.totalPrice = _data['totalPrice'];
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.productVariant = _data['productVariant']
        ? ProductVariant.fromJS(_data['productVariant'])
        : (undefined as any);
      if (Array.isArray(_data['shipmentItems'])) {
        this.shipmentItems = [] as any;
        for (let item of _data['shipmentItems'])
          this.shipmentItems!.push(ShipmentItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OrderItem {
    data = typeof data === 'object' ? data : {};
    let result = new OrderItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['orderItemId'] = this.orderItemId;
    data['orderId'] = this.orderId;
    data['productId'] = this.productId;
    data['productVariantId'] = this.productVariantId;
    data['productName'] = this.productName;
    data['productSku'] = this.productSku;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['totalPrice'] = this.totalPrice;
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['productVariant'] = this.productVariant
      ? this.productVariant.toJSON()
      : (undefined as any);
    if (Array.isArray(this.shipmentItems)) {
      data['shipmentItems'] = [];
      for (let item of this.shipmentItems)
        data['shipmentItems'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IOrderItem {
  orderItemId?: string;
  orderId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  productName: string;
  productSku: string;
  quantity?: number;
  unitPrice: number;
  totalPrice: number;
  order?: Order;
  product?: Product;
  productVariant?: ProductVariant | undefined;
  shipmentItems?: ShipmentItem[];
}

export class ShipmentItem implements IShipmentItem {
  shipmentItemId?: string;
  shipmentId?: string;
  orderItemId?: string;
  quantity?: number;
  orderShipment?: OrderShipment;
  orderItem?: OrderItem;

  constructor(data?: IShipmentItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shipmentItemId = _data['shipmentItemId'];
      this.shipmentId = _data['shipmentId'];
      this.orderItemId = _data['orderItemId'];
      this.quantity = _data['quantity'];
      this.orderShipment = _data['orderShipment']
        ? OrderShipment.fromJS(_data['orderShipment'])
        : (undefined as any);
      this.orderItem = _data['orderItem']
        ? OrderItem.fromJS(_data['orderItem'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ShipmentItem {
    data = typeof data === 'object' ? data : {};
    let result = new ShipmentItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shipmentItemId'] = this.shipmentItemId;
    data['shipmentId'] = this.shipmentId;
    data['orderItemId'] = this.orderItemId;
    data['quantity'] = this.quantity;
    data['orderShipment'] = this.orderShipment ? this.orderShipment.toJSON() : (undefined as any);
    data['orderItem'] = this.orderItem ? this.orderItem.toJSON() : (undefined as any);
    return data;
  }
}

export interface IShipmentItem {
  shipmentItemId?: string;
  shipmentId?: string;
  orderItemId?: string;
  quantity?: number;
  orderShipment?: OrderShipment;
  orderItem?: OrderItem;
}

export class OrderShipment implements IOrderShipment {
  shipmentId?: string;
  orderId?: string;
  shipmentNumber?: string | undefined;
  carrierId?: string | undefined;
  trackingNumber?: string | undefined;
  shippedAt?: Date | undefined;
  deliveredAt?: Date | undefined;
  status?: number;
  shippingCost?: number;
  warehouseId?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  shippedBy?: string | undefined;
  order?: Order;
  shipmentCarrier?: ShipmentCarrier | undefined;
  warehouse?: Warehouse | undefined;
  shippedByUser?: User | undefined;
  shipmentItems?: ShipmentItem[];

  constructor(data?: IOrderShipment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.shipmentId = _data['shipmentId'];
      this.orderId = _data['orderId'];
      this.shipmentNumber = _data['shipmentNumber'];
      this.carrierId = _data['carrierId'];
      this.trackingNumber = _data['trackingNumber'];
      this.shippedAt = _data['shippedAt']
        ? new Date(_data['shippedAt'].toString())
        : (undefined as any);
      this.deliveredAt = _data['deliveredAt']
        ? new Date(_data['deliveredAt'].toString())
        : (undefined as any);
      this.status = _data['status'];
      this.shippingCost = _data['shippingCost'];
      this.warehouseId = _data['warehouseId'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.shippedBy = _data['shippedBy'];
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
      this.shipmentCarrier = _data['shipmentCarrier']
        ? ShipmentCarrier.fromJS(_data['shipmentCarrier'])
        : (undefined as any);
      this.warehouse = _data['warehouse']
        ? Warehouse.fromJS(_data['warehouse'])
        : (undefined as any);
      this.shippedByUser = _data['shippedByUser']
        ? User.fromJS(_data['shippedByUser'])
        : (undefined as any);
      if (Array.isArray(_data['shipmentItems'])) {
        this.shipmentItems = [] as any;
        for (let item of _data['shipmentItems'])
          this.shipmentItems!.push(ShipmentItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OrderShipment {
    data = typeof data === 'object' ? data : {};
    let result = new OrderShipment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['shipmentId'] = this.shipmentId;
    data['orderId'] = this.orderId;
    data['shipmentNumber'] = this.shipmentNumber;
    data['carrierId'] = this.carrierId;
    data['trackingNumber'] = this.trackingNumber;
    data['shippedAt'] = this.shippedAt ? this.shippedAt.toISOString() : (undefined as any);
    data['deliveredAt'] = this.deliveredAt ? this.deliveredAt.toISOString() : (undefined as any);
    data['status'] = this.status;
    data['shippingCost'] = this.shippingCost;
    data['warehouseId'] = this.warehouseId;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['shippedBy'] = this.shippedBy;
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    data['shipmentCarrier'] = this.shipmentCarrier
      ? this.shipmentCarrier.toJSON()
      : (undefined as any);
    data['warehouse'] = this.warehouse ? this.warehouse.toJSON() : (undefined as any);
    data['shippedByUser'] = this.shippedByUser ? this.shippedByUser.toJSON() : (undefined as any);
    if (Array.isArray(this.shipmentItems)) {
      data['shipmentItems'] = [];
      for (let item of this.shipmentItems)
        data['shipmentItems'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IOrderShipment {
  shipmentId?: string;
  orderId?: string;
  shipmentNumber?: string | undefined;
  carrierId?: string | undefined;
  trackingNumber?: string | undefined;
  shippedAt?: Date | undefined;
  deliveredAt?: Date | undefined;
  status?: number;
  shippingCost?: number;
  warehouseId?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  shippedBy?: string | undefined;
  order?: Order;
  shipmentCarrier?: ShipmentCarrier | undefined;
  warehouse?: Warehouse | undefined;
  shippedByUser?: User | undefined;
  shipmentItems?: ShipmentItem[];
}

export class ShipmentCarrier implements IShipmentCarrier {
  carrierId?: string;
  name!: string;
  code?: string | undefined;
  website?: string | undefined;
  phone?: string | undefined;
  createdAt?: Date;
  orderShipments?: OrderShipment[];

  constructor(data?: IShipmentCarrier) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.carrierId = _data['carrierId'];
      this.name = _data['name'];
      this.code = _data['code'];
      this.website = _data['website'];
      this.phone = _data['phone'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['orderShipments'])) {
        this.orderShipments = [] as any;
        for (let item of _data['orderShipments'])
          this.orderShipments!.push(OrderShipment.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ShipmentCarrier {
    data = typeof data === 'object' ? data : {};
    let result = new ShipmentCarrier();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['carrierId'] = this.carrierId;
    data['name'] = this.name;
    data['code'] = this.code;
    data['website'] = this.website;
    data['phone'] = this.phone;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    if (Array.isArray(this.orderShipments)) {
      data['orderShipments'] = [];
      for (let item of this.orderShipments)
        data['orderShipments'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IShipmentCarrier {
  carrierId?: string;
  name: string;
  code?: string | undefined;
  website?: string | undefined;
  phone?: string | undefined;
  createdAt?: Date;
  orderShipments?: OrderShipment[];
}

export class Warehouse implements IWarehouse {
  warehouseId?: string;
  name!: string;
  code?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  phone?: string | undefined;
  isActive?: boolean;
  createdAt?: Date;
  purchaseOrders?: PurchaseOrder[];
  orderShipments?: OrderShipment[];
  stockMovements?: StockMovement[];

  constructor(data?: IWarehouse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.warehouseId = _data['warehouseId'];
      this.name = _data['name'];
      this.code = _data['code'];
      this.address = _data['address'];
      this.city = _data['city'];
      this.state = _data['state'];
      this.country = _data['country'];
      this.phone = _data['phone'];
      this.isActive = _data['isActive'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['purchaseOrders'])) {
        this.purchaseOrders = [] as any;
        for (let item of _data['purchaseOrders'])
          this.purchaseOrders!.push(PurchaseOrder.fromJS(item));
      }
      if (Array.isArray(_data['orderShipments'])) {
        this.orderShipments = [] as any;
        for (let item of _data['orderShipments'])
          this.orderShipments!.push(OrderShipment.fromJS(item));
      }
      if (Array.isArray(_data['stockMovements'])) {
        this.stockMovements = [] as any;
        for (let item of _data['stockMovements'])
          this.stockMovements!.push(StockMovement.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Warehouse {
    data = typeof data === 'object' ? data : {};
    let result = new Warehouse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['warehouseId'] = this.warehouseId;
    data['name'] = this.name;
    data['code'] = this.code;
    data['address'] = this.address;
    data['city'] = this.city;
    data['state'] = this.state;
    data['country'] = this.country;
    data['phone'] = this.phone;
    data['isActive'] = this.isActive;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    if (Array.isArray(this.purchaseOrders)) {
      data['purchaseOrders'] = [];
      for (let item of this.purchaseOrders)
        data['purchaseOrders'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.orderShipments)) {
      data['orderShipments'] = [];
      for (let item of this.orderShipments)
        data['orderShipments'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.stockMovements)) {
      data['stockMovements'] = [];
      for (let item of this.stockMovements)
        data['stockMovements'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IWarehouse {
  warehouseId?: string;
  name: string;
  code?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  country?: string | undefined;
  phone?: string | undefined;
  isActive?: boolean;
  createdAt?: Date;
  purchaseOrders?: PurchaseOrder[];
  orderShipments?: OrderShipment[];
  stockMovements?: StockMovement[];
}

export class PurchaseOrder implements IPurchaseOrder {
  purchaseOrderId?: string;
  supplierId?: string;
  warehouseId?: string | undefined;
  orderNumber!: string;
  orderDate?: Date;
  expectedDate?: Date | undefined;
  status?: number;
  totalAmount?: number;
  createdBy?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  supplier?: Supplier;
  createdByUser?: User | undefined;
  warehouse?: Warehouse | undefined;
  purchaseOrderItems?: PurchaseOrderItem[];

  constructor(data?: IPurchaseOrder) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.purchaseOrderId = _data['purchaseOrderId'];
      this.supplierId = _data['supplierId'];
      this.warehouseId = _data['warehouseId'];
      this.orderNumber = _data['orderNumber'];
      this.orderDate = _data['orderDate']
        ? new Date(_data['orderDate'].toString())
        : (undefined as any);
      this.expectedDate = _data['expectedDate']
        ? new Date(_data['expectedDate'].toString())
        : (undefined as any);
      this.status = _data['status'];
      this.totalAmount = _data['totalAmount'];
      this.createdBy = _data['createdBy'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.supplier = _data['supplier'] ? Supplier.fromJS(_data['supplier']) : (undefined as any);
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      this.warehouse = _data['warehouse']
        ? Warehouse.fromJS(_data['warehouse'])
        : (undefined as any);
      if (Array.isArray(_data['purchaseOrderItems'])) {
        this.purchaseOrderItems = [] as any;
        for (let item of _data['purchaseOrderItems'])
          this.purchaseOrderItems!.push(PurchaseOrderItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PurchaseOrder {
    data = typeof data === 'object' ? data : {};
    let result = new PurchaseOrder();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['purchaseOrderId'] = this.purchaseOrderId;
    data['supplierId'] = this.supplierId;
    data['warehouseId'] = this.warehouseId;
    data['orderNumber'] = this.orderNumber;
    data['orderDate'] = this.orderDate ? this.orderDate.toISOString() : (undefined as any);
    data['expectedDate'] = this.expectedDate ? this.expectedDate.toISOString() : (undefined as any);
    data['status'] = this.status;
    data['totalAmount'] = this.totalAmount;
    data['createdBy'] = this.createdBy;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['supplier'] = this.supplier ? this.supplier.toJSON() : (undefined as any);
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    data['warehouse'] = this.warehouse ? this.warehouse.toJSON() : (undefined as any);
    if (Array.isArray(this.purchaseOrderItems)) {
      data['purchaseOrderItems'] = [];
      for (let item of this.purchaseOrderItems)
        data['purchaseOrderItems'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IPurchaseOrder {
  purchaseOrderId?: string;
  supplierId?: string;
  warehouseId?: string | undefined;
  orderNumber: string;
  orderDate?: Date;
  expectedDate?: Date | undefined;
  status?: number;
  totalAmount?: number;
  createdBy?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  supplier?: Supplier;
  createdByUser?: User | undefined;
  warehouse?: Warehouse | undefined;
  purchaseOrderItems?: PurchaseOrderItem[];
}

export class Supplier implements ISupplier {
  supplierId?: string;
  name!: string;
  contactName?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  address?: string | undefined;
  note?: string | undefined;
  createdAt?: Date;
  purchaseOrders?: PurchaseOrder[];

  constructor(data?: ISupplier) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.name = _data['name'];
      this.contactName = _data['contactName'];
      this.contactEmail = _data['contactEmail'];
      this.contactPhone = _data['contactPhone'];
      this.address = _data['address'];
      this.note = _data['note'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['purchaseOrders'])) {
        this.purchaseOrders = [] as any;
        for (let item of _data['purchaseOrders'])
          this.purchaseOrders!.push(PurchaseOrder.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Supplier {
    data = typeof data === 'object' ? data : {};
    let result = new Supplier();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['name'] = this.name;
    data['contactName'] = this.contactName;
    data['contactEmail'] = this.contactEmail;
    data['contactPhone'] = this.contactPhone;
    data['address'] = this.address;
    data['note'] = this.note;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    if (Array.isArray(this.purchaseOrders)) {
      data['purchaseOrders'] = [];
      for (let item of this.purchaseOrders)
        data['purchaseOrders'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface ISupplier {
  supplierId?: string;
  name: string;
  contactName?: string | undefined;
  contactEmail?: string | undefined;
  contactPhone?: string | undefined;
  address?: string | undefined;
  note?: string | undefined;
  createdAt?: Date;
  purchaseOrders?: PurchaseOrder[];
}

export class PurchaseOrderItem implements IPurchaseOrderItem {
  poiId?: string;
  purchaseOrderId?: string;
  productId?: string;
  variantId?: string | undefined;
  quantity?: number;
  unitCost!: number;
  totalCost!: number;
  purchaseOrder?: PurchaseOrder;
  product?: Product;
  productVariant?: ProductVariant | undefined;

  constructor(data?: IPurchaseOrderItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.poiId = _data['poiId'];
      this.purchaseOrderId = _data['purchaseOrderId'];
      this.productId = _data['productId'];
      this.variantId = _data['variantId'];
      this.quantity = _data['quantity'];
      this.unitCost = _data['unitCost'];
      this.totalCost = _data['totalCost'];
      this.purchaseOrder = _data['purchaseOrder']
        ? PurchaseOrder.fromJS(_data['purchaseOrder'])
        : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.productVariant = _data['productVariant']
        ? ProductVariant.fromJS(_data['productVariant'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): PurchaseOrderItem {
    data = typeof data === 'object' ? data : {};
    let result = new PurchaseOrderItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['poiId'] = this.poiId;
    data['purchaseOrderId'] = this.purchaseOrderId;
    data['productId'] = this.productId;
    data['variantId'] = this.variantId;
    data['quantity'] = this.quantity;
    data['unitCost'] = this.unitCost;
    data['totalCost'] = this.totalCost;
    data['purchaseOrder'] = this.purchaseOrder ? this.purchaseOrder.toJSON() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['productVariant'] = this.productVariant
      ? this.productVariant.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IPurchaseOrderItem {
  poiId?: string;
  purchaseOrderId?: string;
  productId?: string;
  variantId?: string | undefined;
  quantity?: number;
  unitCost: number;
  totalCost: number;
  purchaseOrder?: PurchaseOrder;
  product?: Product;
  productVariant?: ProductVariant | undefined;
}

export class StockMovement implements IStockMovement {
  movementId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  warehouseId?: string | undefined;
  movementType?: number;
  quantity?: number;
  previousStock?: number;
  newStock?: number;
  reason?: string | undefined;
  referenceId?: string | undefined;
  referenceType?: number | undefined;
  createdAt?: Date;
  createdBy?: string;
  product?: Product;
  productVariant?: ProductVariant | undefined;
  warehouse?: Warehouse | undefined;
  createdByUser?: User;

  constructor(data?: IStockMovement) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.movementId = _data['movementId'];
      this.productId = _data['productId'];
      this.productVariantId = _data['productVariantId'];
      this.warehouseId = _data['warehouseId'];
      this.movementType = _data['movementType'];
      this.quantity = _data['quantity'];
      this.previousStock = _data['previousStock'];
      this.newStock = _data['newStock'];
      this.reason = _data['reason'];
      this.referenceId = _data['referenceId'];
      this.referenceType = _data['referenceType'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.productVariant = _data['productVariant']
        ? ProductVariant.fromJS(_data['productVariant'])
        : (undefined as any);
      this.warehouse = _data['warehouse']
        ? Warehouse.fromJS(_data['warehouse'])
        : (undefined as any);
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): StockMovement {
    data = typeof data === 'object' ? data : {};
    let result = new StockMovement();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['movementId'] = this.movementId;
    data['productId'] = this.productId;
    data['productVariantId'] = this.productVariantId;
    data['warehouseId'] = this.warehouseId;
    data['movementType'] = this.movementType;
    data['quantity'] = this.quantity;
    data['previousStock'] = this.previousStock;
    data['newStock'] = this.newStock;
    data['reason'] = this.reason;
    data['referenceId'] = this.referenceId;
    data['referenceType'] = this.referenceType;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['productVariant'] = this.productVariant
      ? this.productVariant.toJSON()
      : (undefined as any);
    data['warehouse'] = this.warehouse ? this.warehouse.toJSON() : (undefined as any);
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    return data;
  }
}

export interface IStockMovement {
  movementId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  warehouseId?: string | undefined;
  movementType?: number;
  quantity?: number;
  previousStock?: number;
  newStock?: number;
  reason?: string | undefined;
  referenceId?: string | undefined;
  referenceType?: number | undefined;
  createdAt?: Date;
  createdBy?: string;
  product?: Product;
  productVariant?: ProductVariant | undefined;
  warehouse?: Warehouse | undefined;
  createdByUser?: User;
}

export class OrderStatusHistory implements IOrderStatusHistory {
  historyId?: string;
  orderId?: string;
  fromStatus?: number | undefined;
  toStatus!: number;
  comment?: string | undefined;
  createdAt?: Date;
  createdBy?: string;
  order?: Order;
  createdByUser?: User;
  oldStatus?: number | undefined;
  newStatus?: number;
  changedByUser?: User | undefined;

  constructor(data?: IOrderStatusHistory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.historyId = _data['historyId'];
      this.orderId = _data['orderId'];
      this.fromStatus = _data['fromStatus'];
      this.toStatus = _data['toStatus'];
      this.comment = _data['comment'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      this.oldStatus = _data['oldStatus'];
      this.newStatus = _data['newStatus'];
      this.changedByUser = _data['changedByUser']
        ? User.fromJS(_data['changedByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): OrderStatusHistory {
    data = typeof data === 'object' ? data : {};
    let result = new OrderStatusHistory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['historyId'] = this.historyId;
    data['orderId'] = this.orderId;
    data['fromStatus'] = this.fromStatus;
    data['toStatus'] = this.toStatus;
    data['comment'] = this.comment;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    data['oldStatus'] = this.oldStatus;
    data['newStatus'] = this.newStatus;
    data['changedByUser'] = this.changedByUser ? this.changedByUser.toJSON() : (undefined as any);
    return data;
  }
}

export interface IOrderStatusHistory {
  historyId?: string;
  orderId?: string;
  fromStatus?: number | undefined;
  toStatus: number;
  comment?: string | undefined;
  createdAt?: Date;
  createdBy?: string;
  order?: Order;
  createdByUser?: User;
  oldStatus?: number | undefined;
  newStatus?: number;
  changedByUser?: User | undefined;
}

export class OrderPayment implements IOrderPayment {
  paymentId?: string;
  orderId?: string;
  paymentMethod?: number;
  transactionId?: string | undefined;
  gatewayResponse?: string | undefined;
  amount!: number;
  currency!: string;
  status?: number;
  paidAt?: Date | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  processedBy?: string | undefined;
  order?: Order;
  processedByUser?: User | undefined;
  orderRefunds?: OrderRefund[];

  constructor(data?: IOrderPayment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.paymentId = _data['paymentId'];
      this.orderId = _data['orderId'];
      this.paymentMethod = _data['paymentMethod'];
      this.transactionId = _data['transactionId'];
      this.gatewayResponse = _data['gatewayResponse'];
      this.amount = _data['amount'];
      this.currency = _data['currency'];
      this.status = _data['status'];
      this.paidAt = _data['paidAt'] ? new Date(_data['paidAt'].toString()) : (undefined as any);
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.processedBy = _data['processedBy'];
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
      this.processedByUser = _data['processedByUser']
        ? User.fromJS(_data['processedByUser'])
        : (undefined as any);
      if (Array.isArray(_data['orderRefunds'])) {
        this.orderRefunds = [] as any;
        for (let item of _data['orderRefunds']) this.orderRefunds!.push(OrderRefund.fromJS(item));
      }
    }
  }

  static fromJS(data: any): OrderPayment {
    data = typeof data === 'object' ? data : {};
    let result = new OrderPayment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['paymentId'] = this.paymentId;
    data['orderId'] = this.orderId;
    data['paymentMethod'] = this.paymentMethod;
    data['transactionId'] = this.transactionId;
    data['gatewayResponse'] = this.gatewayResponse;
    data['amount'] = this.amount;
    data['currency'] = this.currency;
    data['status'] = this.status;
    data['paidAt'] = this.paidAt ? this.paidAt.toISOString() : (undefined as any);
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['processedBy'] = this.processedBy;
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    data['processedByUser'] = this.processedByUser
      ? this.processedByUser.toJSON()
      : (undefined as any);
    if (Array.isArray(this.orderRefunds)) {
      data['orderRefunds'] = [];
      for (let item of this.orderRefunds)
        data['orderRefunds'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IOrderPayment {
  paymentId?: string;
  orderId?: string;
  paymentMethod?: number;
  transactionId?: string | undefined;
  gatewayResponse?: string | undefined;
  amount: number;
  currency: string;
  status?: number;
  paidAt?: Date | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  processedBy?: string | undefined;
  order?: Order;
  processedByUser?: User | undefined;
  orderRefunds?: OrderRefund[];
}

export class OrderRefund implements IOrderRefund {
  refundId?: string;
  orderId?: string;
  paymentId?: string | undefined;
  amount!: number;
  reason?: string | undefined;
  status?: number;
  requestedAt?: Date;
  processedAt?: Date | undefined;
  processedBy?: string | undefined;
  requestedBy?: string | undefined;
  order?: Order;
  orderPayment?: OrderPayment | undefined;
  processedByUser?: User | undefined;
  requestedByUser?: User | undefined;

  constructor(data?: IOrderRefund) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refundId = _data['refundId'];
      this.orderId = _data['orderId'];
      this.paymentId = _data['paymentId'];
      this.amount = _data['amount'];
      this.reason = _data['reason'];
      this.status = _data['status'];
      this.requestedAt = _data['requestedAt']
        ? new Date(_data['requestedAt'].toString())
        : (undefined as any);
      this.processedAt = _data['processedAt']
        ? new Date(_data['processedAt'].toString())
        : (undefined as any);
      this.processedBy = _data['processedBy'];
      this.requestedBy = _data['requestedBy'];
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
      this.orderPayment = _data['orderPayment']
        ? OrderPayment.fromJS(_data['orderPayment'])
        : (undefined as any);
      this.processedByUser = _data['processedByUser']
        ? User.fromJS(_data['processedByUser'])
        : (undefined as any);
      this.requestedByUser = _data['requestedByUser']
        ? User.fromJS(_data['requestedByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): OrderRefund {
    data = typeof data === 'object' ? data : {};
    let result = new OrderRefund();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refundId'] = this.refundId;
    data['orderId'] = this.orderId;
    data['paymentId'] = this.paymentId;
    data['amount'] = this.amount;
    data['reason'] = this.reason;
    data['status'] = this.status;
    data['requestedAt'] = this.requestedAt ? this.requestedAt.toISOString() : (undefined as any);
    data['processedAt'] = this.processedAt ? this.processedAt.toISOString() : (undefined as any);
    data['processedBy'] = this.processedBy;
    data['requestedBy'] = this.requestedBy;
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    data['orderPayment'] = this.orderPayment ? this.orderPayment.toJSON() : (undefined as any);
    data['processedByUser'] = this.processedByUser
      ? this.processedByUser.toJSON()
      : (undefined as any);
    data['requestedByUser'] = this.requestedByUser
      ? this.requestedByUser.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IOrderRefund {
  refundId?: string;
  orderId?: string;
  paymentId?: string | undefined;
  amount: number;
  reason?: string | undefined;
  status?: number;
  requestedAt?: Date;
  processedAt?: Date | undefined;
  processedBy?: string | undefined;
  requestedBy?: string | undefined;
  order?: Order;
  orderPayment?: OrderPayment | undefined;
  processedByUser?: User | undefined;
  requestedByUser?: User | undefined;
}

export class ReviewImage implements IReviewImage {
  imageId?: string;
  reviewId?: string;
  imageUrl!: string;
  createdAt?: Date;
  productReview?: ProductReview;

  constructor(data?: IReviewImage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.imageId = _data['imageId'];
      this.reviewId = _data['reviewId'];
      this.imageUrl = _data['imageUrl'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.productReview = _data['productReview']
        ? ProductReview.fromJS(_data['productReview'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ReviewImage {
    data = typeof data === 'object' ? data : {};
    let result = new ReviewImage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['imageId'] = this.imageId;
    data['reviewId'] = this.reviewId;
    data['imageUrl'] = this.imageUrl;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['productReview'] = this.productReview ? this.productReview.toJSON() : (undefined as any);
    return data;
  }
}

export interface IReviewImage {
  imageId?: string;
  reviewId?: string;
  imageUrl: string;
  createdAt?: Date;
  productReview?: ProductReview;
}

export class ReviewVote implements IReviewVote {
  voteId?: string;
  reviewId?: string;
  userId?: string;
  helpful?: boolean;
  createdAt?: Date;
  productReview?: ProductReview;
  user?: User;

  constructor(data?: IReviewVote) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.voteId = _data['voteId'];
      this.reviewId = _data['reviewId'];
      this.userId = _data['userId'];
      this.helpful = _data['helpful'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.productReview = _data['productReview']
        ? ProductReview.fromJS(_data['productReview'])
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): ReviewVote {
    data = typeof data === 'object' ? data : {};
    let result = new ReviewVote();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['voteId'] = this.voteId;
    data['reviewId'] = this.reviewId;
    data['userId'] = this.userId;
    data['helpful'] = this.helpful;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['productReview'] = this.productReview ? this.productReview.toJSON() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IReviewVote {
  voteId?: string;
  reviewId?: string;
  userId?: string;
  helpful?: boolean;
  createdAt?: Date;
  productReview?: ProductReview;
  user?: User;
}

export class ReviewReport implements IReviewReport {
  reportId?: string;
  reviewId?: string;
  userId?: string;
  reason?: string | undefined;
  createdAt?: Date;
  processed?: boolean;
  processedAt?: Date | undefined;
  processedBy?: string | undefined;
  productReview?: ProductReview;
  user?: User;
  processedByUser?: User | undefined;

  constructor(data?: IReviewReport) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.reportId = _data['reportId'];
      this.reviewId = _data['reviewId'];
      this.userId = _data['userId'];
      this.reason = _data['reason'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.processed = _data['processed'];
      this.processedAt = _data['processedAt']
        ? new Date(_data['processedAt'].toString())
        : (undefined as any);
      this.processedBy = _data['processedBy'];
      this.productReview = _data['productReview']
        ? ProductReview.fromJS(_data['productReview'])
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      this.processedByUser = _data['processedByUser']
        ? User.fromJS(_data['processedByUser'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): ReviewReport {
    data = typeof data === 'object' ? data : {};
    let result = new ReviewReport();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['reportId'] = this.reportId;
    data['reviewId'] = this.reviewId;
    data['userId'] = this.userId;
    data['reason'] = this.reason;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['processed'] = this.processed;
    data['processedAt'] = this.processedAt ? this.processedAt.toISOString() : (undefined as any);
    data['processedBy'] = this.processedBy;
    data['productReview'] = this.productReview ? this.productReview.toJSON() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    data['processedByUser'] = this.processedByUser
      ? this.processedByUser.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IReviewReport {
  reportId?: string;
  reviewId?: string;
  userId?: string;
  reason?: string | undefined;
  createdAt?: Date;
  processed?: boolean;
  processedAt?: Date | undefined;
  processedBy?: string | undefined;
  productReview?: ProductReview;
  user?: User;
  processedByUser?: User | undefined;
}

export class Wishlist implements IWishlist {
  wishlistId?: string;
  userId?: string;
  name!: string;
  isDefault?: boolean;
  isPublic?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  user?: User;
  wishlistItems?: WishlistItem[];

  constructor(data?: IWishlist) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.wishlistId = _data['wishlistId'];
      this.userId = _data['userId'];
      this.name = _data['name'];
      this.isDefault = _data['isDefault'];
      this.isPublic = _data['isPublic'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      if (Array.isArray(_data['wishlistItems'])) {
        this.wishlistItems = [] as any;
        for (let item of _data['wishlistItems'])
          this.wishlistItems!.push(WishlistItem.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Wishlist {
    data = typeof data === 'object' ? data : {};
    let result = new Wishlist();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishlistId'] = this.wishlistId;
    data['userId'] = this.userId;
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    data['isPublic'] = this.isPublic;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    if (Array.isArray(this.wishlistItems)) {
      data['wishlistItems'] = [];
      for (let item of this.wishlistItems)
        data['wishlistItems'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IWishlist {
  wishlistId?: string;
  userId?: string;
  name: string;
  isDefault?: boolean;
  isPublic?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  user?: User;
  wishlistItems?: WishlistItem[];
}

export class WishlistItem implements IWishlistItem {
  wishlistItemId?: string;
  wishlistId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  createdAt?: Date;
  wishlist?: Wishlist;
  product?: Product;
  productVariant?: ProductVariant | undefined;

  constructor(data?: IWishlistItem) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.wishlistItemId = _data['wishlistItemId'];
      this.wishlistId = _data['wishlistId'];
      this.productId = _data['productId'];
      this.productVariantId = _data['productVariantId'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.wishlist = _data['wishlist'] ? Wishlist.fromJS(_data['wishlist']) : (undefined as any);
      this.product = _data['product'] ? Product.fromJS(_data['product']) : (undefined as any);
      this.productVariant = _data['productVariant']
        ? ProductVariant.fromJS(_data['productVariant'])
        : (undefined as any);
    }
  }

  static fromJS(data: any): WishlistItem {
    data = typeof data === 'object' ? data : {};
    let result = new WishlistItem();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishlistItemId'] = this.wishlistItemId;
    data['wishlistId'] = this.wishlistId;
    data['productId'] = this.productId;
    data['productVariantId'] = this.productVariantId;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['wishlist'] = this.wishlist ? this.wishlist.toJSON() : (undefined as any);
    data['product'] = this.product ? this.product.toJSON() : (undefined as any);
    data['productVariant'] = this.productVariant
      ? this.productVariant.toJSON()
      : (undefined as any);
    return data;
  }
}

export interface IWishlistItem {
  wishlistItemId?: string;
  wishlistId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  createdAt?: Date;
  wishlist?: Wishlist;
  product?: Product;
  productVariant?: ProductVariant | undefined;
}

export class AbandonedCart implements IAbandonedCart {
  abandonedId?: string;
  cartId?: string;
  userId?: string | undefined;
  abandonedAt?: Date;
  notified?: boolean;
  shoppingCart?: ShoppingCart;
  user?: User | undefined;

  constructor(data?: IAbandonedCart) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.abandonedId = _data['abandonedId'];
      this.cartId = _data['cartId'];
      this.userId = _data['userId'];
      this.abandonedAt = _data['abandonedAt']
        ? new Date(_data['abandonedAt'].toString())
        : (undefined as any);
      this.notified = _data['notified'];
      this.shoppingCart = _data['shoppingCart']
        ? ShoppingCart.fromJS(_data['shoppingCart'])
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): AbandonedCart {
    data = typeof data === 'object' ? data : {};
    let result = new AbandonedCart();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['abandonedId'] = this.abandonedId;
    data['cartId'] = this.cartId;
    data['userId'] = this.userId;
    data['abandonedAt'] = this.abandonedAt ? this.abandonedAt.toISOString() : (undefined as any);
    data['notified'] = this.notified;
    data['shoppingCart'] = this.shoppingCart ? this.shoppingCart.toJSON() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IAbandonedCart {
  abandonedId?: string;
  cartId?: string;
  userId?: string | undefined;
  abandonedAt?: Date;
  notified?: boolean;
  shoppingCart?: ShoppingCart;
  user?: User | undefined;
}

export class CouponUsage implements ICouponUsage {
  usageId?: string;
  couponId?: string;
  userId?: string;
  orderId?: string;
  discountAmount!: number;
  usedAt?: Date;
  coupon?: Coupon;
  user?: User;
  order?: Order;

  constructor(data?: ICouponUsage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.usageId = _data['usageId'];
      this.couponId = _data['couponId'];
      this.userId = _data['userId'];
      this.orderId = _data['orderId'];
      this.discountAmount = _data['discountAmount'];
      this.usedAt = _data['usedAt'] ? new Date(_data['usedAt'].toString()) : (undefined as any);
      this.coupon = _data['coupon'] ? Coupon.fromJS(_data['coupon']) : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
      this.order = _data['order'] ? Order.fromJS(_data['order']) : (undefined as any);
    }
  }

  static fromJS(data: any): CouponUsage {
    data = typeof data === 'object' ? data : {};
    let result = new CouponUsage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['usageId'] = this.usageId;
    data['couponId'] = this.couponId;
    data['userId'] = this.userId;
    data['orderId'] = this.orderId;
    data['discountAmount'] = this.discountAmount;
    data['usedAt'] = this.usedAt ? this.usedAt.toISOString() : (undefined as any);
    data['coupon'] = this.coupon ? this.coupon.toJSON() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    data['order'] = this.order ? this.order.toJSON() : (undefined as any);
    return data;
  }
}

export interface ICouponUsage {
  usageId?: string;
  couponId?: string;
  userId?: string;
  orderId?: string;
  discountAmount: number;
  usedAt?: Date;
  coupon?: Coupon;
  user?: User;
  order?: Order;
}

export class Coupon implements ICoupon {
  couponId?: string;
  code!: string;
  name!: string;
  description?: string | undefined;
  discountType?: number;
  discountValue!: number;
  minOrderAmount?: number | undefined;
  maxDiscountAmount?: number | undefined;
  usageLimit?: number | undefined;
  usageCount?: number;
  userUsageLimit?: number;
  validFrom?: Date;
  validTo?: Date;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  createdByUser?: User;
  updatedByUser?: User | undefined;
  couponUsages?: CouponUsage[];

  constructor(data?: ICoupon) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.couponId = _data['couponId'];
      this.code = _data['code'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.discountType = _data['discountType'];
      this.discountValue = _data['discountValue'];
      this.minOrderAmount = _data['minOrderAmount'];
      this.maxDiscountAmount = _data['maxDiscountAmount'];
      this.usageLimit = _data['usageLimit'];
      this.usageCount = _data['usageCount'];
      this.userUsageLimit = _data['userUsageLimit'];
      this.validFrom = _data['validFrom']
        ? new Date(_data['validFrom'].toString())
        : (undefined as any);
      this.validTo = _data['validTo'] ? new Date(_data['validTo'].toString()) : (undefined as any);
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.createdBy = _data['createdBy'];
      this.updatedBy = _data['updatedBy'];
      this.createdByUser = _data['createdByUser']
        ? User.fromJS(_data['createdByUser'])
        : (undefined as any);
      this.updatedByUser = _data['updatedByUser']
        ? User.fromJS(_data['updatedByUser'])
        : (undefined as any);
      if (Array.isArray(_data['couponUsages'])) {
        this.couponUsages = [] as any;
        for (let item of _data['couponUsages']) this.couponUsages!.push(CouponUsage.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Coupon {
    data = typeof data === 'object' ? data : {};
    let result = new Coupon();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['couponId'] = this.couponId;
    data['code'] = this.code;
    data['name'] = this.name;
    data['description'] = this.description;
    data['discountType'] = this.discountType;
    data['discountValue'] = this.discountValue;
    data['minOrderAmount'] = this.minOrderAmount;
    data['maxDiscountAmount'] = this.maxDiscountAmount;
    data['usageLimit'] = this.usageLimit;
    data['usageCount'] = this.usageCount;
    data['userUsageLimit'] = this.userUsageLimit;
    data['validFrom'] = this.validFrom ? this.validFrom.toISOString() : (undefined as any);
    data['validTo'] = this.validTo ? this.validTo.toISOString() : (undefined as any);
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['createdBy'] = this.createdBy;
    data['updatedBy'] = this.updatedBy;
    data['createdByUser'] = this.createdByUser ? this.createdByUser.toJSON() : (undefined as any);
    data['updatedByUser'] = this.updatedByUser ? this.updatedByUser.toJSON() : (undefined as any);
    if (Array.isArray(this.couponUsages)) {
      data['couponUsages'] = [];
      for (let item of this.couponUsages)
        data['couponUsages'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface ICoupon {
  couponId?: string;
  code: string;
  name: string;
  description?: string | undefined;
  discountType?: number;
  discountValue: number;
  minOrderAmount?: number | undefined;
  maxDiscountAmount?: number | undefined;
  usageLimit?: number | undefined;
  usageCount?: number;
  userUsageLimit?: number;
  validFrom?: Date;
  validTo?: Date;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  createdBy?: string;
  updatedBy?: string | undefined;
  createdByUser?: User;
  updatedByUser?: User | undefined;
  couponUsages?: CouponUsage[];
}

export class RewardPoint implements IRewardPoint {
  rewardId?: string;
  userId?: string;
  points?: number;
  reason?: string | undefined;
  createdAt?: Date;
  expiresAt?: Date | undefined;
  user?: User;

  constructor(data?: IRewardPoint) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rewardId = _data['rewardId'];
      this.userId = _data['userId'];
      this.points = _data['points'];
      this.reason = _data['reason'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.expiresAt = _data['expiresAt']
        ? new Date(_data['expiresAt'].toString())
        : (undefined as any);
      this.user = _data['user'] ? User.fromJS(_data['user']) : (undefined as any);
    }
  }

  static fromJS(data: any): RewardPoint {
    data = typeof data === 'object' ? data : {};
    let result = new RewardPoint();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['rewardId'] = this.rewardId;
    data['userId'] = this.userId;
    data['points'] = this.points;
    data['reason'] = this.reason;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['expiresAt'] = this.expiresAt ? this.expiresAt.toISOString() : (undefined as any);
    data['user'] = this.user ? this.user.toJSON() : (undefined as any);
    return data;
  }
}

export interface IRewardPoint {
  rewardId?: string;
  userId?: string;
  points?: number;
  reason?: string | undefined;
  createdAt?: Date;
  expiresAt?: Date | undefined;
  user?: User;
}

export class PagedRequest implements IPagedRequest {
  page?: number;
  pageSize?: number;
  search?: string | undefined;
  sortBy?: string | undefined;
  sortDirection?: SortDirection;
  filters?: FilterCriteria[];
  hasFilters?: boolean;
  hasSearch?: boolean;
  hasSorting?: boolean;

  constructor(data?: IPagedRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.search = _data['search'];
      this.sortBy = _data['sortBy'];
      this.sortDirection = _data['sortDirection'];
      if (Array.isArray(_data['filters'])) {
        this.filters = [] as any;
        for (let item of _data['filters']) this.filters!.push(FilterCriteria.fromJS(item));
      }
      this.hasFilters = _data['hasFilters'];
      this.hasSearch = _data['hasSearch'];
      this.hasSorting = _data['hasSorting'];
    }
  }

  static fromJS(data: any): PagedRequest {
    data = typeof data === 'object' ? data : {};
    let result = new PagedRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['search'] = this.search;
    data['sortBy'] = this.sortBy;
    data['sortDirection'] = this.sortDirection;
    if (Array.isArray(this.filters)) {
      data['filters'] = [];
      for (let item of this.filters)
        data['filters'].push(item ? item.toJSON() : (undefined as any));
    }
    data['hasFilters'] = this.hasFilters;
    data['hasSearch'] = this.hasSearch;
    data['hasSorting'] = this.hasSorting;
    return data;
  }
}

export interface IPagedRequest {
  page?: number;
  pageSize?: number;
  search?: string | undefined;
  sortBy?: string | undefined;
  sortDirection?: SortDirection;
  filters?: FilterCriteria[];
  hasFilters?: boolean;
  hasSearch?: boolean;
  hasSorting?: boolean;
}

export enum SortDirection {
  Ascending = 'Ascending',
  Descending = 'Descending',
}

export class FilterCriteria implements IFilterCriteria {
  fieldName?: string;
  value?: any;
  operator?: FilterOperator;

  constructor(data?: IFilterCriteria) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fieldName = _data['fieldName'];
      this.value = _data['value'];
      this.operator = _data['operator'];
    }
  }

  static fromJS(data: any): FilterCriteria {
    data = typeof data === 'object' ? data : {};
    let result = new FilterCriteria();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fieldName'] = this.fieldName;
    data['value'] = this.value;
    data['operator'] = this.operator;
    return data;
  }
}

export interface IFilterCriteria {
  fieldName?: string;
  value?: any;
  operator?: FilterOperator;
}

export enum FilterOperator {
  Equals = 0,
  NotEquals = 1,
  Contains = 2,
  NotContains = 3,
  StartsWith = 4,
  EndsWith = 5,
  GreaterThan = 6,
  GreaterThanOrEqual = 7,
  LessThan = 8,
  LessThanOrEqual = 9,
  In = 10,
  NotIn = 11,
  IsNull = 12,
  IsNotNull = 13,
}

export class ResultOfAuditLog implements IResultOfAuditLog {
  isSuccess?: boolean;
  data?: AuditLog;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfAuditLog) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? AuditLog.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfAuditLog {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfAuditLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfAuditLog {
  isSuccess?: boolean;
  data?: AuditLog;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfBoolean implements IResultOfBoolean {
  isSuccess?: boolean;
  data?: boolean;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfBoolean) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'];
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfBoolean {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfBoolean();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data;
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfBoolean {
  isSuccess?: boolean;
  data?: boolean;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfInteger implements IResultOfInteger {
  isSuccess?: boolean;
  data?: number;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'];
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfInteger {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data;
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfInteger {
  isSuccess?: boolean;
  data?: number;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfDictionaryOfStringAndInteger implements IResultOfDictionaryOfStringAndInteger {
  isSuccess?: boolean;
  data?: { [key: string]: number } | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfDictionaryOfStringAndInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      if (_data['data']) {
        this.data = {} as any;
        for (let key in _data['data']) {
          if (_data['data'].hasOwnProperty(key)) (this.data as any)![key] = _data['data'][key];
        }
      }
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfDictionaryOfStringAndInteger {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfDictionaryOfStringAndInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    if (this.data) {
      data['data'] = {};
      for (let key in this.data) {
        if (this.data.hasOwnProperty(key)) (data['data'] as any)[key] = (this.data as any)[key];
      }
    }
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfDictionaryOfStringAndInteger {
  isSuccess?: boolean;
  data?: { [key: string]: number } | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfRegisterResponse implements IResultOfRegisterResponse {
  isSuccess?: boolean;
  data?: RegisterResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfRegisterResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? RegisterResponse.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfRegisterResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfRegisterResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfRegisterResponse {
  isSuccess?: boolean;
  data?: RegisterResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class RegisterResponse implements IRegisterResponse {
  userId?: string;
  email?: string;
  username?: string;
  role?: string;
  token?: string;
  refreshToken?: string;
  expiresAt?: Date;

  constructor(data?: IRegisterResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.email = _data['email'];
      this.username = _data['username'];
      this.role = _data['role'];
      this.token = _data['token'];
      this.refreshToken = _data['refreshToken'];
      this.expiresAt = _data['expiresAt']
        ? new Date(_data['expiresAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): RegisterResponse {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['email'] = this.email;
    data['username'] = this.username;
    data['role'] = this.role;
    data['token'] = this.token;
    data['refreshToken'] = this.refreshToken;
    data['expiresAt'] = this.expiresAt ? this.expiresAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IRegisterResponse {
  userId?: string;
  email?: string;
  username?: string;
  role?: string;
  token?: string;
  refreshToken?: string;
  expiresAt?: Date;
}

export class RegisterCommand implements IRegisterCommand {
  email?: string;
  username?: string;
  password?: string;

  constructor(data?: IRegisterCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.username = _data['username'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): RegisterCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RegisterCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['username'] = this.username;
    data['password'] = this.password;
    return data;
  }
}

export interface IRegisterCommand {
  email?: string;
  username?: string;
  password?: string;
}

export class ResultOfLoginResponse implements IResultOfLoginResponse {
  isSuccess?: boolean;
  data?: LoginResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfLoginResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? LoginResponse.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfLoginResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfLoginResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfLoginResponse {
  isSuccess?: boolean;
  data?: LoginResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class LoginResponse implements ILoginResponse {
  userId?: string;
  username?: string;
  role?: string;
  email?: string;
  token?: string;
  refreshToken?: string;
  expiresAt?: Date;

  constructor(data?: ILoginResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.username = _data['username'];
      this.role = _data['role'];
      this.email = _data['email'];
      this.token = _data['token'];
      this.refreshToken = _data['refreshToken'];
      this.expiresAt = _data['expiresAt']
        ? new Date(_data['expiresAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): LoginResponse {
    data = typeof data === 'object' ? data : {};
    let result = new LoginResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['username'] = this.username;
    data['role'] = this.role;
    data['email'] = this.email;
    data['token'] = this.token;
    data['refreshToken'] = this.refreshToken;
    data['expiresAt'] = this.expiresAt ? this.expiresAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface ILoginResponse {
  userId?: string;
  username?: string;
  role?: string;
  email?: string;
  token?: string;
  refreshToken?: string;
  expiresAt?: Date;
}

export class LoginCommand implements ILoginCommand {
  emailOrUsername?: string;
  password?: string;

  constructor(data?: ILoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.emailOrUsername = _data['emailOrUsername'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['emailOrUsername'] = this.emailOrUsername;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginCommand {
  emailOrUsername?: string;
  password?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
  email?: string;
  resetToken?: string;
  oldPassword?: string | undefined;
  newPassword?: string | undefined;

  constructor(data?: IResetPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.resetToken = _data['resetToken'];
      this.oldPassword = _data['oldPassword'];
      this.newPassword = _data['newPassword'];
    }
  }

  static fromJS(data: any): ResetPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['resetToken'] = this.resetToken;
    data['oldPassword'] = this.oldPassword;
    data['newPassword'] = this.newPassword;
    return data;
  }
}

export interface IResetPasswordCommand {
  email?: string;
  resetToken?: string;
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
}

export class LogoutCommand implements ILogoutCommand {
  refreshToken?: string;

  constructor(data?: ILogoutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): LogoutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LogoutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface ILogoutCommand {
  refreshToken?: string;
}

export class LogoutCommand implements ILogoutCommand {
  refreshToken?: string;

  constructor(data?: ILogoutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): LogoutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LogoutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface ILogoutCommand {
  refreshToken?: string;
}

export class ResultOfRefreshTokenResponse implements IResultOfRefreshTokenResponse {
  isSuccess?: boolean;
  data?: RefreshTokenResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfRefreshTokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? RefreshTokenResponse.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfRefreshTokenResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfRefreshTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfRefreshTokenResponse {
  isSuccess?: boolean;
  data?: RefreshTokenResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class RefreshTokenResponse implements IRefreshTokenResponse {
  accessToken?: string;
  refreshToken?: string;
  expiresAt?: Date;

  constructor(data?: IRefreshTokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data['accessToken'];
      this.refreshToken = _data['refreshToken'];
      this.expiresAt = _data['expiresAt']
        ? new Date(_data['expiresAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): RefreshTokenResponse {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['accessToken'] = this.accessToken;
    data['refreshToken'] = this.refreshToken;
    data['expiresAt'] = this.expiresAt ? this.expiresAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IRefreshTokenResponse {
  accessToken?: string;
  refreshToken?: string;
  expiresAt?: Date;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
  refreshToken?: string;

  constructor(data?: IRefreshTokenCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): RefreshTokenCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IRefreshTokenCommand {
  refreshToken?: string;
}

export class SearchableField implements ISearchableField {
  fieldName?: string;
  fieldType?: string;
  isSearchable?: boolean;
  isSortable?: boolean;
  isFilterable?: boolean;

  constructor(data?: ISearchableField) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fieldName = _data['fieldName'];
      this.fieldType = _data['fieldType'];
      this.isSearchable = _data['isSearchable'];
      this.isSortable = _data['isSortable'];
      this.isFilterable = _data['isFilterable'];
    }
  }

  static fromJS(data: any): SearchableField {
    data = typeof data === 'object' ? data : {};
    let result = new SearchableField();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fieldName'] = this.fieldName;
    data['fieldType'] = this.fieldType;
    data['isSearchable'] = this.isSearchable;
    data['isSortable'] = this.isSortable;
    data['isFilterable'] = this.isFilterable;
    return data;
  }
}

export interface ISearchableField {
  fieldName?: string;
  fieldType?: string;
  isSearchable?: boolean;
  isSortable?: boolean;
  isFilterable?: boolean;
}

export class CreateBrandCommand implements ICreateBrandCommand {
  description?: string;
  logoUrl?: string;
  name?: string;
  slug?: string;
  website?: string | undefined;
  status?: number;

  constructor(data?: ICreateBrandCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description'];
      this.logoUrl = _data['logoUrl'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.website = _data['website'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): CreateBrandCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateBrandCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['logoUrl'] = this.logoUrl;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['website'] = this.website;
    data['status'] = this.status;
    return data;
  }
}

export interface ICreateBrandCommand {
  description?: string;
  logoUrl?: string;
  name?: string;
  slug?: string;
  website?: string | undefined;
  status?: number;
}

export class UpdateBrandCommand implements IUpdateBrandCommand {
  brandId?: string;
  name?: string | undefined;
  slug?: string | undefined;
  description?: string | undefined;
  logoUrl?: string | undefined;
  website?: string | undefined;
  status?: number | undefined;

  constructor(data?: IUpdateBrandCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.brandId = _data['brandId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.logoUrl = _data['logoUrl'];
      this.website = _data['website'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): UpdateBrandCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateBrandCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['brandId'] = this.brandId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['logoUrl'] = this.logoUrl;
    data['website'] = this.website;
    data['status'] = this.status;
    return data;
  }
}

export interface IUpdateBrandCommand {
  brandId?: string;
  name?: string | undefined;
  slug?: string | undefined;
  description?: string | undefined;
  logoUrl?: string | undefined;
  website?: string | undefined;
  status?: number | undefined;
}

export class UpdateBrandStatusCommand implements IUpdateBrandStatusCommand {
  brandId?: string;
  status?: number;

  constructor(data?: IUpdateBrandStatusCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.brandId = _data['brandId'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): UpdateBrandStatusCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateBrandStatusCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['brandId'] = this.brandId;
    data['status'] = this.status;
    return data;
  }
}

export interface IUpdateBrandStatusCommand {
  brandId?: string;
  status?: number;
}

export class ResultOfShoppingCartDto implements IResultOfShoppingCartDto {
  isSuccess?: boolean;
  data?: ShoppingCartDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? ShoppingCartDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfShoppingCartDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfShoppingCartDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfShoppingCartDto {
  isSuccess?: boolean;
  data?: ShoppingCartDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ShoppingCartDto implements IShoppingCartDto {
  cartId?: string;
  userId?: string | undefined;
  sessionId?: string | undefined;
  subTotal?: number;
  taxAmount?: number;
  shippingAmount?: number;
  discountAmount?: number;
  totalAmount?: number;
  couponCode?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  items?: ShoppingCartItemDto[];

  constructor(data?: IShoppingCartDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cartId = _data['cartId'];
      this.userId = _data['userId'];
      this.sessionId = _data['sessionId'];
      this.subTotal = _data['subTotal'];
      this.taxAmount = _data['taxAmount'];
      this.shippingAmount = _data['shippingAmount'];
      this.discountAmount = _data['discountAmount'];
      this.totalAmount = _data['totalAmount'];
      this.couponCode = _data['couponCode'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ShoppingCartItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ShoppingCartDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cartId'] = this.cartId;
    data['userId'] = this.userId;
    data['sessionId'] = this.sessionId;
    data['subTotal'] = this.subTotal;
    data['taxAmount'] = this.taxAmount;
    data['shippingAmount'] = this.shippingAmount;
    data['discountAmount'] = this.discountAmount;
    data['totalAmount'] = this.totalAmount;
    data['couponCode'] = this.couponCode;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IShoppingCartDto {
  cartId?: string;
  userId?: string | undefined;
  sessionId?: string | undefined;
  subTotal?: number;
  taxAmount?: number;
  shippingAmount?: number;
  discountAmount?: number;
  totalAmount?: number;
  couponCode?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  items?: ShoppingCartItemDto[];
}

export class ShoppingCartItemDto implements IShoppingCartItemDto {
  cartItemId?: string;
  cartId?: string;
  productId?: string;
  productName?: string;
  productSku?: string;
  productImageUrl?: string | undefined;
  productVariantId?: string | undefined;
  variantName?: string | undefined;
  unitPrice?: number;
  quantity?: number;
  totalPrice?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;

  constructor(data?: IShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.cartItemId = _data['cartItemId'];
      this.cartId = _data['cartId'];
      this.productId = _data['productId'];
      this.productName = _data['productName'];
      this.productSku = _data['productSku'];
      this.productImageUrl = _data['productImageUrl'];
      this.productVariantId = _data['productVariantId'];
      this.variantName = _data['variantName'];
      this.unitPrice = _data['unitPrice'];
      this.quantity = _data['quantity'];
      this.totalPrice = _data['totalPrice'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): ShoppingCartItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ShoppingCartItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['cartItemId'] = this.cartItemId;
    data['cartId'] = this.cartId;
    data['productId'] = this.productId;
    data['productName'] = this.productName;
    data['productSku'] = this.productSku;
    data['productImageUrl'] = this.productImageUrl;
    data['productVariantId'] = this.productVariantId;
    data['variantName'] = this.variantName;
    data['unitPrice'] = this.unitPrice;
    data['quantity'] = this.quantity;
    data['totalPrice'] = this.totalPrice;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IShoppingCartItemDto {
  cartItemId?: string;
  cartId?: string;
  productId?: string;
  productName?: string;
  productSku?: string;
  productImageUrl?: string | undefined;
  productVariantId?: string | undefined;
  variantName?: string | undefined;
  unitPrice?: number;
  quantity?: number;
  totalPrice?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
}

export class ResultOfDecimal implements IResultOfDecimal {
  isSuccess?: boolean;
  data?: number;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfDecimal) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'];
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfDecimal {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfDecimal();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data;
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfDecimal {
  isSuccess?: boolean;
  data?: number;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfCartSummaryDto implements IResultOfCartSummaryDto {
  isSuccess?: boolean;
  data?: CartSummaryDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCartSummaryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? CartSummaryDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCartSummaryDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCartSummaryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCartSummaryDto {
  isSuccess?: boolean;
  data?: CartSummaryDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CartSummaryDto implements ICartSummaryDto {
  itemCount?: number;
  subTotal?: number;
  taxAmount?: number;
  shippingAmount?: number;
  discountAmount?: number;
  totalAmount?: number;
  couponCode?: string | undefined;
  isValid?: boolean;
  validationErrors?: string[];

  constructor(data?: ICartSummaryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.itemCount = _data['itemCount'];
      this.subTotal = _data['subTotal'];
      this.taxAmount = _data['taxAmount'];
      this.shippingAmount = _data['shippingAmount'];
      this.discountAmount = _data['discountAmount'];
      this.totalAmount = _data['totalAmount'];
      this.couponCode = _data['couponCode'];
      this.isValid = _data['isValid'];
      if (Array.isArray(_data['validationErrors'])) {
        this.validationErrors = [] as any;
        for (let item of _data['validationErrors']) this.validationErrors!.push(item);
      }
    }
  }

  static fromJS(data: any): CartSummaryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CartSummaryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['itemCount'] = this.itemCount;
    data['subTotal'] = this.subTotal;
    data['taxAmount'] = this.taxAmount;
    data['shippingAmount'] = this.shippingAmount;
    data['discountAmount'] = this.discountAmount;
    data['totalAmount'] = this.totalAmount;
    data['couponCode'] = this.couponCode;
    data['isValid'] = this.isValid;
    if (Array.isArray(this.validationErrors)) {
      data['validationErrors'] = [];
      for (let item of this.validationErrors) data['validationErrors'].push(item);
    }
    return data;
  }
}

export interface ICartSummaryDto {
  itemCount?: number;
  subTotal?: number;
  taxAmount?: number;
  shippingAmount?: number;
  discountAmount?: number;
  totalAmount?: number;
  couponCode?: string | undefined;
  isValid?: boolean;
  validationErrors?: string[];
}

export class ResultOfListOfShoppingCartItemDto implements IResultOfListOfShoppingCartItemDto {
  isSuccess?: boolean;
  data?: ShoppingCartItemDto[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfListOfShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(ShoppingCartItemDto.fromJS(item));
      }
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfListOfShoppingCartItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfListOfShoppingCartItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item ? item.toJSON() : (undefined as any));
    }
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfListOfShoppingCartItemDto {
  isSuccess?: boolean;
  data?: ShoppingCartItemDto[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfShoppingCartItemDto implements IResultOfShoppingCartItemDto {
  isSuccess?: boolean;
  data?: ShoppingCartItemDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfShoppingCartItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? ShoppingCartItemDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfShoppingCartItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfShoppingCartItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfShoppingCartItemDto {
  isSuccess?: boolean;
  data?: ShoppingCartItemDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class AddToCartRequest implements IAddToCartRequest {
  userId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  quantity?: number;

  constructor(data?: IAddToCartRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.productId = _data['productId'];
      this.productVariantId = _data['productVariantId'];
      this.quantity = _data['quantity'];
    }
  }

  static fromJS(data: any): AddToCartRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddToCartRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['productId'] = this.productId;
    data['productVariantId'] = this.productVariantId;
    data['quantity'] = this.quantity;
    return data;
  }
}

export interface IAddToCartRequest {
  userId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  quantity?: number;
}

export class UpdateQuantityRequest implements IUpdateQuantityRequest {
  userId?: string;
  quantity?: number;

  constructor(data?: IUpdateQuantityRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.quantity = _data['quantity'];
    }
  }

  static fromJS(data: any): UpdateQuantityRequest {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateQuantityRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['quantity'] = this.quantity;
    return data;
  }
}

export interface IUpdateQuantityRequest {
  userId?: string;
  quantity?: number;
}

export class RemoveItemRequest implements IRemoveItemRequest {
  userId?: string;

  constructor(data?: IRemoveItemRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): RemoveItemRequest {
    data = typeof data === 'object' ? data : {};
    let result = new RemoveItemRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface IRemoveItemRequest {
  userId?: string;
}

export class ResultOfWishlistDto implements IResultOfWishlistDto {
  isSuccess?: boolean;
  data?: WishlistDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfWishlistDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? WishlistDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfWishlistDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfWishlistDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfWishlistDto {
  isSuccess?: boolean;
  data?: WishlistDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class WishlistDto implements IWishlistDto {
  wishlistId?: string;
  userId?: string;
  name?: string | undefined;
  isDefault?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  items?: WishlistItemDto[];

  constructor(data?: IWishlistDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.wishlistId = _data['wishlistId'];
      this.userId = _data['userId'];
      this.name = _data['name'];
      this.isDefault = _data['isDefault'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(WishlistItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): WishlistDto {
    data = typeof data === 'object' ? data : {};
    let result = new WishlistDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishlistId'] = this.wishlistId;
    data['userId'] = this.userId;
    data['name'] = this.name;
    data['isDefault'] = this.isDefault;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IWishlistDto {
  wishlistId?: string;
  userId?: string;
  name?: string | undefined;
  isDefault?: boolean;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  items?: WishlistItemDto[];
}

export class WishlistItemDto implements IWishlistItemDto {
  wishlistItemId?: string;
  wishlistId?: string;
  productId?: string;
  productName?: string;
  productSku?: string;
  productImageUrl?: string | undefined;
  productPrice?: number;
  productDiscountPrice?: number | undefined;
  productStockQuantity?: number;
  productVariantId?: string | undefined;
  variantName?: string | undefined;
  createdAt?: Date;

  constructor(data?: IWishlistItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.wishlistItemId = _data['wishlistItemId'];
      this.wishlistId = _data['wishlistId'];
      this.productId = _data['productId'];
      this.productName = _data['productName'];
      this.productSku = _data['productSku'];
      this.productImageUrl = _data['productImageUrl'];
      this.productPrice = _data['productPrice'];
      this.productDiscountPrice = _data['productDiscountPrice'];
      this.productStockQuantity = _data['productStockQuantity'];
      this.productVariantId = _data['productVariantId'];
      this.variantName = _data['variantName'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): WishlistItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new WishlistItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['wishlistItemId'] = this.wishlistItemId;
    data['wishlistId'] = this.wishlistId;
    data['productId'] = this.productId;
    data['productName'] = this.productName;
    data['productSku'] = this.productSku;
    data['productImageUrl'] = this.productImageUrl;
    data['productPrice'] = this.productPrice;
    data['productDiscountPrice'] = this.productDiscountPrice;
    data['productStockQuantity'] = this.productStockQuantity;
    data['productVariantId'] = this.productVariantId;
    data['variantName'] = this.variantName;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IWishlistItemDto {
  wishlistItemId?: string;
  wishlistId?: string;
  productId?: string;
  productName?: string;
  productSku?: string;
  productImageUrl?: string | undefined;
  productPrice?: number;
  productDiscountPrice?: number | undefined;
  productStockQuantity?: number;
  productVariantId?: string | undefined;
  variantName?: string | undefined;
  createdAt?: Date;
}

export class ResultOfListOfWishlistItemDto implements IResultOfListOfWishlistItemDto {
  isSuccess?: boolean;
  data?: WishlistItemDto[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfListOfWishlistItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(WishlistItemDto.fromJS(item));
      }
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfListOfWishlistItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfListOfWishlistItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item ? item.toJSON() : (undefined as any));
    }
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfListOfWishlistItemDto {
  isSuccess?: boolean;
  data?: WishlistItemDto[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfWishlistItemDto implements IResultOfWishlistItemDto {
  isSuccess?: boolean;
  data?: WishlistItemDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfWishlistItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? WishlistItemDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfWishlistItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfWishlistItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfWishlistItemDto {
  isSuccess?: boolean;
  data?: WishlistItemDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class AddToWishlistRequest implements IAddToWishlistRequest {
  productId?: string;
  variantId?: string | undefined;

  constructor(data?: IAddToWishlistRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.variantId = _data['variantId'];
    }
  }

  static fromJS(data: any): AddToWishlistRequest {
    data = typeof data === 'object' ? data : {};
    let result = new AddToWishlistRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['variantId'] = this.variantId;
    return data;
  }
}

export interface IAddToWishlistRequest {
  productId?: string;
  variantId?: string | undefined;
}

export class MoveToCartRequest implements IMoveToCartRequest {
  quantity?: number;

  constructor(data?: IMoveToCartRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.quantity = _data['quantity'];
    }
  }

  static fromJS(data: any): MoveToCartRequest {
    data = typeof data === 'object' ? data : {};
    let result = new MoveToCartRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['quantity'] = this.quantity;
    return data;
  }
}

export interface IMoveToCartRequest {
  quantity?: number;
}

export class MergeCartsRequest implements IMergeCartsRequest {
  guestCartId?: string;

  constructor(data?: IMergeCartsRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.guestCartId = _data['guestCartId'];
    }
  }

  static fromJS(data: any): MergeCartsRequest {
    data = typeof data === 'object' ? data : {};
    let result = new MergeCartsRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['guestCartId'] = this.guestCartId;
    return data;
  }
}

export interface IMergeCartsRequest {
  guestCartId?: string;
}

export class ApplyCouponRequest implements IApplyCouponRequest {
  couponCode?: string;

  constructor(data?: IApplyCouponRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.couponCode = _data['couponCode'];
    }
  }

  static fromJS(data: any): ApplyCouponRequest {
    data = typeof data === 'object' ? data : {};
    let result = new ApplyCouponRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['couponCode'] = this.couponCode;
    return data;
  }
}

export interface IApplyCouponRequest {
  couponCode?: string;
}

export class ResultOfPagedResultOfCategoryDto implements IResultOfPagedResultOfCategoryDto {
  isSuccess?: boolean;
  data?: PagedResultOfCategoryDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfCategoryDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfCategoryDto {
  isSuccess?: boolean;
  data?: PagedResultOfCategoryDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfCategoryDto implements IPagedResultOfCategoryDto {
  items?: CategoryDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CategoryDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfCategoryDto {
  items?: CategoryDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class CategoryDto implements ICategoryDto {
  categoryId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  imageUrl?: string | undefined;
  parentCategoryId?: string | undefined;
  parentCategoryName?: string | undefined;
  displayOrder?: number;
  status?: number;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  subCategories?: CategoryDto[];
  productCount?: number;

  constructor(data?: ICategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId = _data['categoryId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.imageUrl = _data['imageUrl'];
      this.parentCategoryId = _data['parentCategoryId'];
      this.parentCategoryName = _data['parentCategoryName'];
      this.displayOrder = _data['displayOrder'];
      this.status = _data['status'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['subCategories'])) {
        this.subCategories = [] as any;
        for (let item of _data['subCategories']) this.subCategories!.push(CategoryDto.fromJS(item));
      }
      this.productCount = _data['productCount'];
    }
  }

  static fromJS(data: any): CategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['categoryId'] = this.categoryId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['imageUrl'] = this.imageUrl;
    data['parentCategoryId'] = this.parentCategoryId;
    data['parentCategoryName'] = this.parentCategoryName;
    data['displayOrder'] = this.displayOrder;
    data['status'] = this.status;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    if (Array.isArray(this.subCategories)) {
      data['subCategories'] = [];
      for (let item of this.subCategories)
        data['subCategories'].push(item ? item.toJSON() : (undefined as any));
    }
    data['productCount'] = this.productCount;
    return data;
  }
}

export interface ICategoryDto {
  categoryId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  imageUrl?: string | undefined;
  parentCategoryId?: string | undefined;
  parentCategoryName?: string | undefined;
  displayOrder?: number;
  status?: number;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  subCategories?: CategoryDto[];
  productCount?: number;
}

export class ResultOfListOfCategoryDto implements IResultOfListOfCategoryDto {
  isSuccess?: boolean;
  data?: CategoryDto[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfListOfCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(CategoryDto.fromJS(item));
      }
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfListOfCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfListOfCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item ? item.toJSON() : (undefined as any));
    }
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfListOfCategoryDto {
  isSuccess?: boolean;
  data?: CategoryDto[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfCategoryDto implements IResultOfCategoryDto {
  isSuccess?: boolean;
  data?: CategoryDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCategoryDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? CategoryDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCategoryDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCategoryDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCategoryDto {
  isSuccess?: boolean;
  data?: CategoryDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  parentCategoryId?: string | undefined;
  status?: number;
  displayOrder?: number;

  constructor(data?: ICreateCategoryCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      this.parentCategoryId = _data['parentCategoryId'];
      this.status = _data['status'];
      this.displayOrder = _data['displayOrder'];
    }
  }

  static fromJS(data: any): CreateCategoryCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateCategoryCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    data['parentCategoryId'] = this.parentCategoryId;
    data['status'] = this.status;
    data['displayOrder'] = this.displayOrder;
    return data;
  }
}

export interface ICreateCategoryCommand {
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  parentCategoryId?: string | undefined;
  status?: number;
  displayOrder?: number;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
  categoryId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  parentCategoryId?: string | undefined;
  status?: number;
  displayOrder?: number;

  constructor(data?: IUpdateCategoryCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId = _data['categoryId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      this.parentCategoryId = _data['parentCategoryId'];
      this.status = _data['status'];
      this.displayOrder = _data['displayOrder'];
    }
  }

  static fromJS(data: any): UpdateCategoryCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCategoryCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['categoryId'] = this.categoryId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    data['parentCategoryId'] = this.parentCategoryId;
    data['status'] = this.status;
    data['displayOrder'] = this.displayOrder;
    return data;
  }
}

export interface IUpdateCategoryCommand {
  categoryId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  parentCategoryId?: string | undefined;
  status?: number;
  displayOrder?: number;
}

export class UpdateCategoryStatusCommand implements IUpdateCategoryStatusCommand {
  categoryId?: string;
  status?: number;

  constructor(data?: IUpdateCategoryStatusCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.categoryId = _data['categoryId'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): UpdateCategoryStatusCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateCategoryStatusCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['categoryId'] = this.categoryId;
    data['status'] = this.status;
    return data;
  }
}

export interface IUpdateCategoryStatusCommand {
  categoryId?: string;
  status?: number;
}

export class ResultOfString implements IResultOfString {
  isSuccess?: boolean;
  data?: string | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'];
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfString {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data;
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfString {
  isSuccess?: boolean;
  data?: string | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfObject implements IResultOfObject {
  isSuccess?: boolean;
  data?: any | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfObject) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'];
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfObject {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfObject();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data;
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfObject {
  isSuccess?: boolean;
  data?: any | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfListOfString implements IResultOfListOfString {
  isSuccess?: boolean;
  data?: string[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfListOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      if (Array.isArray(_data['data'])) {
        this.data = [] as any;
        for (let item of _data['data']) this.data!.push(item);
      }
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfListOfString {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfListOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    if (Array.isArray(this.data)) {
      data['data'] = [];
      for (let item of this.data) data['data'].push(item);
    }
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfListOfString {
  isSuccess?: boolean;
  data?: string[] | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfPagedResultOfProductAttributeDto
  implements IResultOfPagedResultOfProductAttributeDto
{
  isSuccess?: boolean;
  data?: PagedResultOfProductAttributeDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfProductAttributeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfProductAttributeDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfProductAttributeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfProductAttributeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfProductAttributeDto {
  isSuccess?: boolean;
  data?: PagedResultOfProductAttributeDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfProductAttributeDto implements IPagedResultOfProductAttributeDto {
  items?: ProductAttributeDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfProductAttributeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductAttributeDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfProductAttributeDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductAttributeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfProductAttributeDto {
  items?: ProductAttributeDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class ProductAttributeDto implements IProductAttributeDto {
  productAttributeId?: string;
  name?: string;
  description?: string | undefined;
  dataType?: string;
  isRequired?: boolean;
  isSearchable?: boolean;
  isFilterable?: boolean;
  displayOrder?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;

  constructor(data?: IProductAttributeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productAttributeId = _data['productAttributeId'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.dataType = _data['dataType'];
      this.isRequired = _data['isRequired'];
      this.isSearchable = _data['isSearchable'];
      this.isFilterable = _data['isFilterable'];
      this.displayOrder = _data['displayOrder'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductAttributeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductAttributeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productAttributeId'] = this.productAttributeId;
    data['name'] = this.name;
    data['description'] = this.description;
    data['dataType'] = this.dataType;
    data['isRequired'] = this.isRequired;
    data['isSearchable'] = this.isSearchable;
    data['isFilterable'] = this.isFilterable;
    data['displayOrder'] = this.displayOrder;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IProductAttributeDto {
  productAttributeId?: string;
  name?: string;
  description?: string | undefined;
  dataType?: string;
  isRequired?: boolean;
  isSearchable?: boolean;
  isFilterable?: boolean;
  displayOrder?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
}

export class ResultOfProductAttributeDto implements IResultOfProductAttributeDto {
  isSuccess?: boolean;
  data?: ProductAttributeDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfProductAttributeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? ProductAttributeDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfProductAttributeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfProductAttributeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfProductAttributeDto {
  isSuccess?: boolean;
  data?: ProductAttributeDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfCreateProductAttributeResponse
  implements IResultOfCreateProductAttributeResponse
{
  isSuccess?: boolean;
  data?: CreateProductAttributeResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCreateProductAttributeResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? CreateProductAttributeResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCreateProductAttributeResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCreateProductAttributeResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCreateProductAttributeResponse {
  isSuccess?: boolean;
  data?: CreateProductAttributeResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CreateProductAttributeResponse
  extends ProductAttributeDto
  implements ICreateProductAttributeResponse
{
  constructor(data?: ICreateProductAttributeResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): CreateProductAttributeResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductAttributeResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateProductAttributeResponse extends IProductAttributeDto {}

export class CreateProductAttributeCommand implements ICreateProductAttributeCommand {
  name?: string;
  displayName?: string;
  attributeType?: number;
  isRequired?: boolean;
  displayOrder?: number;

  constructor(data?: ICreateProductAttributeCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.attributeType = _data['attributeType'];
      this.isRequired = _data['isRequired'];
      this.displayOrder = _data['displayOrder'];
    }
  }

  static fromJS(data: any): CreateProductAttributeCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductAttributeCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['attributeType'] = this.attributeType;
    data['isRequired'] = this.isRequired;
    data['displayOrder'] = this.displayOrder;
    return data;
  }
}

export interface ICreateProductAttributeCommand {
  name?: string;
  displayName?: string;
  attributeType?: number;
  isRequired?: boolean;
  displayOrder?: number;
}

export class ResultOfUpdateProductAttributeResponse
  implements IResultOfUpdateProductAttributeResponse
{
  isSuccess?: boolean;
  data?: UpdateProductAttributeResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfUpdateProductAttributeResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? UpdateProductAttributeResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfUpdateProductAttributeResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfUpdateProductAttributeResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfUpdateProductAttributeResponse {
  isSuccess?: boolean;
  data?: UpdateProductAttributeResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class UpdateProductAttributeResponse
  extends ProductAttributeDto
  implements IUpdateProductAttributeResponse
{
  constructor(data?: IUpdateProductAttributeResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): UpdateProductAttributeResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductAttributeResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUpdateProductAttributeResponse extends IProductAttributeDto {}

export class UpdateProductAttributeCommand implements IUpdateProductAttributeCommand {
  attributeId?: string;
  name?: string;
  displayName?: string;
  attributeType?: number;
  isRequired?: boolean;
  displayOrder?: number;

  constructor(data?: IUpdateProductAttributeCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attributeId = _data['attributeId'];
      this.name = _data['name'];
      this.displayName = _data['displayName'];
      this.attributeType = _data['attributeType'];
      this.isRequired = _data['isRequired'];
      this.displayOrder = _data['displayOrder'];
    }
  }

  static fromJS(data: any): UpdateProductAttributeCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductAttributeCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['attributeId'] = this.attributeId;
    data['name'] = this.name;
    data['displayName'] = this.displayName;
    data['attributeType'] = this.attributeType;
    data['isRequired'] = this.isRequired;
    data['displayOrder'] = this.displayOrder;
    return data;
  }
}

export interface IUpdateProductAttributeCommand {
  attributeId?: string;
  name?: string;
  displayName?: string;
  attributeType?: number;
  isRequired?: boolean;
  displayOrder?: number;
}

export class ResultOfProductAttributeValueDto implements IResultOfProductAttributeValueDto {
  isSuccess?: boolean;
  data?: ProductAttributeValueDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfProductAttributeValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? ProductAttributeValueDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfProductAttributeValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfProductAttributeValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfProductAttributeValueDto {
  isSuccess?: boolean;
  data?: ProductAttributeValueDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ProductAttributeValueDto implements IProductAttributeValueDto {
  productAttributeValueId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  productAttributeId?: string;
  productAttributeName?: string;
  value?: string;
  createdAt?: Date;

  constructor(data?: IProductAttributeValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productAttributeValueId = _data['productAttributeValueId'];
      this.productId = _data['productId'];
      this.productVariantId = _data['productVariantId'];
      this.productAttributeId = _data['productAttributeId'];
      this.productAttributeName = _data['productAttributeName'];
      this.value = _data['value'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductAttributeValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductAttributeValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productAttributeValueId'] = this.productAttributeValueId;
    data['productId'] = this.productId;
    data['productVariantId'] = this.productVariantId;
    data['productAttributeId'] = this.productAttributeId;
    data['productAttributeName'] = this.productAttributeName;
    data['value'] = this.value;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IProductAttributeValueDto {
  productAttributeValueId?: string;
  productId?: string;
  productVariantId?: string | undefined;
  productAttributeId?: string;
  productAttributeName?: string;
  value?: string;
  createdAt?: Date;
}

export class ResultOfPagedResultOfProductAttributeValueDto
  implements IResultOfPagedResultOfProductAttributeValueDto
{
  isSuccess?: boolean;
  data?: PagedResultOfProductAttributeValueDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfProductAttributeValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfProductAttributeValueDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfProductAttributeValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfProductAttributeValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfProductAttributeValueDto {
  isSuccess?: boolean;
  data?: PagedResultOfProductAttributeValueDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfProductAttributeValueDto
  implements IPagedResultOfProductAttributeValueDto
{
  items?: ProductAttributeValueDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfProductAttributeValueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductAttributeValueDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfProductAttributeValueDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductAttributeValueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfProductAttributeValueDto {
  items?: ProductAttributeValueDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class ResultOfCreateProductAttributeValueResponse
  implements IResultOfCreateProductAttributeValueResponse
{
  isSuccess?: boolean;
  data?: CreateProductAttributeValueResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCreateProductAttributeValueResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? CreateProductAttributeValueResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCreateProductAttributeValueResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCreateProductAttributeValueResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCreateProductAttributeValueResponse {
  isSuccess?: boolean;
  data?: CreateProductAttributeValueResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CreateProductAttributeValueResponse
  extends ProductAttributeValueDto
  implements ICreateProductAttributeValueResponse
{
  constructor(data?: ICreateProductAttributeValueResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): CreateProductAttributeValueResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductAttributeValueResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateProductAttributeValueResponse extends IProductAttributeValueDto {}

export class CreateProductAttributeValueCommand implements ICreateProductAttributeValueCommand {
  productId?: string;
  attributeId?: string;
  value?: string;

  constructor(data?: ICreateProductAttributeValueCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.attributeId = _data['attributeId'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): CreateProductAttributeValueCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductAttributeValueCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['attributeId'] = this.attributeId;
    data['value'] = this.value;
    return data;
  }
}

export interface ICreateProductAttributeValueCommand {
  productId?: string;
  attributeId?: string;
  value?: string;
}

export class ResultOfUpdateProductAttributeValueResponse
  implements IResultOfUpdateProductAttributeValueResponse
{
  isSuccess?: boolean;
  data?: UpdateProductAttributeValueResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfUpdateProductAttributeValueResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? UpdateProductAttributeValueResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfUpdateProductAttributeValueResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfUpdateProductAttributeValueResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfUpdateProductAttributeValueResponse {
  isSuccess?: boolean;
  data?: UpdateProductAttributeValueResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class UpdateProductAttributeValueResponse
  extends ProductAttributeValueDto
  implements IUpdateProductAttributeValueResponse
{
  constructor(data?: IUpdateProductAttributeValueResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): UpdateProductAttributeValueResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductAttributeValueResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUpdateProductAttributeValueResponse extends IProductAttributeValueDto {}

export class UpdateProductAttributeValueCommand implements IUpdateProductAttributeValueCommand {
  valueId?: string;
  productId?: string;
  attributeId?: string;
  value?: string;

  constructor(data?: IUpdateProductAttributeValueCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.valueId = _data['valueId'];
      this.productId = _data['productId'];
      this.attributeId = _data['attributeId'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): UpdateProductAttributeValueCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductAttributeValueCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['valueId'] = this.valueId;
    data['productId'] = this.productId;
    data['attributeId'] = this.attributeId;
    data['value'] = this.value;
    return data;
  }
}

export interface IUpdateProductAttributeValueCommand {
  valueId?: string;
  productId?: string;
  attributeId?: string;
  value?: string;
}

export class ResultOfCreateProductResponse implements IResultOfCreateProductResponse {
  isSuccess?: boolean;
  data?: CreateProductResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCreateProductResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? CreateProductResponse.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCreateProductResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCreateProductResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCreateProductResponse {
  isSuccess?: boolean;
  data?: CreateProductResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ProductBaseResponse implements IProductBaseResponse {
  productId?: string;
  name?: string;
  slug?: string | undefined;
  sku?: string;
  description?: string;
  shortDescription?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  cost?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  categoryId?: string;
  categoryName?: string;
  brandId?: string | undefined;
  brandName?: string | undefined;
  status?: number;
  isFeatured?: boolean;
  isDigital?: boolean;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  primaryImageUrl?: string | undefined;
  images?: ProductImageDto[];
  variants?: ProductVariantDto[];
  tags?: ProductTagDto[];
  averageRating?: number | undefined;
  reviewCount?: number;

  constructor(data?: IProductBaseResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.sku = _data['sku'];
      this.description = _data['description'];
      this.shortDescription = _data['shortDescription'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.cost = _data['cost'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.categoryId = _data['categoryId'];
      this.categoryName = _data['categoryName'];
      this.brandId = _data['brandId'];
      this.brandName = _data['brandName'];
      this.status = _data['status'];
      this.isFeatured = _data['isFeatured'];
      this.isDigital = _data['isDigital'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.primaryImageUrl = _data['primaryImageUrl'];
      if (Array.isArray(_data['images'])) {
        this.images = [] as any;
        for (let item of _data['images']) this.images!.push(ProductImageDto.fromJS(item));
      }
      if (Array.isArray(_data['variants'])) {
        this.variants = [] as any;
        for (let item of _data['variants']) this.variants!.push(ProductVariantDto.fromJS(item));
      }
      if (Array.isArray(_data['tags'])) {
        this.tags = [] as any;
        for (let item of _data['tags']) this.tags!.push(ProductTagDto.fromJS(item));
      }
      this.averageRating = _data['averageRating'];
      this.reviewCount = _data['reviewCount'];
    }
  }

  static fromJS(data: any): ProductBaseResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ProductBaseResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['sku'] = this.sku;
    data['description'] = this.description;
    data['shortDescription'] = this.shortDescription;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['cost'] = this.cost;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['categoryId'] = this.categoryId;
    data['categoryName'] = this.categoryName;
    data['brandId'] = this.brandId;
    data['brandName'] = this.brandName;
    data['status'] = this.status;
    data['isFeatured'] = this.isFeatured;
    data['isDigital'] = this.isDigital;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['primaryImageUrl'] = this.primaryImageUrl;
    if (Array.isArray(this.images)) {
      data['images'] = [];
      for (let item of this.images) data['images'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.variants)) {
      data['variants'] = [];
      for (let item of this.variants)
        data['variants'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.tags)) {
      data['tags'] = [];
      for (let item of this.tags) data['tags'].push(item ? item.toJSON() : (undefined as any));
    }
    data['averageRating'] = this.averageRating;
    data['reviewCount'] = this.reviewCount;
    return data;
  }
}

export interface IProductBaseResponse {
  productId?: string;
  name?: string;
  slug?: string | undefined;
  sku?: string;
  description?: string;
  shortDescription?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  cost?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  categoryId?: string;
  categoryName?: string;
  brandId?: string | undefined;
  brandName?: string | undefined;
  status?: number;
  isFeatured?: boolean;
  isDigital?: boolean;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  primaryImageUrl?: string | undefined;
  images?: ProductImageDto[];
  variants?: ProductVariantDto[];
  tags?: ProductTagDto[];
  averageRating?: number | undefined;
  reviewCount?: number;
}

export class CreateProductResponse extends ProductBaseResponse implements ICreateProductResponse {
  constructor(data?: ICreateProductResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): CreateProductResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateProductResponse extends IProductBaseResponse {}

export class ProductImageDto implements IProductImageDto {
  productImageId?: string;
  productId?: string;
  imageUrl?: string;
  altText?: string | undefined;
  displayOrder?: number;
  isPrimary?: boolean;
  createdAt?: Date;

  constructor(data?: IProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productImageId = _data['productImageId'];
      this.productId = _data['productId'];
      this.imageUrl = _data['imageUrl'];
      this.altText = _data['altText'];
      this.displayOrder = _data['displayOrder'];
      this.isPrimary = _data['isPrimary'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductImageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productImageId'] = this.productImageId;
    data['productId'] = this.productId;
    data['imageUrl'] = this.imageUrl;
    data['altText'] = this.altText;
    data['displayOrder'] = this.displayOrder;
    data['isPrimary'] = this.isPrimary;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IProductImageDto {
  productImageId?: string;
  productId?: string;
  imageUrl?: string;
  altText?: string | undefined;
  displayOrder?: number;
  isPrimary?: boolean;
  createdAt?: Date;
}

export class ProductVariantDto implements IProductVariantDto {
  productVariantId?: string;
  productId?: string;
  sku?: string;
  name?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  attributes?: ProductAttributeValueDto[];

  constructor(data?: IProductVariantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productVariantId = _data['productVariantId'];
      this.productId = _data['productId'];
      this.sku = _data['sku'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      if (Array.isArray(_data['attributes'])) {
        this.attributes = [] as any;
        for (let item of _data['attributes'])
          this.attributes!.push(ProductAttributeValueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProductVariantDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductVariantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productVariantId'] = this.productVariantId;
    data['productId'] = this.productId;
    data['sku'] = this.sku;
    data['name'] = this.name;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    if (Array.isArray(this.attributes)) {
      data['attributes'] = [];
      for (let item of this.attributes)
        data['attributes'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface IProductVariantDto {
  productVariantId?: string;
  productId?: string;
  sku?: string;
  name?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  attributes?: ProductAttributeValueDto[];
}

export class ProductTagDto implements IProductTagDto {
  productTagId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  color?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  productCount?: number;

  constructor(data?: IProductTagDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productTagId = _data['productTagId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
      this.color = _data['color'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
      this.productCount = _data['productCount'];
    }
  }

  static fromJS(data: any): ProductTagDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductTagDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productTagId'] = this.productTagId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    data['color'] = this.color;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    data['productCount'] = this.productCount;
    return data;
  }
}

export interface IProductTagDto {
  productTagId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
  color?: string | undefined;
  createdAt?: Date;
  updatedAt?: Date | undefined;
  productCount?: number;
}

export class CreateProductVariantRequest implements ICreateProductVariantRequest {
  productId?: string;
  sku?: string;
  name?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;
  imageUrl?: string | undefined;
  attributes?: CreateProductAttributeValueRequest[];

  constructor(data?: ICreateProductVariantRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.sku = _data['sku'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.status = _data['status'];
      this.imageUrl = _data['imageUrl'];
      if (Array.isArray(_data['attributes'])) {
        this.attributes = [] as any;
        for (let item of _data['attributes'])
          this.attributes!.push(CreateProductAttributeValueRequest.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CreateProductVariantRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductVariantRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['sku'] = this.sku;
    data['name'] = this.name;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['status'] = this.status;
    data['imageUrl'] = this.imageUrl;
    if (Array.isArray(this.attributes)) {
      data['attributes'] = [];
      for (let item of this.attributes)
        data['attributes'].push(item ? item.toJSON() : (undefined as any));
    }
    return data;
  }
}

export interface ICreateProductVariantRequest {
  productId?: string;
  sku?: string;
  name?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;
  imageUrl?: string | undefined;
  attributes?: CreateProductAttributeValueRequest[];
}

export class CreateProductAttributeValueRequest implements ICreateProductAttributeValueRequest {
  productId?: string;
  productAttributeId?: string;
  value?: string;

  constructor(data?: ICreateProductAttributeValueRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.productAttributeId = _data['productAttributeId'];
      this.value = _data['value'];
    }
  }

  static fromJS(data: any): CreateProductAttributeValueRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductAttributeValueRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['productAttributeId'] = this.productAttributeId;
    data['value'] = this.value;
    return data;
  }
}

export interface ICreateProductAttributeValueRequest {
  productId?: string;
  productAttributeId?: string;
  value?: string;
}

export class CreateProductCommand implements ICreateProductCommand {
  name?: string;
  slug?: string | undefined;
  sku?: string;
  description?: string;
  shortDescription?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  cost?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  categoryId?: string;
  brandId?: string | undefined;
  status?: number;
  isFeatured?: boolean;
  isDigital?: boolean;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  images?: CreateProductImageRequest[] | undefined;
  variants?: CreateProductVariantRequest[] | undefined;
  attributes?: CreateProductAttributeValueRequest[] | undefined;
  tagIds?: string[] | undefined;

  constructor(data?: ICreateProductCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.sku = _data['sku'];
      this.description = _data['description'];
      this.shortDescription = _data['shortDescription'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.cost = _data['cost'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.categoryId = _data['categoryId'];
      this.brandId = _data['brandId'];
      this.status = _data['status'];
      this.isFeatured = _data['isFeatured'];
      this.isDigital = _data['isDigital'];
      this.metaTitle = _data['metaTitle'];
      this.metaDescription = _data['metaDescription'];
      if (Array.isArray(_data['images'])) {
        this.images = [] as any;
        for (let item of _data['images']) this.images!.push(CreateProductImageRequest.fromJS(item));
      }
      if (Array.isArray(_data['variants'])) {
        this.variants = [] as any;
        for (let item of _data['variants'])
          this.variants!.push(CreateProductVariantRequest.fromJS(item));
      }
      if (Array.isArray(_data['attributes'])) {
        this.attributes = [] as any;
        for (let item of _data['attributes'])
          this.attributes!.push(CreateProductAttributeValueRequest.fromJS(item));
      }
      if (Array.isArray(_data['tagIds'])) {
        this.tagIds = [] as any;
        for (let item of _data['tagIds']) this.tagIds!.push(item);
      }
    }
  }

  static fromJS(data: any): CreateProductCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['sku'] = this.sku;
    data['description'] = this.description;
    data['shortDescription'] = this.shortDescription;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['cost'] = this.cost;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['categoryId'] = this.categoryId;
    data['brandId'] = this.brandId;
    data['status'] = this.status;
    data['isFeatured'] = this.isFeatured;
    data['isDigital'] = this.isDigital;
    data['metaTitle'] = this.metaTitle;
    data['metaDescription'] = this.metaDescription;
    if (Array.isArray(this.images)) {
      data['images'] = [];
      for (let item of this.images) data['images'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.variants)) {
      data['variants'] = [];
      for (let item of this.variants)
        data['variants'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.attributes)) {
      data['attributes'] = [];
      for (let item of this.attributes)
        data['attributes'].push(item ? item.toJSON() : (undefined as any));
    }
    if (Array.isArray(this.tagIds)) {
      data['tagIds'] = [];
      for (let item of this.tagIds) data['tagIds'].push(item);
    }
    return data;
  }
}

export interface ICreateProductCommand {
  name?: string;
  slug?: string | undefined;
  sku?: string;
  description?: string;
  shortDescription?: string | undefined;
  price?: number;
  discountPrice?: number | undefined;
  cost?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  categoryId?: string;
  brandId?: string | undefined;
  status?: number;
  isFeatured?: boolean;
  isDigital?: boolean;
  metaTitle?: string | undefined;
  metaDescription?: string | undefined;
  images?: CreateProductImageRequest[] | undefined;
  variants?: CreateProductVariantRequest[] | undefined;
  attributes?: CreateProductAttributeValueRequest[] | undefined;
  tagIds?: string[] | undefined;
}

export class CreateProductImageRequest implements ICreateProductImageRequest {
  productId?: string;
  imageUrl?: string | undefined;
  imageFile?: string | undefined;
  altText?: string | undefined;
  displayOrder?: number;
  isPrimary?: boolean;

  constructor(data?: ICreateProductImageRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.imageUrl = _data['imageUrl'];
      this.imageFile = _data['imageFile'];
      this.altText = _data['altText'];
      this.displayOrder = _data['displayOrder'];
      this.isPrimary = _data['isPrimary'];
    }
  }

  static fromJS(data: any): CreateProductImageRequest {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductImageRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['imageUrl'] = this.imageUrl;
    data['imageFile'] = this.imageFile;
    data['altText'] = this.altText;
    data['displayOrder'] = this.displayOrder;
    data['isPrimary'] = this.isPrimary;
    return data;
  }
}

export interface ICreateProductImageRequest {
  productId?: string;
  imageUrl?: string | undefined;
  imageFile?: string | undefined;
  altText?: string | undefined;
  displayOrder?: number;
  isPrimary?: boolean;
}

export class ResultOfPagedResultOfProductBaseResponse
  implements IResultOfPagedResultOfProductBaseResponse
{
  isSuccess?: boolean;
  data?: PagedResultOfProductBaseResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfProductBaseResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfProductBaseResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfProductBaseResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfProductBaseResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfProductBaseResponse {
  isSuccess?: boolean;
  data?: PagedResultOfProductBaseResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfProductBaseResponse implements IPagedResultOfProductBaseResponse {
  items?: ProductBaseResponse[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfProductBaseResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductBaseResponse.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfProductBaseResponse {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductBaseResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfProductBaseResponse {
  items?: ProductBaseResponse[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class ResultOfProductImageDto implements IResultOfProductImageDto {
  isSuccess?: boolean;
  data?: ProductImageDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? ProductImageDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfProductImageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfProductImageDto {
  isSuccess?: boolean;
  data?: ProductImageDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfPagedResultOfProductImageDto implements IResultOfPagedResultOfProductImageDto {
  isSuccess?: boolean;
  data?: PagedResultOfProductImageDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfProductImageDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfProductImageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfProductImageDto {
  isSuccess?: boolean;
  data?: PagedResultOfProductImageDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfProductImageDto implements IPagedResultOfProductImageDto {
  items?: ProductImageDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfProductImageDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductImageDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfProductImageDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductImageDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfProductImageDto {
  items?: ProductImageDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class ResultOfCreateProductImageResponse implements IResultOfCreateProductImageResponse {
  isSuccess?: boolean;
  data?: CreateProductImageResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCreateProductImageResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? CreateProductImageResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCreateProductImageResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCreateProductImageResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCreateProductImageResponse {
  isSuccess?: boolean;
  data?: CreateProductImageResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CreateProductImageResponse
  extends ProductImageDto
  implements ICreateProductImageResponse
{
  constructor(data?: ICreateProductImageResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): CreateProductImageResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductImageResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateProductImageResponse extends IProductImageDto {}

export class CreateProductImageCommand implements ICreateProductImageCommand {
  productId?: string;
  imageUrl?: string;
  altText?: string | undefined;
  isPrimary?: boolean;
  displayOrder?: number;

  constructor(data?: ICreateProductImageCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.imageUrl = _data['imageUrl'];
      this.altText = _data['altText'];
      this.isPrimary = _data['isPrimary'];
      this.displayOrder = _data['displayOrder'];
    }
  }

  static fromJS(data: any): CreateProductImageCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductImageCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['imageUrl'] = this.imageUrl;
    data['altText'] = this.altText;
    data['isPrimary'] = this.isPrimary;
    data['displayOrder'] = this.displayOrder;
    return data;
  }
}

export interface ICreateProductImageCommand {
  productId?: string;
  imageUrl?: string;
  altText?: string | undefined;
  isPrimary?: boolean;
  displayOrder?: number;
}

export class ResultOfUpdateProductImageResponse implements IResultOfUpdateProductImageResponse {
  isSuccess?: boolean;
  data?: UpdateProductImageResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfUpdateProductImageResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? UpdateProductImageResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfUpdateProductImageResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfUpdateProductImageResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfUpdateProductImageResponse {
  isSuccess?: boolean;
  data?: UpdateProductImageResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class UpdateProductImageResponse
  extends ProductImageDto
  implements IUpdateProductImageResponse
{
  constructor(data?: IUpdateProductImageResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): UpdateProductImageResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductImageResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUpdateProductImageResponse extends IProductImageDto {}

export class UpdateProductImageCommand implements IUpdateProductImageCommand {
  imageId?: string;
  productId?: string;
  imageUrl?: string;
  altText?: string | undefined;
  isPrimary?: boolean;
  displayOrder?: number;

  constructor(data?: IUpdateProductImageCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.imageId = _data['imageId'];
      this.productId = _data['productId'];
      this.imageUrl = _data['imageUrl'];
      this.altText = _data['altText'];
      this.isPrimary = _data['isPrimary'];
      this.displayOrder = _data['displayOrder'];
    }
  }

  static fromJS(data: any): UpdateProductImageCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductImageCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['imageId'] = this.imageId;
    data['productId'] = this.productId;
    data['imageUrl'] = this.imageUrl;
    data['altText'] = this.altText;
    data['isPrimary'] = this.isPrimary;
    data['displayOrder'] = this.displayOrder;
    return data;
  }
}

export interface IUpdateProductImageCommand {
  imageId?: string;
  productId?: string;
  imageUrl?: string;
  altText?: string | undefined;
  isPrimary?: boolean;
  displayOrder?: number;
}

export class ResultOfProductQuestionDto implements IResultOfProductQuestionDto {
  isSuccess?: boolean;
  data?: ProductQuestionDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfProductQuestionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? ProductQuestionDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfProductQuestionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfProductQuestionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfProductQuestionDto {
  isSuccess?: boolean;
  data?: ProductQuestionDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ProductQuestionDto implements IProductQuestionDto {
  productQuestionId?: string;
  productId?: string;
  productName?: string;
  userId?: string;
  userName?: string;
  question?: string;
  answer?: string | undefined;
  answeredAt?: Date | undefined;
  answeredBy?: string | undefined;
  answeredByName?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;

  constructor(data?: IProductQuestionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productQuestionId = _data['productQuestionId'];
      this.productId = _data['productId'];
      this.productName = _data['productName'];
      this.userId = _data['userId'];
      this.userName = _data['userName'];
      this.question = _data['question'];
      this.answer = _data['answer'];
      this.answeredAt = _data['answeredAt']
        ? new Date(_data['answeredAt'].toString())
        : (undefined as any);
      this.answeredBy = _data['answeredBy'];
      this.answeredByName = _data['answeredByName'];
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : (undefined as any);
      this.updatedAt = _data['updatedAt']
        ? new Date(_data['updatedAt'].toString())
        : (undefined as any);
    }
  }

  static fromJS(data: any): ProductQuestionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProductQuestionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productQuestionId'] = this.productQuestionId;
    data['productId'] = this.productId;
    data['productName'] = this.productName;
    data['userId'] = this.userId;
    data['userName'] = this.userName;
    data['question'] = this.question;
    data['answer'] = this.answer;
    data['answeredAt'] = this.answeredAt ? this.answeredAt.toISOString() : (undefined as any);
    data['answeredBy'] = this.answeredBy;
    data['answeredByName'] = this.answeredByName;
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : (undefined as any);
    data['updatedAt'] = this.updatedAt ? this.updatedAt.toISOString() : (undefined as any);
    return data;
  }
}

export interface IProductQuestionDto {
  productQuestionId?: string;
  productId?: string;
  productName?: string;
  userId?: string;
  userName?: string;
  question?: string;
  answer?: string | undefined;
  answeredAt?: Date | undefined;
  answeredBy?: string | undefined;
  answeredByName?: string | undefined;
  status?: number;
  createdAt?: Date;
  updatedAt?: Date | undefined;
}

export class ResultOfPagedResultOfProductQuestionDto
  implements IResultOfPagedResultOfProductQuestionDto
{
  isSuccess?: boolean;
  data?: PagedResultOfProductQuestionDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfProductQuestionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfProductQuestionDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfProductQuestionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfProductQuestionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfProductQuestionDto {
  isSuccess?: boolean;
  data?: PagedResultOfProductQuestionDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfProductQuestionDto implements IPagedResultOfProductQuestionDto {
  items?: ProductQuestionDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfProductQuestionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductQuestionDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfProductQuestionDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductQuestionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfProductQuestionDto {
  items?: ProductQuestionDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export class ResultOfCreateProductQuestionResponse
  implements IResultOfCreateProductQuestionResponse
{
  isSuccess?: boolean;
  data?: CreateProductQuestionResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCreateProductQuestionResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? CreateProductQuestionResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCreateProductQuestionResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCreateProductQuestionResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCreateProductQuestionResponse {
  isSuccess?: boolean;
  data?: CreateProductQuestionResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CreateProductQuestionResponse
  extends ProductQuestionDto
  implements ICreateProductQuestionResponse
{
  constructor(data?: ICreateProductQuestionResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): CreateProductQuestionResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductQuestionResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateProductQuestionResponse extends IProductQuestionDto {}

export class CreateProductQuestionCommand implements ICreateProductQuestionCommand {
  productId?: string;
  userId?: string;
  question?: string;
  status?: number;

  constructor(data?: ICreateProductQuestionCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.userId = _data['userId'];
      this.question = _data['question'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): CreateProductQuestionCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductQuestionCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['userId'] = this.userId;
    data['question'] = this.question;
    data['status'] = this.status;
    return data;
  }
}

export interface ICreateProductQuestionCommand {
  productId?: string;
  userId?: string;
  question?: string;
  status?: number;
}

export class ResultOfUpdateProductQuestionResponse
  implements IResultOfUpdateProductQuestionResponse
{
  isSuccess?: boolean;
  data?: UpdateProductQuestionResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfUpdateProductQuestionResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? UpdateProductQuestionResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfUpdateProductQuestionResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfUpdateProductQuestionResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfUpdateProductQuestionResponse {
  isSuccess?: boolean;
  data?: UpdateProductQuestionResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class UpdateProductQuestionResponse
  extends ProductQuestionDto
  implements IUpdateProductQuestionResponse
{
  constructor(data?: IUpdateProductQuestionResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): UpdateProductQuestionResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductQuestionResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUpdateProductQuestionResponse extends IProductQuestionDto {}

export class UpdateProductQuestionCommand implements IUpdateProductQuestionCommand {
  questionId?: string;
  question?: string;
  status?: number;

  constructor(data?: IUpdateProductQuestionCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.question = _data['question'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): UpdateProductQuestionCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductQuestionCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['question'] = this.question;
    data['status'] = this.status;
    return data;
  }
}

export interface IUpdateProductQuestionCommand {
  questionId?: string;
  question?: string;
  status?: number;
}

export class AnswerProductQuestionCommand implements IAnswerProductQuestionCommand {
  questionId?: string;
  answer?: string;
  answeredBy?: string;

  constructor(data?: IAnswerProductQuestionCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.questionId = _data['questionId'];
      this.answer = _data['answer'];
      this.answeredBy = _data['answeredBy'];
    }
  }

  static fromJS(data: any): AnswerProductQuestionCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AnswerProductQuestionCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['questionId'] = this.questionId;
    data['answer'] = this.answer;
    data['answeredBy'] = this.answeredBy;
    return data;
  }
}

export interface IAnswerProductQuestionCommand {
  questionId?: string;
  answer?: string;
  answeredBy?: string;
}

export class AssignTagToProductCommand implements IAssignTagToProductCommand {
  productId?: string;
  tagId?: string;

  constructor(data?: IAssignTagToProductCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.tagId = _data['tagId'];
    }
  }

  static fromJS(data: any): AssignTagToProductCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AssignTagToProductCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['tagId'] = this.tagId;
    return data;
  }
}

export interface IAssignTagToProductCommand {
  productId?: string;
  tagId?: string;
}

export class CreateProductTagCommand implements ICreateProductTagCommand {
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;

  constructor(data?: ICreateProductTagCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): CreateProductTagCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductTagCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    return data;
  }
}

export interface ICreateProductTagCommand {
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
}

export class UpdateProductTagCommand implements IUpdateProductTagCommand {
  tagId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;

  constructor(data?: IUpdateProductTagCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tagId = _data['tagId'];
      this.name = _data['name'];
      this.slug = _data['slug'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): UpdateProductTagCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductTagCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tagId'] = this.tagId;
    data['name'] = this.name;
    data['slug'] = this.slug;
    data['description'] = this.description;
    return data;
  }
}

export interface IUpdateProductTagCommand {
  tagId?: string;
  name?: string;
  slug?: string | undefined;
  description?: string | undefined;
}

export class ResultOfCreateProductVariantResponse implements IResultOfCreateProductVariantResponse {
  isSuccess?: boolean;
  data?: CreateProductVariantResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfCreateProductVariantResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? CreateProductVariantResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfCreateProductVariantResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfCreateProductVariantResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfCreateProductVariantResponse {
  isSuccess?: boolean;
  data?: CreateProductVariantResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class CreateProductVariantResponse
  extends ProductVariantDto
  implements ICreateProductVariantResponse
{
  constructor(data?: ICreateProductVariantResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): CreateProductVariantResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductVariantResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface ICreateProductVariantResponse extends IProductVariantDto {}

export class CreateProductVariantCommand implements ICreateProductVariantCommand {
  productId?: string;
  sku?: string;
  name?: string;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;

  constructor(data?: ICreateProductVariantCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.productId = _data['productId'];
      this.sku = _data['sku'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): CreateProductVariantCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateProductVariantCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['productId'] = this.productId;
    data['sku'] = this.sku;
    data['name'] = this.name;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['status'] = this.status;
    return data;
  }
}

export interface ICreateProductVariantCommand {
  productId?: string;
  sku?: string;
  name?: string;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;
}

export class ResultOfUpdateProductVariantResponse implements IResultOfUpdateProductVariantResponse {
  isSuccess?: boolean;
  data?: UpdateProductVariantResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfUpdateProductVariantResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? UpdateProductVariantResponse.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfUpdateProductVariantResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfUpdateProductVariantResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfUpdateProductVariantResponse {
  isSuccess?: boolean;
  data?: UpdateProductVariantResponse | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class UpdateProductVariantResponse
  extends ProductVariantDto
  implements IUpdateProductVariantResponse
{
  constructor(data?: IUpdateProductVariantResponse) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
  }

  static override fromJS(data: any): UpdateProductVariantResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductVariantResponse();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    super.toJSON(data);
    return data;
  }
}

export interface IUpdateProductVariantResponse extends IProductVariantDto {}

export class UpdateProductVariantCommand implements IUpdateProductVariantCommand {
  variantId?: string;
  sku?: string;
  name?: string;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;

  constructor(data?: IUpdateProductVariantCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.variantId = _data['variantId'];
      this.sku = _data['sku'];
      this.name = _data['name'];
      this.price = _data['price'];
      this.discountPrice = _data['discountPrice'];
      this.stockQuantity = _data['stockQuantity'];
      this.minStockLevel = _data['minStockLevel'];
      this.weight = _data['weight'];
      this.dimensions = _data['dimensions'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): UpdateProductVariantCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductVariantCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['variantId'] = this.variantId;
    data['sku'] = this.sku;
    data['name'] = this.name;
    data['price'] = this.price;
    data['discountPrice'] = this.discountPrice;
    data['stockQuantity'] = this.stockQuantity;
    data['minStockLevel'] = this.minStockLevel;
    data['weight'] = this.weight;
    data['dimensions'] = this.dimensions;
    data['status'] = this.status;
    return data;
  }
}

export interface IUpdateProductVariantCommand {
  variantId?: string;
  sku?: string;
  name?: string;
  price?: number;
  discountPrice?: number | undefined;
  stockQuantity?: number;
  minStockLevel?: number;
  weight?: number | undefined;
  dimensions?: string | undefined;
  status?: number;
}

export class UpdateProductVariantStockCommand implements IUpdateProductVariantStockCommand {
  variantId?: string;
  quantity?: number;

  constructor(data?: IUpdateProductVariantStockCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.variantId = _data['variantId'];
      this.quantity = _data['quantity'];
    }
  }

  static fromJS(data: any): UpdateProductVariantStockCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateProductVariantStockCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['variantId'] = this.variantId;
    data['quantity'] = this.quantity;
    return data;
  }
}

export interface IUpdateProductVariantStockCommand {
  variantId?: string;
  quantity?: number;
}

export class ResultOfProductVariantDto implements IResultOfProductVariantDto {
  isSuccess?: boolean;
  data?: ProductVariantDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfProductVariantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data'] ? ProductVariantDto.fromJS(_data['data']) : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfProductVariantDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfProductVariantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfProductVariantDto {
  isSuccess?: boolean;
  data?: ProductVariantDto | undefined;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class ResultOfPagedResultOfProductVariantDto
  implements IResultOfPagedResultOfProductVariantDto
{
  isSuccess?: boolean;
  data?: PagedResultOfProductVariantDto;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];

  constructor(data?: IResultOfPagedResultOfProductVariantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSuccess = _data['isSuccess'];
      this.data = _data['data']
        ? PagedResultOfProductVariantDto.fromJS(_data['data'])
        : (undefined as any);
      this.errorMessage = _data['errorMessage'];
      this.errorCode = _data['errorCode'];
      if (Array.isArray(_data['errors'])) {
        this.errors = [] as any;
        for (let item of _data['errors']) this.errors!.push(item);
      }
    }
  }

  static fromJS(data: any): ResultOfPagedResultOfProductVariantDto {
    data = typeof data === 'object' ? data : {};
    let result = new ResultOfPagedResultOfProductVariantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSuccess'] = this.isSuccess;
    data['data'] = this.data ? this.data.toJSON() : (undefined as any);
    data['errorMessage'] = this.errorMessage;
    data['errorCode'] = this.errorCode;
    if (Array.isArray(this.errors)) {
      data['errors'] = [];
      for (let item of this.errors) data['errors'].push(item);
    }
    return data;
  }
}

export interface IResultOfPagedResultOfProductVariantDto {
  isSuccess?: boolean;
  data?: PagedResultOfProductVariantDto;
  errorMessage?: string | undefined;
  errorCode?: string | undefined;
  errors?: string[];
}

export class PagedResultOfProductVariantDto implements IPagedResultOfProductVariantDto {
  items?: ProductVariantDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;

  constructor(data?: IPagedResultOfProductVariantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (this as any)[property] = (data as any)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProductVariantDto.fromJS(item));
      }
      this.totalCount = _data['totalCount'];
      this.page = _data['page'];
      this.pageSize = _data['pageSize'];
      this.totalPages = _data['totalPages'];
      this.hasPreviousPage = _data['hasPreviousPage'];
      this.hasNextPage = _data['hasNextPage'];
    }
  }

  static fromJS(data: any): PagedResultOfProductVariantDto {
    data = typeof data === 'object' ? data : {};
    let result = new PagedResultOfProductVariantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item ? item.toJSON() : (undefined as any));
    }
    data['totalCount'] = this.totalCount;
    data['page'] = this.page;
    data['pageSize'] = this.pageSize;
    data['totalPages'] = this.totalPages;
    data['hasPreviousPage'] = this.hasPreviousPage;
    data['hasNextPage'] = this.hasNextPage;
    return data;
  }
}

export interface IPagedResultOfProductVariantDto {
  items?: ProductVariantDto[];
  totalCount?: number;
  page?: number;
  pageSize?: number;
  totalPages?: number;
  hasPreviousPage?: boolean;
  hasNextPage?: boolean;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
