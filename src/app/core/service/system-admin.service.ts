//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AbandonedCartClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getUnnotifiedCarts(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfAbandonedCartDto> {
        let url_ = this.baseUrl + "/api/AbandonedCart/unnotified?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnnotifiedCarts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnnotifiedCarts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAbandonedCartDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAbandonedCartDto>;
        }));
    }

    protected processGetUnnotifiedCarts(response: HttpResponseBase): Observable<ResultOfPagedResultOfAbandonedCartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAbandonedCartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByDateRange(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined, fromDate: Date | undefined, toDate: Date | undefined): Observable<ResultOfPagedResultOfAbandonedCartDto> {
        let url_ = this.baseUrl + "/api/AbandonedCart/date-range?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        if (fromDate === null)
            throw new globalThis.Error("The parameter 'fromDate' cannot be null.");
        else if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toISOString() : "") + "&";
        if (toDate === null)
            throw new globalThis.Error("The parameter 'toDate' cannot be null.");
        else if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAbandonedCartDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAbandonedCartDto>;
        }));
    }

    protected processGetByDateRange(response: HttpResponseBase): Observable<ResultOfPagedResultOfAbandonedCartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAbandonedCartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    markAsNotified(abandonedCartId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/AbandonedCart/notified/{abandonedCartId}";
        if (abandonedCartId === undefined || abandonedCartId === null)
            throw new globalThis.Error("The parameter 'abandonedCartId' must be defined.");
        url_ = url_.replace("{abandonedCartId}", encodeURIComponent("" + abandonedCartId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAsNotified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAsNotified(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processMarkAsNotified(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    markBatchAsNotified(request: MarkCartsNotifiedRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/AbandonedCart/notified/batch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkBatchAsNotified(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkBatchAsNotified(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processMarkBatchAsNotified(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuditLogClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getPaged(request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/paged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: string): Observable<ResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfAuditLog>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/AuditLog/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(auditLog: AuditLog): Observable<ResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(auditLog);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfAuditLog>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByUser(userId: string, request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/by-user/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        }));
    }

    protected processGetByUser(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByEntity(entity: string | undefined, entityId: string | undefined, request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/by-entity?";
        if (entity === null)
            throw new globalThis.Error("The parameter 'entity' cannot be null.");
        else if (entity !== undefined)
            url_ += "entity=" + encodeURIComponent("" + entity) + "&";
        if (entityId === null)
            throw new globalThis.Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        }));
    }

    protected processGetByEntity(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByAction(action: string | undefined, request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/by-action?";
        if (action === null)
            throw new globalThis.Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        }));
    }

    protected processGetByAction(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByDateRange(from: Date | undefined, to: Date | undefined, request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/by-date-range?";
        if (from === null)
            throw new globalThis.Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new globalThis.Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        }));
    }

    protected processGetByDateRange(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRecent(count: number | undefined, request: PagedRequest): Observable<ResultOfPagedResultOfAuditLog> {
        let url_ = this.baseUrl + "/api/AuditLog/recent?";
        if (count === null)
            throw new globalThis.Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfAuditLog>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfAuditLog>;
        }));
    }

    protected processGetRecent(response: HttpResponseBase): Observable<ResultOfPagedResultOfAuditLog> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfAuditLog.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLogCountByUser(userId: string): Observable<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/AuditLog/count/by-user/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogCountByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogCountByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        }));
    }

    protected processGetLogCountByUser(response: HttpResponseBase): Observable<ResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLogCountByAction(action: string | undefined): Observable<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/AuditLog/count/by-action?";
        if (action === null)
            throw new globalThis.Error("The parameter 'action' cannot be null.");
        else if (action !== undefined)
            url_ += "action=" + encodeURIComponent("" + action) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogCountByAction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogCountByAction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        }));
    }

    protected processGetLogCountByAction(response: HttpResponseBase): Observable<ResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActionStatistics(from: Date | undefined, to: Date | undefined): Observable<ResultOfDictionaryOfStringAndInteger> {
        let url_ = this.baseUrl + "/api/AuditLog/stats?";
        if (from === null)
            throw new globalThis.Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new globalThis.Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfDictionaryOfStringAndInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfDictionaryOfStringAndInteger>;
        }));
    }

    protected processGetActionStatistics(response: HttpResponseBase): Observable<ResultOfDictionaryOfStringAndInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfDictionaryOfStringAndInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    registerAccount(request: RegisterCommand): Observable<ResultOfRegisterResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfRegisterResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfRegisterResponse>;
        }));
    }

    protected processRegisterAccount(response: HttpResponseBase): Observable<ResultOfRegisterResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfRegisterResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(request: LoginCommand): Observable<ResultOfLoginResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfLoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfLoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResultOfLoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(request: ForgotPasswordCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(request: ResetPasswordCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logout(request: LogoutCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(request: RefreshTokenCommand): Observable<ResultOfRefreshTokenResponse> {
        let url_ = this.baseUrl + "/api/Auth/refresh-token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfRefreshTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfRefreshTokenResponse>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ResultOfRefreshTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfRefreshTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BrandClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getBrandsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandsPaging(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCountByBrand(brandId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/product-count/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCountByBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCountByBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductCountByBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrandById(brandId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBrand(brandId: string, request: UpdateBrandCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteBrand(brandId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrandByName(name: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrandBySlug(slug: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/slug/{slug}";
        if (slug === undefined || slug === null)
            throw new globalThis.Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandBySlug(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBrand(request: CreateBrandCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBrandStatus(brandId: string, request: UpdateBrandStatusCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/status/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrandStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrandStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateBrandStatus(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CartClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getShoppingCart(userId: string | null): Observable<ResultOfShoppingCartDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShoppingCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShoppingCartDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShoppingCartDto>;
        }));
    }

    protected processGetShoppingCart(response: HttpResponseBase): Observable<ResultOfShoppingCartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShoppingCartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clearShoppingCart(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearShoppingCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processClearShoppingCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCartSummary(userId: string): Observable<ResultOfCartSummaryDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/summary";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCartSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCartSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCartSummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCartSummaryDto>;
        }));
    }

    protected processGetCartSummary(response: HttpResponseBase): Observable<ResultOfCartSummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCartSummaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addItemToCart(request: AddToCartRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItemToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItemToCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAddItemToCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCartItemQuantity(itemId: string, request: UpdateQuantityRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/items/{itemId}/quantity";
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCartItemQuantity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCartItemQuantity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateCartItemQuantity(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItemFromCart(itemId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemFromCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemFromCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItemFromCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWishlist(userId: string): Observable<ResultOfWishlistDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfWishlistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfWishlistDto>;
        }));
    }

    protected processGetWishlist(response: HttpResponseBase): Observable<ResultOfWishlistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfWishlistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWishlistItems(userId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfWishlistItemDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWishlistItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWishlistItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfWishlistItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfWishlistItemDto>;
        }));
    }

    protected processGetWishlistItems(response: HttpResponseBase): Observable<ResultOfPagedResultOfWishlistItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfWishlistItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addItemToWishlist(userId: string, request: AddToWishlistRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItemToWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItemToWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAddItemToWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItemFromWishlist(userId: string, itemId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items/{itemId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemFromWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemFromWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItemFromWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getCategoriesPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoriesPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoriesPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfCategoryDto>;
        }));
    }

    protected processGetCategoriesPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCountByCategory(categoryId: string): Observable<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/Category/product-count/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCountByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCountByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        }));
    }

    protected processGetProductCountByCategory(response: HttpResponseBase): Observable<ResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubCategories(categoryId: string): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/sub-categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetSubCategories(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryPath(categoryId: string): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/category-path/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryPath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetCategoryPath(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryTree(): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/category-tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetCategoryTree(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRootCategories(): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/root-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRootCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRootCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetRootCategories(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveCategories(): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/active-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetActiveCategories(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryById(categoryId: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCategory(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryByName(name: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processGetCategoryByName(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryBySlug(slug: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/slug/{slug}";
        if (slug === undefined || slug === null)
            throw new globalThis.Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processGetCategoryBySlug(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCategory(request: CreateCategoryCommand): Observable<ResultOfCreateCategoryResponse> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateCategoryResponse>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<ResultOfCreateCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCategoryWithFile(name: string | undefined, slug: string | null | undefined, description: string | null | undefined, image: FileParameter | null | undefined, metaTitle: string | null | undefined, metaDescription: string | null | undefined, parentCategoryId: string | null | undefined, status: number | undefined, displayOrder: number | undefined): Observable<ResultOfCreateCategoryResponse> {
        let url_ = this.baseUrl + "/api/Category/create-with-file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (slug !== null && slug !== undefined)
            content_.append("Slug", slug.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
        if (metaTitle !== null && metaTitle !== undefined)
            content_.append("MetaTitle", metaTitle.toString());
        if (metaDescription !== null && metaDescription !== undefined)
            content_.append("MetaDescription", metaDescription.toString());
        if (parentCategoryId !== null && parentCategoryId !== undefined)
            content_.append("ParentCategoryId", parentCategoryId.toString());
        if (status === null || status === undefined)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (displayOrder === null || displayOrder === undefined)
            throw new globalThis.Error("The parameter 'displayOrder' cannot be null.");
        else
            content_.append("DisplayOrder", displayOrder.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategoryWithFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategoryWithFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateCategoryResponse>;
        }));
    }

    protected processCreateCategoryWithFile(response: HttpResponseBase): Observable<ResultOfCreateCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategory(request: UpdateCategoryCommand): Observable<ResultOfUpdateCategoryResponse> {
        let url_ = this.baseUrl + "/api/Category/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateCategoryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateCategoryResponse>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<ResultOfUpdateCategoryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateCategoryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategoryWithFile(categoryId: string | undefined, name: string | undefined, slug: string | null | undefined, description: string | null | undefined, image: FileParameter | null | undefined, metaTitle: string | null | undefined, metaDescription: string | null | undefined, parentCategoryId: string | null | undefined, status: number | undefined, displayOrder: number | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/update-with-file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (categoryId === null || categoryId === undefined)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else
            content_.append("CategoryId", categoryId.toString());
        if (name === null || name === undefined)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (slug !== null && slug !== undefined)
            content_.append("Slug", slug.toString());
        if (description !== null && description !== undefined)
            content_.append("Description", description.toString());
        if (image !== null && image !== undefined)
            content_.append("Image", image.data, image.fileName ? image.fileName : "Image");
        if (metaTitle !== null && metaTitle !== undefined)
            content_.append("MetaTitle", metaTitle.toString());
        if (metaDescription !== null && metaDescription !== undefined)
            content_.append("MetaDescription", metaDescription.toString());
        if (parentCategoryId !== null && parentCategoryId !== undefined)
            content_.append("ParentCategoryId", parentCategoryId.toString());
        if (status === null || status === undefined)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (displayOrder === null || displayOrder === undefined)
            throw new globalThis.Error("The parameter 'displayOrder' cannot be null.");
        else
            content_.append("DisplayOrder", displayOrder.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryWithFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryWithFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateCategoryWithFile(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategoryStatus(categoryId: string, request: UpdateCategoryStatusCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/status/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateCategoryStatus(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryExistsById(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/exists/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryExistsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryExistsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryExistsById(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryExistsByName(name: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/exists-by-name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryExistsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryExistsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryExistsByName(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryHasSubCategories(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/has-sub-categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryHasSubCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryHasSubCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryHasSubCategories(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryInUse(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/in-use/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryInUse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryInUse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryInUse(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIsRootCategory(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/is-root/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIsRootCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIsRootCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckIsRootCategory(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileUploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    uploadImage(file: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FileUpload/upload-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadMultipleImages(files: FileParameter[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FileUpload/upload-multiple-images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadMultipleImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadMultipleImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadMultipleImages(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(blobName: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FileUpload/delete-image?";
        if (blobName === null)
            throw new globalThis.Error("The parameter 'blobName' cannot be null.");
        else if (blobName !== undefined)
            url_ += "blobName=" + encodeURIComponent("" + blobName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ImageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    uploadImage(file: FileParameter | null | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Image/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfString>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getImageUrl(blobName: string, policyName: string | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Image/{blobName}/url?";
        if (blobName === undefined || blobName === null)
            throw new globalThis.Error("The parameter 'blobName' must be defined.");
        url_ = url_.replace("{blobName}", encodeURIComponent("" + blobName));
        if (policyName === null)
            throw new globalThis.Error("The parameter 'policyName' cannot be null.");
        else if (policyName !== undefined)
            url_ += "policyName=" + encodeURIComponent("" + policyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfString>;
        }));
    }

    protected processGetImageUrl(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getContainerUrl(policyName: string | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Image/container/url?";
        if (policyName === null)
            throw new globalThis.Error("The parameter 'policyName' cannot be null.");
        else if (policyName !== undefined)
            url_ += "policyName=" + encodeURIComponent("" + policyName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContainerUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContainerUrl(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfString>;
        }));
    }

    protected processGetContainerUrl(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateImage(blobName: string, file: FileParameter | null | undefined): Observable<ResultOfString> {
        let url_ = this.baseUrl + "/api/Image/{blobName}";
        if (blobName === undefined || blobName === null)
            throw new globalThis.Error("The parameter 'blobName' must be defined.");
        url_ = url_.replace("{blobName}", encodeURIComponent("" + blobName));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfString>;
        }));
    }

    protected processUpdateImage(response: HttpResponseBase): Observable<ResultOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(blobName: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Image/{blobName}";
        if (blobName === undefined || blobName === null)
            throw new globalThis.Error("The parameter 'blobName' must be defined.");
        url_ = url_.replace("{blobName}", encodeURIComponent("" + blobName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    imageExists(blobName: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Image/{blobName}/exists";
        if (blobName === undefined || blobName === null)
            throw new globalThis.Error("The parameter 'blobName' must be defined.");
        url_ = url_.replace("{blobName}", encodeURIComponent("" + blobName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImageExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImageExists(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processImageExists(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getImageMetadata(blobName: string): Observable<ResultOfObject> {
        let url_ = this.baseUrl + "/api/Image/{blobName}/metadata";
        if (blobName === undefined || blobName === null)
            throw new globalThis.Error("The parameter 'blobName' must be defined.");
        url_ = url_.replace("{blobName}", encodeURIComponent("" + blobName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageMetadata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageMetadata(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfObject>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfObject>;
        }));
    }

    protected processGetImageMetadata(response: HttpResponseBase): Observable<ResultOfObject> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfObject.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    listImages(prefix: string | undefined): Observable<ResultOfListOfString> {
        let url_ = this.baseUrl + "/api/Image/list?";
        if (prefix === null)
            throw new globalThis.Error("The parameter 'prefix' cannot be null.");
        else if (prefix !== undefined)
            url_ += "prefix=" + encodeURIComponent("" + prefix) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfString>;
        }));
    }

    protected processListImages(response: HttpResponseBase): Observable<ResultOfListOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadMultipleImages(files: FileParameter[] | null | undefined): Observable<ResultOfListOfString> {
        let url_ = this.baseUrl + "/api/Image/upload-multiple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadMultipleImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadMultipleImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfString>;
        }));
    }

    protected processUploadMultipleImages(response: HttpResponseBase): Observable<ResultOfListOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    create(request: CreateOrderRequest): Observable<ResultOfOrderDto> {
        let url_ = this.baseUrl + "/api/Order/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getOrdersPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderDto> {
        let url_ = this.baseUrl + "/api/Order/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrdersPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrdersPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderDto>;
        }));
    }

    protected processGetOrdersPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(orderId: string): Observable<ResultOfOrderDetailDto> {
        let url_ = this.baseUrl + "/api/Order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderDetailDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfOrderDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(orderId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByUserId(userId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderDto> {
        let url_ = this.baseUrl + "/api/Order/user/{userId}?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderDto>;
        }));
    }

    protected processGetByUserId(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(orderId: string, request: UpdateOrderRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Order/update/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateStatus(orderId: string, request: UpdateOrderStatusRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Order/update-status/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderItemClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getOrderItemsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderItemDto> {
        let url_ = this.baseUrl + "/api/OrderItem/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderItemsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderItemsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderItemDto>;
        }));
    }

    protected processGetOrderItemsPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(orderItemId: string): Observable<ResultOfOrderItemDto> {
        let url_ = this.baseUrl + "/api/OrderItem/{orderItemId}";
        if (orderItemId === undefined || orderItemId === null)
            throw new globalThis.Error("The parameter 'orderItemId' must be defined.");
        url_ = url_.replace("{orderItemId}", encodeURIComponent("" + orderItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderItemDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfOrderItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(orderItemId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderItem/{orderItemId}";
        if (orderItemId === undefined || orderItemId === null)
            throw new globalThis.Error("The parameter 'orderItemId' must be defined.");
        url_ = url_.replace("{orderItemId}", encodeURIComponent("" + orderItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByOrderId(orderId: string): Observable<ResultOfListOfOrderItemDto> {
        let url_ = this.baseUrl + "/api/OrderItem/order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfOrderItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfOrderItemDto>;
        }));
    }

    protected processGetByOrderId(response: HttpResponseBase): Observable<ResultOfListOfOrderItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfOrderItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateOrderItemRequest): Observable<ResultOfOrderItemDto> {
        let url_ = this.baseUrl + "/api/OrderItem/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderItemDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfOrderItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(orderItemId: string, request: UpdateOrderItemRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderItem/update/{orderItemId}";
        if (orderItemId === undefined || orderItemId === null)
            throw new globalThis.Error("The parameter 'orderItemId' must be defined.");
        url_ = url_.replace("{orderItemId}", encodeURIComponent("" + orderItemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderPaymentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getOrderPaymentsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderPaymentDto> {
        let url_ = this.baseUrl + "/api/OrderPayment/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderPaymentsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderPaymentsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderPaymentDto>;
        }));
    }

    protected processGetOrderPaymentsPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(paymentId: string): Observable<ResultOfOrderPaymentDto> {
        let url_ = this.baseUrl + "/api/OrderPayment/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new globalThis.Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderPaymentDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfOrderPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(paymentId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderPayment/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new globalThis.Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByOrderId(orderId: string): Observable<ResultOfListOfOrderPaymentDto> {
        let url_ = this.baseUrl + "/api/OrderPayment/order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfOrderPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfOrderPaymentDto>;
        }));
    }

    protected processGetByOrderId(response: HttpResponseBase): Observable<ResultOfListOfOrderPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfOrderPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateOrderPaymentRequest): Observable<ResultOfOrderPaymentDto> {
        let url_ = this.baseUrl + "/api/OrderPayment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderPaymentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfOrderPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(paymentId: string, request: UpdateOrderPaymentRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderPayment/update/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new globalThis.Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateStatus(paymentId: string, request: UpdatePaymentStatusRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderPayment/update-status/{paymentId}";
        if (paymentId === undefined || paymentId === null)
            throw new globalThis.Error("The parameter 'paymentId' must be defined.");
        url_ = url_.replace("{paymentId}", encodeURIComponent("" + paymentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderRefundClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getOrderRefundsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderRefundDto> {
        let url_ = this.baseUrl + "/api/OrderRefund/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderRefundsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderRefundsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderRefundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderRefundDto>;
        }));
    }

    protected processGetOrderRefundsPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderRefundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderRefundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(refundId: string): Observable<ResultOfOrderRefundDto> {
        let url_ = this.baseUrl + "/api/OrderRefund/{refundId}";
        if (refundId === undefined || refundId === null)
            throw new globalThis.Error("The parameter 'refundId' must be defined.");
        url_ = url_.replace("{refundId}", encodeURIComponent("" + refundId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderRefundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderRefundDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfOrderRefundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderRefundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(refundId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderRefund/{refundId}";
        if (refundId === undefined || refundId === null)
            throw new globalThis.Error("The parameter 'refundId' must be defined.");
        url_ = url_.replace("{refundId}", encodeURIComponent("" + refundId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByOrderId(orderId: string): Observable<ResultOfListOfOrderRefundDto> {
        let url_ = this.baseUrl + "/api/OrderRefund/order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfOrderRefundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfOrderRefundDto>;
        }));
    }

    protected processGetByOrderId(response: HttpResponseBase): Observable<ResultOfListOfOrderRefundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfOrderRefundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateOrderRefundRequest): Observable<ResultOfOrderRefundDto> {
        let url_ = this.baseUrl + "/api/OrderRefund/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderRefundDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderRefundDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfOrderRefundDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderRefundDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(refundId: string, request: UpdateOrderRefundRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderRefund/update/{refundId}";
        if (refundId === undefined || refundId === null)
            throw new globalThis.Error("The parameter 'refundId' must be defined.");
        url_ = url_.replace("{refundId}", encodeURIComponent("" + refundId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    processRefund(refundId: string, request: ProcessRefundRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderRefund/process/{refundId}";
        if (refundId === undefined || refundId === null)
            throw new globalThis.Error("The parameter 'refundId' must be defined.");
        url_ = url_.replace("{refundId}", encodeURIComponent("" + refundId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProcessRefund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProcessRefund(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processProcessRefund(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderShipmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getOrderShipmentsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderShipmentDto> {
        let url_ = this.baseUrl + "/api/OrderShipment/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderShipmentsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderShipmentsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderShipmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderShipmentDto>;
        }));
    }

    protected processGetOrderShipmentsPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderShipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderShipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(shipmentId: string): Observable<ResultOfOrderShipmentDto> {
        let url_ = this.baseUrl + "/api/OrderShipment/{shipmentId}";
        if (shipmentId === undefined || shipmentId === null)
            throw new globalThis.Error("The parameter 'shipmentId' must be defined.");
        url_ = url_.replace("{shipmentId}", encodeURIComponent("" + shipmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderShipmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderShipmentDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfOrderShipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderShipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(shipmentId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderShipment/{shipmentId}";
        if (shipmentId === undefined || shipmentId === null)
            throw new globalThis.Error("The parameter 'shipmentId' must be defined.");
        url_ = url_.replace("{shipmentId}", encodeURIComponent("" + shipmentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByOrderId(orderId: string): Observable<ResultOfListOfOrderShipmentDto> {
        let url_ = this.baseUrl + "/api/OrderShipment/order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfOrderShipmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfOrderShipmentDto>;
        }));
    }

    protected processGetByOrderId(response: HttpResponseBase): Observable<ResultOfListOfOrderShipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfOrderShipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateOrderShipmentRequest): Observable<ResultOfOrderShipmentDto> {
        let url_ = this.baseUrl + "/api/OrderShipment/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderShipmentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderShipmentDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfOrderShipmentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderShipmentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(shipmentId: string, request: UpdateOrderShipmentRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderShipment/update/{shipmentId}";
        if (shipmentId === undefined || shipmentId === null)
            throw new globalThis.Error("The parameter 'shipmentId' must be defined.");
        url_ = url_.replace("{shipmentId}", encodeURIComponent("" + shipmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateStatus(shipmentId: string, request: UpdateShipmentStatusRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderShipment/update-status/{shipmentId}";
        if (shipmentId === undefined || shipmentId === null)
            throw new globalThis.Error("The parameter 'shipmentId' must be defined.");
        url_ = url_.replace("{shipmentId}", encodeURIComponent("" + shipmentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderStatusHistoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getOrderStatusHistoriesPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfOrderStatusHistoryDto> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrderStatusHistoriesPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderStatusHistoriesPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfOrderStatusHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfOrderStatusHistoryDto>;
        }));
    }

    protected processGetOrderStatusHistoriesPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfOrderStatusHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfOrderStatusHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(historyId: string): Observable<ResultOfOrderStatusHistoryDto> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/{historyId}";
        if (historyId === undefined || historyId === null)
            throw new globalThis.Error("The parameter 'historyId' must be defined.");
        url_ = url_.replace("{historyId}", encodeURIComponent("" + historyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderStatusHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderStatusHistoryDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfOrderStatusHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderStatusHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(historyId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/{historyId}";
        if (historyId === undefined || historyId === null)
            throw new globalThis.Error("The parameter 'historyId' must be defined.");
        url_ = url_.replace("{historyId}", encodeURIComponent("" + historyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByOrderId(orderId: string): Observable<ResultOfListOfOrderStatusHistoryDto> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/order/{orderId}";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfOrderStatusHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfOrderStatusHistoryDto>;
        }));
    }

    protected processGetByOrderId(response: HttpResponseBase): Observable<ResultOfListOfOrderStatusHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfOrderStatusHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLatestByOrderId(orderId: string): Observable<ResultOfOrderStatusHistoryDto> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/order/{orderId}/latest";
        if (orderId === undefined || orderId === null)
            throw new globalThis.Error("The parameter 'orderId' must be defined.");
        url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestByOrderId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestByOrderId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderStatusHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderStatusHistoryDto>;
        }));
    }

    protected processGetLatestByOrderId(response: HttpResponseBase): Observable<ResultOfOrderStatusHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderStatusHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateOrderStatusHistoryRequest): Observable<ResultOfOrderStatusHistoryDto> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfOrderStatusHistoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfOrderStatusHistoryDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfOrderStatusHistoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderStatusHistoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addStatusChange(request: AddStatusChangeRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/OrderStatusHistory/add-status-change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddStatusChange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddStatusChange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAddStatusChange(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    checkAttributeExistsById(attributeId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/exists-by-id/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttributeExistsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttributeExistsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckAttributeExistsById(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkAttributeExistsByName(name: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/exists-by-name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttributeExistsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttributeExistsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckAttributeExistsByName(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkAttributeInUse(attributeId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/in-use/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttributeInUse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttributeInUse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckAttributeInUse(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllAttributes(): Observable<ResultOfPagedResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        }));
    }

    protected processGetAllAttributes(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAttributeById(attributeId: string): Observable<ResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/by-id/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttributeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttributeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductAttributeDto>;
        }));
    }

    protected processGetAttributeById(response: HttpResponseBase): Observable<ResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAttributeByName(name: string): Observable<ResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/by-name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttributeByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttributeByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductAttributeDto>;
        }));
    }

    protected processGetAttributeByName(response: HttpResponseBase): Observable<ResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAttributesByType(attributeType: number | undefined, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/by-type?";
        if (attributeType === null)
            throw new globalThis.Error("The parameter 'attributeType' cannot be null.");
        else if (attributeType !== undefined)
            url_ += "attributeType=" + encodeURIComponent("" + attributeType) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttributesByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttributesByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        }));
    }

    protected processGetAttributesByType(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRequiredAttributes(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/required?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequiredAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequiredAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        }));
    }

    protected processGetRequiredAttributes(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createAttribute(command: CreateProductAttributeCommand): Observable<ResultOfCreateProductAttributeResponse> {
        let url_ = this.baseUrl + "/api/ProductAttribute/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductAttributeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductAttributeResponse>;
        }));
    }

    protected processCreateAttribute(response: HttpResponseBase): Observable<ResultOfCreateProductAttributeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductAttributeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAttribute(command: UpdateProductAttributeCommand): Observable<ResultOfUpdateProductAttributeResponse> {
        let url_ = this.baseUrl + "/api/ProductAttribute/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductAttributeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductAttributeResponse>;
        }));
    }

    protected processUpdateAttribute(response: HttpResponseBase): Observable<ResultOfUpdateProductAttributeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductAttributeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAttribute(attributeId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/delete/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDeleteAttribute(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeValueClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getById(valueId: string): Observable<ResultOfProductAttributeValueDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/by-id/{valueId}";
        if (valueId === undefined || valueId === null)
            throw new globalThis.Error("The parameter 'valueId' must be defined.");
        url_ = url_.replace("{valueId}", encodeURIComponent("" + valueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductAttributeValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductAttributeValueDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductAttributeValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductAttributeValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/by-product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByAttribute(attributeId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/by-attribute/{attributeId}?";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
        }));
    }

    protected processGetByAttribute(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAttributeValueCommand): Observable<ResultOfCreateProductAttributeValueResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductAttributeValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductAttributeValueResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductAttributeValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductAttributeValueResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductAttributeValueCommand): Observable<ResultOfUpdateProductAttributeValueResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductAttributeValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductAttributeValueResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductAttributeValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductAttributeValueResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(valueId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/delete/{valueId}";
        if (valueId === undefined || valueId === null)
            throw new globalThis.Error("The parameter 'valueId' must be defined.");
        url_ = url_.replace("{valueId}", encodeURIComponent("" + valueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    create(name: string | undefined, slug: string | null | undefined, sku: string | undefined, description: string | undefined, shortDescription: string | null | undefined, price: number | undefined, discountPrice: number | null | undefined, cost: number | null | undefined, stockQuantity: number | undefined, minStockLevel: number | undefined, weight: number | null | undefined, dimensions: string | null | undefined, categoryId: string | undefined, brandId: string | null | undefined, status: number | undefined, isFeatured: boolean | undefined, isDigital: boolean | undefined, metaTitle: string | null | undefined, metaDescription: string | null | undefined, imageFiles: FileParameter[] | null | undefined, imageAltTexts: string[] | null | undefined, imageDisplayOrders: number[] | null | undefined, imageIsPrimary: boolean[] | null | undefined, variants: CreateProductVariantRequest[] | null | undefined, attributes: CreateProductAttributeValueRequest[] | null | undefined, tagIds: string[] | null | undefined): Observable<ResultOfCreateProductResponse> {
        let url_ = this.baseUrl + "/api/Product/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (slug !== null && slug !== undefined)
            content_.append("Slug", slug.toString());
        if (sku === null || sku === undefined)
            throw new globalThis.Error("The parameter 'sku' cannot be null.");
        else
            content_.append("Sku", sku.toString());
        if (description === null || description === undefined)
            throw new globalThis.Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription !== null && shortDescription !== undefined)
            content_.append("ShortDescription", shortDescription.toString());
        if (price === null || price === undefined)
            throw new globalThis.Error("The parameter 'price' cannot be null.");
        else
            content_.append("Price", price.toString());
        if (discountPrice !== null && discountPrice !== undefined)
            content_.append("DiscountPrice", discountPrice.toString());
        if (cost !== null && cost !== undefined)
            content_.append("Cost", cost.toString());
        if (stockQuantity === null || stockQuantity === undefined)
            throw new globalThis.Error("The parameter 'stockQuantity' cannot be null.");
        else
            content_.append("StockQuantity", stockQuantity.toString());
        if (minStockLevel === null || minStockLevel === undefined)
            throw new globalThis.Error("The parameter 'minStockLevel' cannot be null.");
        else
            content_.append("MinStockLevel", minStockLevel.toString());
        if (weight !== null && weight !== undefined)
            content_.append("Weight", weight.toString());
        if (dimensions !== null && dimensions !== undefined)
            content_.append("Dimensions", dimensions.toString());
        if (categoryId === null || categoryId === undefined)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else
            content_.append("CategoryId", categoryId.toString());
        if (brandId !== null && brandId !== undefined)
            content_.append("BrandId", brandId.toString());
        if (status === null || status === undefined)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (isFeatured === null || isFeatured === undefined)
            throw new globalThis.Error("The parameter 'isFeatured' cannot be null.");
        else
            content_.append("IsFeatured", isFeatured.toString());
        if (isDigital === null || isDigital === undefined)
            throw new globalThis.Error("The parameter 'isDigital' cannot be null.");
        else
            content_.append("IsDigital", isDigital.toString());
        if (metaTitle !== null && metaTitle !== undefined)
            content_.append("MetaTitle", metaTitle.toString());
        if (metaDescription !== null && metaDescription !== undefined)
            content_.append("MetaDescription", metaDescription.toString());
        if (imageFiles !== null && imageFiles !== undefined)
            imageFiles.forEach(item_ => content_.append("ImageFiles", item_.data, item_.fileName ? item_.fileName : "ImageFiles") );
        if (imageAltTexts !== null && imageAltTexts !== undefined)
            imageAltTexts.forEach(item_ => content_.append("ImageAltTexts", item_.toString()));
        if (imageDisplayOrders !== null && imageDisplayOrders !== undefined)
            imageDisplayOrders.forEach(item_ => content_.append("ImageDisplayOrders", item_.toString()));
        if (imageIsPrimary !== null && imageIsPrimary !== undefined)
            imageIsPrimary.forEach(item_ => content_.append("ImageIsPrimary", item_.toString()));
        if (variants !== null && variants !== undefined)
            variants.forEach(item_ => content_.append("Variants", item_.toString()));
        if (attributes !== null && attributes !== undefined)
            attributes.forEach(item_ => content_.append("Attributes", item_.toString()));
        if (tagIds !== null && tagIds !== undefined)
            tagIds.forEach(item_ => content_.append("TagIds", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createWithUrls(command: CreateProductCommand): Observable<ResultOfCreateProductResponse> {
        let url_ = this.baseUrl + "/api/Product/create-with-urls";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWithUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWithUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductResponse>;
        }));
    }

    protected processCreateWithUrls(response: HttpResponseBase): Observable<ResultOfCreateProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductBaseResponse> {
        let url_ = this.baseUrl + "/api/Product/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductBaseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductBaseResponse>;
        }));
    }

    protected processGetProductsPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductBaseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductBaseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(productId: string): Observable<ResultOfGetProductByIdResponse> {
        let url_ = this.baseUrl + "/api/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetProductByIdResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetProductByIdResponse>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfGetProductByIdResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetProductByIdResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(productId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Product/{productId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBySku(sku: string): Observable<ResultOfGetProductBySkuResponse> {
        let url_ = this.baseUrl + "/api/Product/sku/{sku}";
        if (sku === undefined || sku === null)
            throw new globalThis.Error("The parameter 'sku' must be defined.");
        url_ = url_.replace("{sku}", encodeURIComponent("" + sku));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySku(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySku(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetProductBySkuResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetProductBySkuResponse>;
        }));
    }

    protected processGetBySku(response: HttpResponseBase): Observable<ResultOfGetProductBySkuResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetProductBySkuResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBySlug(slug: string): Observable<ResultOfGetProductBySlugResponse> {
        let url_ = this.baseUrl + "/api/Product/slug/{slug}";
        if (slug === undefined || slug === null)
            throw new globalThis.Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetProductBySlugResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetProductBySlugResponse>;
        }));
    }

    protected processGetBySlug(response: HttpResponseBase): Observable<ResultOfGetProductBySlugResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetProductBySlugResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateWithFiles(productId: string | undefined, name: string | undefined, slug: string | null | undefined, sku: string | undefined, description: string | undefined, shortDescription: string | null | undefined, price: number | undefined, discountPrice: number | null | undefined, cost: number | null | undefined, stockQuantity: number | undefined, minStockLevel: number | undefined, weight: number | null | undefined, dimensions: string | null | undefined, categoryId: string | undefined, brandId: string | null | undefined, status: number | undefined, isFeatured: boolean | undefined, isDigital: boolean | undefined, metaTitle: string | null | undefined, metaDescription: string | null | undefined, newImageFiles: FileParameter[] | null | undefined, newImageAltTexts: string[] | null | undefined, newImageDisplayOrders: number[] | null | undefined, newImageIsPrimary: boolean[] | null | undefined, imageIdsToDelete: string[] | null | undefined, variants: CreateProductVariantRequest[] | null | undefined, attributes: CreateProductAttributeValueRequest[] | null | undefined, tagIds: string[] | null | undefined): Observable<ResultOfUpdateProductResponse> {
        let url_ = this.baseUrl + "/api/Product/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (productId === null || productId === undefined)
            throw new globalThis.Error("The parameter 'productId' cannot be null.");
        else
            content_.append("ProductId", productId.toString());
        if (name === null || name === undefined)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (slug !== null && slug !== undefined)
            content_.append("Slug", slug.toString());
        if (sku === null || sku === undefined)
            throw new globalThis.Error("The parameter 'sku' cannot be null.");
        else
            content_.append("Sku", sku.toString());
        if (description === null || description === undefined)
            throw new globalThis.Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription !== null && shortDescription !== undefined)
            content_.append("ShortDescription", shortDescription.toString());
        if (price === null || price === undefined)
            throw new globalThis.Error("The parameter 'price' cannot be null.");
        else
            content_.append("Price", price.toString());
        if (discountPrice !== null && discountPrice !== undefined)
            content_.append("DiscountPrice", discountPrice.toString());
        if (cost !== null && cost !== undefined)
            content_.append("Cost", cost.toString());
        if (stockQuantity === null || stockQuantity === undefined)
            throw new globalThis.Error("The parameter 'stockQuantity' cannot be null.");
        else
            content_.append("StockQuantity", stockQuantity.toString());
        if (minStockLevel === null || minStockLevel === undefined)
            throw new globalThis.Error("The parameter 'minStockLevel' cannot be null.");
        else
            content_.append("MinStockLevel", minStockLevel.toString());
        if (weight !== null && weight !== undefined)
            content_.append("Weight", weight.toString());
        if (dimensions !== null && dimensions !== undefined)
            content_.append("Dimensions", dimensions.toString());
        if (categoryId === null || categoryId === undefined)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else
            content_.append("CategoryId", categoryId.toString());
        if (brandId !== null && brandId !== undefined)
            content_.append("BrandId", brandId.toString());
        if (status === null || status === undefined)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (isFeatured === null || isFeatured === undefined)
            throw new globalThis.Error("The parameter 'isFeatured' cannot be null.");
        else
            content_.append("IsFeatured", isFeatured.toString());
        if (isDigital === null || isDigital === undefined)
            throw new globalThis.Error("The parameter 'isDigital' cannot be null.");
        else
            content_.append("IsDigital", isDigital.toString());
        if (metaTitle !== null && metaTitle !== undefined)
            content_.append("MetaTitle", metaTitle.toString());
        if (metaDescription !== null && metaDescription !== undefined)
            content_.append("MetaDescription", metaDescription.toString());
        if (newImageFiles !== null && newImageFiles !== undefined)
            newImageFiles.forEach(item_ => content_.append("NewImageFiles", item_.data, item_.fileName ? item_.fileName : "NewImageFiles") );
        if (newImageAltTexts !== null && newImageAltTexts !== undefined)
            newImageAltTexts.forEach(item_ => content_.append("NewImageAltTexts", item_.toString()));
        if (newImageDisplayOrders !== null && newImageDisplayOrders !== undefined)
            newImageDisplayOrders.forEach(item_ => content_.append("NewImageDisplayOrders", item_.toString()));
        if (newImageIsPrimary !== null && newImageIsPrimary !== undefined)
            newImageIsPrimary.forEach(item_ => content_.append("NewImageIsPrimary", item_.toString()));
        if (imageIdsToDelete !== null && imageIdsToDelete !== undefined)
            imageIdsToDelete.forEach(item_ => content_.append("ImageIdsToDelete", item_.toString()));
        if (variants !== null && variants !== undefined)
            variants.forEach(item_ => content_.append("Variants", item_.toString()));
        if (attributes !== null && attributes !== undefined)
            attributes.forEach(item_ => content_.append("Attributes", item_.toString()));
        if (tagIds !== null && tagIds !== undefined)
            tagIds.forEach(item_ => content_.append("TagIds", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateWithFiles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateWithFiles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductResponse>;
        }));
    }

    protected processUpdateWithFiles(response: HttpResponseBase): Observable<ResultOfUpdateProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductCommand): Observable<ResultOfUpdateProductResponse> {
        let url_ = this.baseUrl + "/api/Product/update-simple";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateStatus(command: UpdateProductStatusCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Product/update-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateStatus(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateStock(command: UpdateProductStockCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Product/update-stock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateStock(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFeatured(page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<ResultOfGetFeaturedProductsResponse> {
        let url_ = this.baseUrl + "/api/Product/featured?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFeatured(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFeatured(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetFeaturedProductsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetFeaturedProductsResponse>;
        }));
    }

    protected processGetFeatured(response: HttpResponseBase): Observable<ResultOfGetFeaturedProductsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetFeaturedProductsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActive(page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<ResultOfGetActiveProductsResponse> {
        let url_ = this.baseUrl + "/api/Product/active?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfGetActiveProductsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfGetActiveProductsResponse>;
        }));
    }

    protected processGetActive(response: HttpResponseBase): Observable<ResultOfGetActiveProductsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfGetActiveProductsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    search(searchTerm: string | null | undefined, categoryId: string | null | undefined, brandId: string | null | undefined, minPrice: number | null | undefined, maxPrice: number | null | undefined, isFeatured: boolean | null | undefined, isActive: boolean | null | undefined, tagIds: string[] | null | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined, page: number | undefined, pageSize: number | undefined): Observable<ResultOfSearchProductsResponse> {
        let url_ = this.baseUrl + "/api/Product/search?";
        if (searchTerm !== undefined && searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        if (categoryId !== undefined && categoryId !== null)
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (brandId !== undefined && brandId !== null)
            url_ += "brandId=" + encodeURIComponent("" + brandId) + "&";
        if (minPrice !== undefined && minPrice !== null)
            url_ += "minPrice=" + encodeURIComponent("" + minPrice) + "&";
        if (maxPrice !== undefined && maxPrice !== null)
            url_ += "maxPrice=" + encodeURIComponent("" + maxPrice) + "&";
        if (isFeatured !== undefined && isFeatured !== null)
            url_ += "isFeatured=" + encodeURIComponent("" + isFeatured) + "&";
        if (isActive !== undefined && isActive !== null)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&";
        if (tagIds !== undefined && tagIds !== null)
            tagIds && tagIds.forEach(item => { url_ += "tagIds=" + encodeURIComponent("" + item) + "&"; });
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfSearchProductsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfSearchProductsResponse>;
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<ResultOfSearchProductsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfSearchProductsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductImageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getUrlsByProduct(productId: string): Observable<ResultOfListOfString> {
        let url_ = this.baseUrl + "/api/ProductImage/urls/{productId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUrlsByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUrlsByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfString>;
        }));
    }

    protected processGetUrlsByProduct(response: HttpResponseBase): Observable<ResultOfListOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(imageId: string): Observable<ResultOfProductImageDto> {
        let url_ = this.baseUrl + "/api/ProductImage/by-id/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new globalThis.Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductImageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductImageDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductImageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductImageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductImageDto> {
        let url_ = this.baseUrl + "/api/ProductImage/by-product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductImageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductImageDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductImageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductImageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductImageCommand): Observable<ResultOfCreateProductImageResponse> {
        let url_ = this.baseUrl + "/api/ProductImage/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductImageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductImageResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductImageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductImageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductImageCommand): Observable<ResultOfUpdateProductImageResponse> {
        let url_ = this.baseUrl + "/api/ProductImage/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductImageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductImageResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductImageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductImageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setPrimary(imageId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductImage/set-primary/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new globalThis.Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPrimary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPrimary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processSetPrimary(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(imageId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductImage/delete/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new globalThis.Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getById(questionId: string): Observable<ResultOfProductQuestionDto> {
        let url_ = this.baseUrl + "/api/ProductQuestion/by-id/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new globalThis.Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductQuestionDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductQuestionDto> {
        let url_ = this.baseUrl + "/api/ProductQuestion/by-product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUnanswered(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductQuestionDto> {
        let url_ = this.baseUrl + "/api/ProductQuestion/unanswered?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnanswered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnanswered(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
        }));
    }

    protected processGetUnanswered(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductQuestionCommand): Observable<ResultOfCreateProductQuestionResponse> {
        let url_ = this.baseUrl + "/api/ProductQuestion/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductQuestionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductQuestionResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductQuestionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductQuestionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductQuestionCommand): Observable<ResultOfUpdateProductQuestionResponse> {
        let url_ = this.baseUrl + "/api/ProductQuestion/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductQuestionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductQuestionResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductQuestionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductQuestionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    answer(command: AnswerProductQuestionCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductQuestion/answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAnswer(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(questionId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductQuestion/delete/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new globalThis.Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductTagAssignmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    assignTagToProduct(request: AssignTagToProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignTagToProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignTagToProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAssignTagToProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeTagFromProduct(productId: string, tagId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/{productId}/{tagId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTagFromProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTagFromProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveTagFromProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeAllTagsFromProduct(productId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/product/{productId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAllTagsFromProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAllTagsFromProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveAllTagsFromProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByTag(tagId: string, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/tag/{tagId}?";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetByTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductTagClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getProductTagsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductTagsPaging(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTagById(tagId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/{tagId}";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductTagById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateProductTag(tagId: string, request: UpdateProductTagCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/{tagId}";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateProductTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteProductTag(tagId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/{tagId}";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteProductTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTagByName(name: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductTagByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProductTag(request: CreateProductTagCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateProductTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductVariantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    createVariant(request: CreateProductVariantRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCreateVariant(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVariant(variantId: string | undefined, request: UpdateProductVariantRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/update?";
        if (variantId === null)
            throw new globalThis.Error("The parameter 'variantId' cannot be null.");
        else if (variantId !== undefined)
            url_ += "variantId=" + encodeURIComponent("" + variantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateVariant(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createVariantWithFile(productId: string | undefined, sku: string | null | undefined, variantName: string | null | undefined, price: number | undefined, stockQuantity: number | undefined, minStockLevel: number | undefined, status: number | undefined, discountPrice: number | null | undefined, weight: number | null | undefined, dimensions: string | null | undefined, imageFile: FileParameter | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/create-with-file";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (productId === null || productId === undefined)
            throw new globalThis.Error("The parameter 'productId' cannot be null.");
        else
            content_.append("ProductId", productId.toString());
        if (sku !== null && sku !== undefined)
            content_.append("Sku", sku.toString());
        if (variantName !== null && variantName !== undefined)
            content_.append("VariantName", variantName.toString());
        if (price === null || price === undefined)
            throw new globalThis.Error("The parameter 'price' cannot be null.");
        else
            content_.append("Price", price.toString());
        if (stockQuantity === null || stockQuantity === undefined)
            throw new globalThis.Error("The parameter 'stockQuantity' cannot be null.");
        else
            content_.append("StockQuantity", stockQuantity.toString());
        if (minStockLevel === null || minStockLevel === undefined)
            throw new globalThis.Error("The parameter 'minStockLevel' cannot be null.");
        else
            content_.append("MinStockLevel", minStockLevel.toString());
        if (status === null || status === undefined)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (discountPrice !== null && discountPrice !== undefined)
            content_.append("DiscountPrice", discountPrice.toString());
        if (weight !== null && weight !== undefined)
            content_.append("Weight", weight.toString());
        if (dimensions !== null && dimensions !== undefined)
            content_.append("Dimensions", dimensions.toString());
        if (imageFile !== null && imageFile !== undefined)
            content_.append("ImageFile", imageFile.data, imageFile.fileName ? imageFile.fileName : "ImageFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVariantWithFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVariantWithFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCreateVariantWithFile(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadVariantImage(variantId: string, contentType: string | null | undefined, contentDisposition: string | null | undefined, headers: any[] | null | undefined, length: number | undefined, name: string | null | undefined, fileName: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/{variantId}/upload-image";
        if (variantId === undefined || variantId === null)
            throw new globalThis.Error("The parameter 'variantId' must be defined.");
        url_ = url_.replace("{variantId}", encodeURIComponent("" + variantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (contentType !== null && contentType !== undefined)
            content_.append("ContentType", contentType.toString());
        if (contentDisposition !== null && contentDisposition !== undefined)
            content_.append("ContentDisposition", contentDisposition.toString());
        if (headers !== null && headers !== undefined)
            headers.forEach(item_ => content_.append("Headers", item_.toString()));
        if (length === null || length === undefined)
            throw new globalThis.Error("The parameter 'length' cannot be null.");
        else
            content_.append("Length", length.toString());
        if (name !== null && name !== undefined)
            content_.append("Name", name.toString());
        if (fileName !== null && fileName !== undefined)
            content_.append("FileName", fileName.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadVariantImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadVariantImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUploadVariantImage(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVariant(variantId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/delete/{variantId}";
        if (variantId === undefined || variantId === null)
            throw new globalThis.Error("The parameter 'variantId' must be defined.");
        url_ = url_.replace("{variantId}", encodeURIComponent("" + variantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDeleteVariant(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVariantStock(command: UpdateProductVariantStockCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/update-stock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVariantStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVariantStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateVariantStock(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(variantId: string): Observable<ResultOfProductVariantDto> {
        let url_ = this.baseUrl + "/api/ProductVariant/by-id/{variantId}";
        if (variantId === undefined || variantId === null)
            throw new globalThis.Error("The parameter 'variantId' must be defined.");
        url_ = url_.replace("{variantId}", encodeURIComponent("" + variantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductVariantDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<ResultOfPagedResultOfProductVariantDto> {
        let url_ = this.baseUrl + "/api/ProductVariant/product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLowStock(page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined, threshold: number | undefined): Observable<ResultOfPagedResultOfProductVariantDto> {
        let url_ = this.baseUrl + "/api/ProductVariant/low-stock?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (threshold === null)
            throw new globalThis.Error("The parameter 'threshold' cannot be null.");
        else if (threshold !== undefined)
            url_ += "threshold=" + encodeURIComponent("" + threshold) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLowStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLowStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
        }));
    }

    protected processGetLowStock(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PurchaseOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getPurchaseOrdersPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrdersPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrdersPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetPurchaseOrdersPaging(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPurchaseOrderById(purchaseOrderId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/{purchaseOrderId}";
        if (purchaseOrderId === undefined || purchaseOrderId === null)
            throw new globalThis.Error("The parameter 'purchaseOrderId' must be defined.");
        url_ = url_.replace("{purchaseOrderId}", encodeURIComponent("" + purchaseOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrderById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrderById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetPurchaseOrderById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deletePurchaseOrder(purchaseOrderId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/{purchaseOrderId}";
        if (purchaseOrderId === undefined || purchaseOrderId === null)
            throw new globalThis.Error("The parameter 'purchaseOrderId' must be defined.");
        url_ = url_.replace("{purchaseOrderId}", encodeURIComponent("" + purchaseOrderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeletePurchaseOrder(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPurchaseOrdersByStatus(status: number, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/status/{status}/paging?";
        if (status === undefined || status === null)
            throw new globalThis.Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseOrdersByStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseOrdersByStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetPurchaseOrdersByStatus(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createPurchaseOrder(command: CreatePurchaseOrderCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PurchaseOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePurchaseOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePurchaseOrder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreatePurchaseOrder(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updatePurchaseOrderStatus(purchaseOrderId: string, command: UpdatePurchaseOrderStatusCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PurchaseOrder/{purchaseOrderId}/status";
        if (purchaseOrderId === undefined || purchaseOrderId === null)
            throw new globalThis.Error("The parameter 'purchaseOrderId' must be defined.");
        url_ = url_.replace("{purchaseOrderId}", encodeURIComponent("" + purchaseOrderId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePurchaseOrderStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePurchaseOrderStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdatePurchaseOrderStatus(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class RefreshTokenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getByUser(userId: string): Observable<ResultOfListOfRefreshToken> {
        let url_ = this.baseUrl + "/api/RefreshToken/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfRefreshToken>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfRefreshToken>;
        }));
    }

    protected processGetByUser(response: HttpResponseBase): Observable<ResultOfListOfRefreshToken> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfRefreshToken.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    revoke(tokenId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/RefreshToken/revoke/{tokenId}";
        if (tokenId === undefined || tokenId === null)
            throw new globalThis.Error("The parameter 'tokenId' must be defined.");
        url_ = url_.replace("{tokenId}", encodeURIComponent("" + tokenId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRevoke(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    revokeAll(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/RefreshToken/users/{userId}/revoke-all";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRevokeAll(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    cleanupExpired(): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/RefreshToken/cleanup-expired";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanupExpired(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanupExpired(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCleanupExpired(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ShipmentCarrierClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getShipmentCarriersPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfShipmentCarrierDto> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShipmentCarriersPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShipmentCarriersPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfShipmentCarrierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfShipmentCarrierDto>;
        }));
    }

    protected processGetShipmentCarriersPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfShipmentCarrierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfShipmentCarrierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<ResultOfListOfShipmentCarrierDto> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfShipmentCarrierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfShipmentCarrierDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResultOfListOfShipmentCarrierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfShipmentCarrierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActive(): Observable<ResultOfListOfShipmentCarrierDto> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/active";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActive(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActive(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfShipmentCarrierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfShipmentCarrierDto>;
        }));
    }

    protected processGetActive(response: HttpResponseBase): Observable<ResultOfListOfShipmentCarrierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfShipmentCarrierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(carrierId: string): Observable<ResultOfShipmentCarrierDto> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/{carrierId}";
        if (carrierId === undefined || carrierId === null)
            throw new globalThis.Error("The parameter 'carrierId' must be defined.");
        url_ = url_.replace("{carrierId}", encodeURIComponent("" + carrierId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShipmentCarrierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShipmentCarrierDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfShipmentCarrierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShipmentCarrierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(carrierId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/{carrierId}";
        if (carrierId === undefined || carrierId === null)
            throw new globalThis.Error("The parameter 'carrierId' must be defined.");
        url_ = url_.replace("{carrierId}", encodeURIComponent("" + carrierId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByName(name: string): Observable<ResultOfShipmentCarrierDto> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShipmentCarrierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShipmentCarrierDto>;
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<ResultOfShipmentCarrierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShipmentCarrierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(request: CreateShipmentCarrierRequest): Observable<ResultOfShipmentCarrierDto> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShipmentCarrierDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShipmentCarrierDto>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfShipmentCarrierDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShipmentCarrierDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(carrierId: string, request: UpdateShipmentCarrierRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ShipmentCarrier/update/{carrierId}";
        if (carrierId === undefined || carrierId === null)
            throw new globalThis.Error("The parameter 'carrierId' must be defined.");
        url_ = url_.replace("{carrierId}", encodeURIComponent("" + carrierId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserAddressClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getByUser(userId: string, request: PagedRequest): Observable<ResultOfPagedResultOfUserAddress> {
        let url_ = this.baseUrl + "/api/UserAddress/users/{userId}/paged";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfUserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfUserAddress>;
        }));
    }

    protected processGetByUser(response: HttpResponseBase): Observable<ResultOfPagedResultOfUserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfUserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getDefault(userId: string): Observable<ResultOfUserAddress> {
        let url_ = this.baseUrl + "/api/UserAddress/users/{userId}/default";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUserAddress>;
        }));
    }

    protected processGetDefault(response: HttpResponseBase): Observable<ResultOfUserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserAddressCommand): Observable<ResultOfUserAddress> {
        let url_ = this.baseUrl + "/api/UserAddress/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUserAddress>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUserAddress>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfUserAddress> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserAddress.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateUserAddressCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserAddress/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setDefault(userId: string, addressId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserAddress/users/{userId}/default/{addressId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (addressId === undefined || addressId === null)
            throw new globalThis.Error("The parameter 'addressId' must be defined.");
        url_ = url_.replace("{addressId}", encodeURIComponent("" + addressId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefault(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefault(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processSetDefault(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(addressId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserAddress/{addressId}";
        if (addressId === undefined || addressId === null)
            throw new globalThis.Error("The parameter 'addressId' must be defined.");
        url_ = url_.replace("{addressId}", encodeURIComponent("" + addressId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getUsersPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetUsersPaging(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(userId: string): Observable<ResultOfUser> {
        let url_ = this.baseUrl + "/api/User/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUser>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/User/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByEmail(email: string | undefined): Observable<ResultOfUser> {
        let url_ = this.baseUrl + "/api/User/by-email?";
        if (email === null)
            throw new globalThis.Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUser>;
        }));
    }

    protected processGetByEmail(response: HttpResponseBase): Observable<ResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByUsername(username: string | undefined): Observable<ResultOfUser> {
        let url_ = this.baseUrl + "/api/User/by-username?";
        if (username === null)
            throw new globalThis.Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUsername(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUsername(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUser>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUser>;
        }));
    }

    protected processGetByUsername(response: HttpResponseBase): Observable<ResultOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/User/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateUserCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/User/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleAssignmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    assign(command: AssignUserRoleCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserRoleAssignment/assign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssign(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAssign(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    remove(command: RemoveUserRoleCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserRoleAssignment/remove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserRoleNames(userId: string): Observable<ResultOfListOfString> {
        let url_ = this.baseUrl + "/api/UserRoleAssignment/users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoleNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoleNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfString>;
        }));
    }

    protected processGetUserRoleNames(response: HttpResponseBase): Observable<ResultOfListOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfString.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAssignmentsByUser(userId: string, request: PagedRequest): Observable<ResultOfPagedResultOfUserRoleAssignment> {
        let url_ = this.baseUrl + "/api/UserRoleAssignment/users/{userId}/paged";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssignmentsByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignmentsByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfUserRoleAssignment>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfUserRoleAssignment>;
        }));
    }

    protected processGetAssignmentsByUser(response: HttpResponseBase): Observable<ResultOfPagedResultOfUserRoleAssignment> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfUserRoleAssignment.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfUserRole> {
        let url_ = this.baseUrl + "/api/UserRole/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfUserRole>;
        }));
    }

    protected processGetPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(roleId: string): Observable<ResultOfUserRole> {
        let url_ = this.baseUrl + "/api/UserRole/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new globalThis.Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUserRole>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(roleId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserRole/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new globalThis.Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(): Observable<ResultOfListOfUserRole> {
        let url_ = this.baseUrl + "/api/UserRole/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfUserRole>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResultOfListOfUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserRoleCommand): Observable<ResultOfUserRole> {
        let url_ = this.baseUrl + "/api/UserRole/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUserRole>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfUserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUserRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateUserRoleCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserRole/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserSessionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getByUser(userId: string, request: PagedRequest): Observable<ResultOfPagedResultOfUserSession> {
        let url_ = this.baseUrl + "/api/UserSession/users/{userId}/paged";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfUserSession>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfUserSession>;
        }));
    }

    protected processGetByUser(response: HttpResponseBase): Observable<ResultOfPagedResultOfUserSession> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfUserSession.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveByUser(userId: string, request: PagedRequest): Observable<ResultOfPagedResultOfUserSession> {
        let url_ = this.baseUrl + "/api/UserSession/users/{userId}/active-paged";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfUserSession>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfUserSession>;
        }));
    }

    protected processGetActiveByUser(response: HttpResponseBase): Observable<ResultOfPagedResultOfUserSession> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfUserSession.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    revoke(sessionId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserSession/revoke/{sessionId}";
        if (sessionId === undefined || sessionId === null)
            throw new globalThis.Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRevoke(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    revokeAll(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/UserSession/users/{userId}/revoke-all";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevokeAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevokeAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRevokeAll(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WishlistClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getWishlist(userId: string): Observable<ResultOfWishlistDto> {
        let url_ = this.baseUrl + "/api/Wishlist/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfWishlistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfWishlistDto>;
        }));
    }

    protected processGetWishlist(response: HttpResponseBase): Observable<ResultOfWishlistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfWishlistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addItem(userId: string, request: AddToWishlistRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Wishlist/users/{userId}/items";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAddItem(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserWishlistItems(userId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfWishlistItemDto> {
        let url_ = this.baseUrl + "/api/Wishlist/users/{userId}/items?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserWishlistItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserWishlistItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfWishlistItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfWishlistItemDto>;
        }));
    }

    protected processGetUserWishlistItems(response: HttpResponseBase): Observable<ResultOfPagedResultOfWishlistItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfWishlistItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItem(itemId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Wishlist/items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItem(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWishlistItems(wishlistId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfWishlistItemDto> {
        let url_ = this.baseUrl + "/api/Wishlist/wishlists/{wishlistId}/items?";
        if (wishlistId === undefined || wishlistId === null)
            throw new globalThis.Error("The parameter 'wishlistId' must be defined.");
        url_ = url_.replace("{wishlistId}", encodeURIComponent("" + wishlistId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            withCredentials: true,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWishlistItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWishlistItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfWishlistItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfWishlistItemDto>;
        }));
    }

    protected processGetWishlistItems(response: HttpResponseBase): Observable<ResultOfPagedResultOfWishlistItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfWishlistItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ResultOfPagedResultOfAbandonedCartDto implements IResultOfPagedResultOfAbandonedCartDto {
    isSuccess?: boolean;
    data?: PagedResultOfAbandonedCartDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfAbandonedCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfAbandonedCartDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfAbandonedCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfAbandonedCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfAbandonedCartDto {
    isSuccess?: boolean;
    data?: PagedResultOfAbandonedCartDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfAbandonedCartDto implements IPagedResultOfAbandonedCartDto {
    items?: AbandonedCartDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfAbandonedCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AbandonedCartDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfAbandonedCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAbandonedCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfAbandonedCartDto {
    items?: AbandonedCartDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AbandonedCartDto implements IAbandonedCartDto {
    abandonedCartId?: string;
    userId?: string;
    userEmail?: string;
    userName?: string;
    cartValue?: number;
    itemCount?: number;
    lastActivity?: Date;
    createdAt?: Date;
    recoveredAt?: Date | undefined;
    isRecovered?: boolean;
    items?: ShoppingCartItemDto[];

    constructor(data?: IAbandonedCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.abandonedCartId = _data["abandonedCartId"];
            this.userId = _data["userId"];
            this.userEmail = _data["userEmail"];
            this.userName = _data["userName"];
            this.cartValue = _data["cartValue"];
            this.itemCount = _data["itemCount"];
            this.lastActivity = _data["lastActivity"] ? new Date(_data["lastActivity"].toString()) : undefined as any;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.recoveredAt = _data["recoveredAt"] ? new Date(_data["recoveredAt"].toString()) : undefined as any;
            this.isRecovered = _data["isRecovered"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShoppingCartItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AbandonedCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbandonedCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["abandonedCartId"] = this.abandonedCartId;
        data["userId"] = this.userId;
        data["userEmail"] = this.userEmail;
        data["userName"] = this.userName;
        data["cartValue"] = this.cartValue;
        data["itemCount"] = this.itemCount;
        data["lastActivity"] = this.lastActivity ? this.lastActivity.toISOString() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["recoveredAt"] = this.recoveredAt ? this.recoveredAt.toISOString() : undefined as any;
        data["isRecovered"] = this.isRecovered;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IAbandonedCartDto {
    abandonedCartId?: string;
    userId?: string;
    userEmail?: string;
    userName?: string;
    cartValue?: number;
    itemCount?: number;
    lastActivity?: Date;
    createdAt?: Date;
    recoveredAt?: Date | undefined;
    isRecovered?: boolean;
    items?: ShoppingCartItemDto[];
}

export class ShoppingCartItemDto implements IShoppingCartItemDto {
    cartItemId?: string;
    cartId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    unitPrice?: number;
    quantity?: number;
    totalPrice?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IShoppingCartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.cartId = _data["cartId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.productImageUrl = _data["productImageUrl"];
            this.productVariantId = _data["productVariantId"];
            this.variantName = _data["variantName"];
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
            this.totalPrice = _data["totalPrice"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ShoppingCartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["cartId"] = this.cartId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["productImageUrl"] = this.productImageUrl;
        data["productVariantId"] = this.productVariantId;
        data["variantName"] = this.variantName;
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        data["totalPrice"] = this.totalPrice;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IShoppingCartItemDto {
    cartItemId?: string;
    cartId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    unitPrice?: number;
    quantity?: number;
    totalPrice?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class FilterCriteria implements IFilterCriteria {
    fieldName?: string;
    value?: string;
    operator?: FilterOperator;

    constructor(data?: IFilterCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): FilterCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new FilterCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        data["operator"] = this.operator;
        return data;
    }
}

export interface IFilterCriteria {
    fieldName?: string;
    value?: string;
    operator?: FilterOperator;
}

export enum FilterOperator {
    Equals = 0,
    NotEquals = 1,
    Contains = 2,
    NotContains = 3,
    StartsWith = 4,
    EndsWith = 5,
    GreaterThan = 6,
    GreaterThanOrEqual = 7,
    LessThan = 8,
    LessThanOrEqual = 9,
    In = 10,
    NotIn = 11,
    IsNull = 12,
    IsNotNull = 13,
}

export class SearchableField implements ISearchableField {
    fieldName?: string;
    fieldType?: string;
    isSearchable?: boolean;
    isSortable?: boolean;
    isFilterable?: boolean;

    constructor(data?: ISearchableField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.isSearchable = _data["isSearchable"];
            this.isSortable = _data["isSortable"];
            this.isFilterable = _data["isFilterable"];
        }
    }

    static fromJS(data: any): SearchableField {
        data = typeof data === 'object' ? data : {};
        let result = new SearchableField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["isSearchable"] = this.isSearchable;
        data["isSortable"] = this.isSortable;
        data["isFilterable"] = this.isFilterable;
        return data;
    }
}

export interface ISearchableField {
    fieldName?: string;
    fieldType?: string;
    isSearchable?: boolean;
    isSortable?: boolean;
    isFilterable?: boolean;
}

export class ResultOfBoolean implements IResultOfBoolean {
    isSuccess?: boolean;
    data?: boolean;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfBoolean {
    isSuccess?: boolean;
    data?: boolean;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class MarkCartsNotifiedRequest implements IMarkCartsNotifiedRequest {
    abandonedCartIds?: string[];

    constructor(data?: IMarkCartsNotifiedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["abandonedCartIds"])) {
                this.abandonedCartIds = [] as any;
                for (let item of _data["abandonedCartIds"])
                    this.abandonedCartIds!.push(item);
            }
        }
    }

    static fromJS(data: any): MarkCartsNotifiedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MarkCartsNotifiedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.abandonedCartIds)) {
            data["abandonedCartIds"] = [];
            for (let item of this.abandonedCartIds)
                data["abandonedCartIds"].push(item);
        }
        return data;
    }
}

export interface IMarkCartsNotifiedRequest {
    abandonedCartIds?: string[];
}

export class ResultOfPagedResultOfAuditLog implements IResultOfPagedResultOfAuditLog {
    isSuccess?: boolean;
    data?: PagedResultOfAuditLog | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfAuditLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfAuditLog.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfAuditLog {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfAuditLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfAuditLog {
    isSuccess?: boolean;
    data?: PagedResultOfAuditLog | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfAuditLog implements IPagedResultOfAuditLog {
    items?: AuditLog[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfAuditLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLog.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfAuditLog {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAuditLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfAuditLog {
    items?: AuditLog[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AuditLog implements IAuditLog {
    auditId?: string;
    userId?: string | undefined;
    action!: string;
    entity?: string | undefined;
    entityId?: string | undefined;
    detail?: string | undefined;
    createdAt?: Date;
    user?: User | undefined;

    constructor(data?: IAuditLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.auditId = _data["auditId"];
            this.userId = _data["userId"];
            this.action = _data["action"];
            this.entity = _data["entity"];
            this.entityId = _data["entityId"];
            this.detail = _data["detail"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): AuditLog {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["auditId"] = this.auditId;
        data["userId"] = this.userId;
        data["action"] = this.action;
        data["entity"] = this.entity;
        data["entityId"] = this.entityId;
        data["detail"] = this.detail;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IAuditLog {
    auditId?: string;
    userId?: string | undefined;
    action: string;
    entity?: string | undefined;
    entityId?: string | undefined;
    detail?: string | undefined;
    createdAt?: Date;
    user?: User | undefined;
}

export class User implements IUser {
    userId?: string;
    email!: string;
    passwordHash!: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;
    username!: string;
    status?: number;
    emailVerified?: boolean;
    phoneVerified?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    lastLoginAt?: Date | undefined;
    failedLoginAttempts?: number;
    lastFailedLogin?: Date | undefined;
    lockedUntil?: Date | undefined;
    userRoleAssignments?: UserRoleAssignment[];
    userAddresses?: UserAddress[];
    userSessions?: UserSession[];
    auditLogs?: AuditLog[];
    refreshTokens?: RefreshToken[];
    shoppingCarts?: ShoppingCart[];
    wishlists?: Wishlist[];
    abandonedCarts?: AbandonedCart[];
    orders?: Order[];
    couponUsages?: CouponUsage[];
    rewardPoints?: RewardPoint[];
    productReviews?: ProductReview[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.passwordHash = _data["passwordHash"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : undefined as any;
            this.username = _data["username"];
            this.status = _data["status"];
            this.emailVerified = _data["emailVerified"];
            this.phoneVerified = _data["phoneVerified"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.lastLoginAt = _data["lastLoginAt"] ? new Date(_data["lastLoginAt"].toString()) : undefined as any;
            this.failedLoginAttempts = _data["failedLoginAttempts"];
            this.lastFailedLogin = _data["lastFailedLogin"] ? new Date(_data["lastFailedLogin"].toString()) : undefined as any;
            this.lockedUntil = _data["lockedUntil"] ? new Date(_data["lockedUntil"].toString()) : undefined as any;
            if (Array.isArray(_data["userRoleAssignments"])) {
                this.userRoleAssignments = [] as any;
                for (let item of _data["userRoleAssignments"])
                    this.userRoleAssignments!.push(UserRoleAssignment.fromJS(item));
            }
            if (Array.isArray(_data["userAddresses"])) {
                this.userAddresses = [] as any;
                for (let item of _data["userAddresses"])
                    this.userAddresses!.push(UserAddress.fromJS(item));
            }
            if (Array.isArray(_data["userSessions"])) {
                this.userSessions = [] as any;
                for (let item of _data["userSessions"])
                    this.userSessions!.push(UserSession.fromJS(item));
            }
            if (Array.isArray(_data["auditLogs"])) {
                this.auditLogs = [] as any;
                for (let item of _data["auditLogs"])
                    this.auditLogs!.push(AuditLog.fromJS(item));
            }
            if (Array.isArray(_data["refreshTokens"])) {
                this.refreshTokens = [] as any;
                for (let item of _data["refreshTokens"])
                    this.refreshTokens!.push(RefreshToken.fromJS(item));
            }
            if (Array.isArray(_data["shoppingCarts"])) {
                this.shoppingCarts = [] as any;
                for (let item of _data["shoppingCarts"])
                    this.shoppingCarts!.push(ShoppingCart.fromJS(item));
            }
            if (Array.isArray(_data["wishlists"])) {
                this.wishlists = [] as any;
                for (let item of _data["wishlists"])
                    this.wishlists!.push(Wishlist.fromJS(item));
            }
            if (Array.isArray(_data["abandonedCarts"])) {
                this.abandonedCarts = [] as any;
                for (let item of _data["abandonedCarts"])
                    this.abandonedCarts!.push(AbandonedCart.fromJS(item));
            }
            if (Array.isArray(_data["orders"])) {
                this.orders = [] as any;
                for (let item of _data["orders"])
                    this.orders!.push(Order.fromJS(item));
            }
            if (Array.isArray(_data["couponUsages"])) {
                this.couponUsages = [] as any;
                for (let item of _data["couponUsages"])
                    this.couponUsages!.push(CouponUsage.fromJS(item));
            }
            if (Array.isArray(_data["rewardPoints"])) {
                this.rewardPoints = [] as any;
                for (let item of _data["rewardPoints"])
                    this.rewardPoints!.push(RewardPoint.fromJS(item));
            }
            if (Array.isArray(_data["productReviews"])) {
                this.productReviews = [] as any;
                for (let item of _data["productReviews"])
                    this.productReviews!.push(ProductReview.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["passwordHash"] = this.passwordHash;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : undefined as any;
        data["username"] = this.username;
        data["status"] = this.status;
        data["emailVerified"] = this.emailVerified;
        data["phoneVerified"] = this.phoneVerified;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["lastLoginAt"] = this.lastLoginAt ? this.lastLoginAt.toISOString() : undefined as any;
        data["failedLoginAttempts"] = this.failedLoginAttempts;
        data["lastFailedLogin"] = this.lastFailedLogin ? this.lastFailedLogin.toISOString() : undefined as any;
        data["lockedUntil"] = this.lockedUntil ? this.lockedUntil.toISOString() : undefined as any;
        if (Array.isArray(this.userRoleAssignments)) {
            data["userRoleAssignments"] = [];
            for (let item of this.userRoleAssignments)
                data["userRoleAssignments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.userAddresses)) {
            data["userAddresses"] = [];
            for (let item of this.userAddresses)
                data["userAddresses"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.userSessions)) {
            data["userSessions"] = [];
            for (let item of this.userSessions)
                data["userSessions"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.auditLogs)) {
            data["auditLogs"] = [];
            for (let item of this.auditLogs)
                data["auditLogs"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.refreshTokens)) {
            data["refreshTokens"] = [];
            for (let item of this.refreshTokens)
                data["refreshTokens"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.shoppingCarts)) {
            data["shoppingCarts"] = [];
            for (let item of this.shoppingCarts)
                data["shoppingCarts"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.wishlists)) {
            data["wishlists"] = [];
            for (let item of this.wishlists)
                data["wishlists"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.abandonedCarts)) {
            data["abandonedCarts"] = [];
            for (let item of this.abandonedCarts)
                data["abandonedCarts"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.orders)) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.couponUsages)) {
            data["couponUsages"] = [];
            for (let item of this.couponUsages)
                data["couponUsages"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.rewardPoints)) {
            data["rewardPoints"] = [];
            for (let item of this.rewardPoints)
                data["rewardPoints"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.productReviews)) {
            data["productReviews"] = [];
            for (let item of this.productReviews)
                data["productReviews"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IUser {
    userId?: string;
    email: string;
    passwordHash: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;
    username: string;
    status?: number;
    emailVerified?: boolean;
    phoneVerified?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    lastLoginAt?: Date | undefined;
    failedLoginAttempts?: number;
    lastFailedLogin?: Date | undefined;
    lockedUntil?: Date | undefined;
    userRoleAssignments?: UserRoleAssignment[];
    userAddresses?: UserAddress[];
    userSessions?: UserSession[];
    auditLogs?: AuditLog[];
    refreshTokens?: RefreshToken[];
    shoppingCarts?: ShoppingCart[];
    wishlists?: Wishlist[];
    abandonedCarts?: AbandonedCart[];
    orders?: Order[];
    couponUsages?: CouponUsage[];
    rewardPoints?: RewardPoint[];
    productReviews?: ProductReview[];
}

export class UserRoleAssignment implements IUserRoleAssignment {
    userId?: string;
    roleId?: string;
    assignedAt?: Date;
    assignedBy?: string;
    user?: User;
    role?: UserRole;
    assignedByUser?: User;

    constructor(data?: IUserRoleAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.assignedAt = _data["assignedAt"] ? new Date(_data["assignedAt"].toString()) : undefined as any;
            this.assignedBy = _data["assignedBy"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.role = _data["role"] ? UserRole.fromJS(_data["role"]) : undefined as any;
            this.assignedByUser = _data["assignedByUser"] ? User.fromJS(_data["assignedByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserRoleAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["assignedAt"] = this.assignedAt ? this.assignedAt.toISOString() : undefined as any;
        data["assignedBy"] = this.assignedBy;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["role"] = this.role ? this.role.toJSON() : undefined as any;
        data["assignedByUser"] = this.assignedByUser ? this.assignedByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserRoleAssignment {
    userId?: string;
    roleId?: string;
    assignedAt?: Date;
    assignedBy?: string;
    user?: User;
    role?: UserRole;
    assignedByUser?: User;
}

export class UserRole implements IUserRole {
    roleId?: string;
    roleName!: string;
    description?: string | undefined;
    createdAt?: Date;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IUserRole {
    roleId?: string;
    roleName: string;
    description?: string | undefined;
    createdAt?: Date;
}

export class UserAddress implements IUserAddress {
    addressId?: string;
    userId?: string;
    addressType?: number;
    addressLine1!: string;
    addressLine2?: string | undefined;
    city!: string;
    state!: string;
    zipCode!: string;
    country!: string;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    user?: User;

    constructor(data?: IUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressId = _data["addressId"];
            this.userId = _data["userId"];
            this.addressType = _data["addressType"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
            this.isDefault = _data["isDefault"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new UserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressId"] = this.addressId;
        data["userId"] = this.userId;
        data["addressType"] = this.addressType;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        data["isDefault"] = this.isDefault;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserAddress {
    addressId?: string;
    userId?: string;
    addressType?: number;
    addressLine1: string;
    addressLine2?: string | undefined;
    city: string;
    state: string;
    zipCode: string;
    country: string;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    user?: User;
}

export class UserSession implements IUserSession {
    sessionId?: string;
    userId?: string | undefined;
    sessionToken!: string;
    deviceInfo?: string | undefined;
    ipAddress?: string | undefined;
    createdAt?: Date;
    expiresAt?: Date | undefined;
    revoked?: boolean;
    user?: User | undefined;

    constructor(data?: IUserSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            this.userId = _data["userId"];
            this.sessionToken = _data["sessionToken"];
            this.deviceInfo = _data["deviceInfo"];
            this.ipAddress = _data["ipAddress"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.revoked = _data["revoked"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): UserSession {
        data = typeof data === 'object' ? data : {};
        let result = new UserSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        data["userId"] = this.userId;
        data["sessionToken"] = this.sessionToken;
        data["deviceInfo"] = this.deviceInfo;
        data["ipAddress"] = this.ipAddress;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["revoked"] = this.revoked;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IUserSession {
    sessionId?: string;
    userId?: string | undefined;
    sessionToken: string;
    deviceInfo?: string | undefined;
    ipAddress?: string | undefined;
    createdAt?: Date;
    expiresAt?: Date | undefined;
    revoked?: boolean;
    user?: User | undefined;
}

export class RefreshToken implements IRefreshToken {
    tokenId?: string;
    userId?: string;
    refreshTokenValue!: string;
    expiresAt?: Date;
    revoked?: boolean;
    createdAt?: Date;
    createdByIp?: string | undefined;
    replacedByToken?: string | undefined;
    user?: User;

    constructor(data?: IRefreshToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenId = _data["tokenId"];
            this.userId = _data["userId"];
            this.refreshTokenValue = _data["refreshTokenValue"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.revoked = _data["revoked"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdByIp = _data["createdByIp"];
            this.replacedByToken = _data["replacedByToken"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): RefreshToken {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenId"] = this.tokenId;
        data["userId"] = this.userId;
        data["refreshTokenValue"] = this.refreshTokenValue;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["revoked"] = this.revoked;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdByIp"] = this.createdByIp;
        data["replacedByToken"] = this.replacedByToken;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IRefreshToken {
    tokenId?: string;
    userId?: string;
    refreshTokenValue: string;
    expiresAt?: Date;
    revoked?: boolean;
    createdAt?: Date;
    createdByIp?: string | undefined;
    replacedByToken?: string | undefined;
    user?: User;
}

export class ShoppingCart implements IShoppingCart {
    cartId?: string;
    userId?: string | undefined;
    sessionId?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    user?: User | undefined;
    shoppingCartItems?: ShoppingCartItem[];

    constructor(data?: IShoppingCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartId = _data["cartId"];
            this.userId = _data["userId"];
            this.sessionId = _data["sessionId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            if (Array.isArray(_data["shoppingCartItems"])) {
                this.shoppingCartItems = [] as any;
                for (let item of _data["shoppingCartItems"])
                    this.shoppingCartItems!.push(ShoppingCartItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShoppingCart {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartId"] = this.cartId;
        data["userId"] = this.userId;
        data["sessionId"] = this.sessionId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        if (Array.isArray(this.shoppingCartItems)) {
            data["shoppingCartItems"] = [];
            for (let item of this.shoppingCartItems)
                data["shoppingCartItems"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IShoppingCart {
    cartId?: string;
    userId?: string | undefined;
    sessionId?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    user?: User | undefined;
    shoppingCartItems?: ShoppingCartItem[];
}

export class ShoppingCartItem implements IShoppingCartItem {
    cartItemId?: string;
    cartId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    quantity?: number;
    unitPrice!: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    shoppingCart?: ShoppingCart;
    product?: Product;
    productVariant?: ProductVariant | undefined;

    constructor(data?: IShoppingCartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.cartId = _data["cartId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.shoppingCart = _data["shoppingCart"] ? ShoppingCart.fromJS(_data["shoppingCart"]) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.productVariant = _data["productVariant"] ? ProductVariant.fromJS(_data["productVariant"]) : undefined as any;
        }
    }

    static fromJS(data: any): ShoppingCartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["cartId"] = this.cartId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["shoppingCart"] = this.shoppingCart ? this.shoppingCart.toJSON() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["productVariant"] = this.productVariant ? this.productVariant.toJSON() : undefined as any;
        return data;
    }
}

export interface IShoppingCartItem {
    cartItemId?: string;
    cartId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    quantity?: number;
    unitPrice: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    shoppingCart?: ShoppingCart;
    product?: Product;
    productVariant?: ProductVariant | undefined;
}

export class Product implements IProduct {
    productId?: string;
    name!: string;
    slug?: string | undefined;
    sku!: string;
    description!: string;
    shortDescription?: string | undefined;
    price!: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    category?: Category;
    brand?: Brand | undefined;
    createdByUser?: User;
    updatedByUser?: User | undefined;
    productImages?: ProductImage[];
    productAttributeValues?: ProductAttributeValue[];
    productVariants?: ProductVariant[];
    productTagAssignments?: ProductTagAssignment[];
    productQuestions?: ProductQuestion[];
    reviews?: ProductReview[];

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.categoryId = _data["categoryId"];
            this.brandId = _data["brandId"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.isDigital = _data["isDigital"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : undefined as any;
            this.brand = _data["brand"] ? Brand.fromJS(_data["brand"]) : undefined as any;
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : undefined as any;
            this.updatedByUser = _data["updatedByUser"] ? User.fromJS(_data["updatedByUser"]) : undefined as any;
            if (Array.isArray(_data["productImages"])) {
                this.productImages = [] as any;
                for (let item of _data["productImages"])
                    this.productImages!.push(ProductImage.fromJS(item));
            }
            if (Array.isArray(_data["productAttributeValues"])) {
                this.productAttributeValues = [] as any;
                for (let item of _data["productAttributeValues"])
                    this.productAttributeValues!.push(ProductAttributeValue.fromJS(item));
            }
            if (Array.isArray(_data["productVariants"])) {
                this.productVariants = [] as any;
                for (let item of _data["productVariants"])
                    this.productVariants!.push(ProductVariant.fromJS(item));
            }
            if (Array.isArray(_data["productTagAssignments"])) {
                this.productTagAssignments = [] as any;
                for (let item of _data["productTagAssignments"])
                    this.productTagAssignments!.push(ProductTagAssignment.fromJS(item));
            }
            if (Array.isArray(_data["productQuestions"])) {
                this.productQuestions = [] as any;
                for (let item of _data["productQuestions"])
                    this.productQuestions!.push(ProductQuestion.fromJS(item));
            }
            if (Array.isArray(_data["reviews"])) {
                this.reviews = [] as any;
                for (let item of _data["reviews"])
                    this.reviews!.push(ProductReview.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["categoryId"] = this.categoryId;
        data["brandId"] = this.brandId;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["isDigital"] = this.isDigital;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["category"] = this.category ? this.category.toJSON() : undefined as any;
        data["brand"] = this.brand ? this.brand.toJSON() : undefined as any;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : undefined as any;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : undefined as any;
        if (Array.isArray(this.productImages)) {
            data["productImages"] = [];
            for (let item of this.productImages)
                data["productImages"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.productAttributeValues)) {
            data["productAttributeValues"] = [];
            for (let item of this.productAttributeValues)
                data["productAttributeValues"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.productVariants)) {
            data["productVariants"] = [];
            for (let item of this.productVariants)
                data["productVariants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.productTagAssignments)) {
            data["productTagAssignments"] = [];
            for (let item of this.productTagAssignments)
                data["productTagAssignments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.productQuestions)) {
            data["productQuestions"] = [];
            for (let item of this.productQuestions)
                data["productQuestions"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.reviews)) {
            data["reviews"] = [];
            for (let item of this.reviews)
                data["reviews"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProduct {
    productId?: string;
    name: string;
    slug?: string | undefined;
    sku: string;
    description: string;
    shortDescription?: string | undefined;
    price: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    category?: Category;
    brand?: Brand | undefined;
    createdByUser?: User;
    updatedByUser?: User | undefined;
    productImages?: ProductImage[];
    productAttributeValues?: ProductAttributeValue[];
    productVariants?: ProductVariant[];
    productTagAssignments?: ProductTagAssignment[];
    productQuestions?: ProductQuestion[];
    reviews?: ProductReview[];
}

export class Category implements ICategory {
    categoryId?: string;
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    parentCategoryId?: string | undefined;
    displayOrder?: number;
    status?: number;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    parentCategory?: Category | undefined;
    subCategories?: Category[];
    products?: Product[];
    createdByUser?: User;
    updatedByUser?: User | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.displayOrder = _data["displayOrder"];
            this.status = _data["status"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.parentCategory = _data["parentCategory"] ? Category.fromJS(_data["parentCategory"]) : undefined as any;
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(Category.fromJS(item));
            }
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : undefined as any;
            this.updatedByUser = _data["updatedByUser"] ? User.fromJS(_data["updatedByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["parentCategoryId"] = this.parentCategoryId;
        data["displayOrder"] = this.displayOrder;
        data["status"] = this.status;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["parentCategory"] = this.parentCategory ? this.parentCategory.toJSON() : undefined as any;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item ? item.toJSON() : undefined as any);
        }
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : undefined as any;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface ICategory {
    categoryId?: string;
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    parentCategoryId?: string | undefined;
    displayOrder?: number;
    status?: number;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    parentCategory?: Category | undefined;
    subCategories?: Category[];
    products?: Product[];
    createdByUser?: User;
    updatedByUser?: User | undefined;
}

export class Brand implements IBrand {
    brandId?: string;
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;
    logoUrl?: string | undefined;
    website?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    products?: Product[];
    createdByUser?: User;
    updatedByUser?: User | undefined;

    constructor(data?: IBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.website = _data["website"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : undefined as any;
            this.updatedByUser = _data["updatedByUser"] ? User.fromJS(_data["updatedByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): Brand {
        data = typeof data === 'object' ? data : {};
        let result = new Brand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item ? item.toJSON() : undefined as any);
        }
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : undefined as any;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IBrand {
    brandId?: string;
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
    logoUrl?: string | undefined;
    website?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    products?: Product[];
    createdByUser?: User;
    updatedByUser?: User | undefined;
}

export class ProductImage implements IProductImage {
    imageId?: string;
    productId?: string;
    imageUrl!: string;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
    createdAt?: Date;
    product?: Product;

    constructor(data?: IProductImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
        }
    }

    static fromJS(data: any): ProductImage {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        return data;
    }
}

export interface IProductImage {
    imageId?: string;
    productId?: string;
    imageUrl: string;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
    createdAt?: Date;
    product?: Product;
}

export class ProductAttributeValue implements IProductAttributeValue {
    valueId?: string;
    productId?: string;
    attributeId?: string;
    value!: string;
    createdAt?: Date;
    product?: Product;
    attribute?: ProductAttribute;

    constructor(data?: IProductAttributeValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueId = _data["valueId"];
            this.productId = _data["productId"];
            this.attributeId = _data["attributeId"];
            this.value = _data["value"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.attribute = _data["attribute"] ? ProductAttribute.fromJS(_data["attribute"]) : undefined as any;
        }
    }

    static fromJS(data: any): ProductAttributeValue {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueId"] = this.valueId;
        data["productId"] = this.productId;
        data["attributeId"] = this.attributeId;
        data["value"] = this.value;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["attribute"] = this.attribute ? this.attribute.toJSON() : undefined as any;
        return data;
    }
}

export interface IProductAttributeValue {
    valueId?: string;
    productId?: string;
    attributeId?: string;
    value: string;
    createdAt?: Date;
    product?: Product;
    attribute?: ProductAttribute;
}

export class ProductAttribute implements IProductAttribute {
    attributeId?: string;
    name!: string;
    displayName!: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    productAttributeValues?: ProductAttributeValue[];

    constructor(data?: IProductAttribute) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.attributeType = _data["attributeType"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["productAttributeValues"])) {
                this.productAttributeValues = [] as any;
                for (let item of _data["productAttributeValues"])
                    this.productAttributeValues!.push(ProductAttributeValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductAttribute {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttribute();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["attributeType"] = this.attributeType;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.productAttributeValues)) {
            data["productAttributeValues"] = [];
            for (let item of this.productAttributeValues)
                data["productAttributeValues"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProductAttribute {
    attributeId?: string;
    name: string;
    displayName: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    productAttributeValues?: ProductAttributeValue[];
}

export class ProductVariant implements IProductVariant {
    variantId?: string;
    productId?: string;
    sku!: string;
    name!: string;
    price!: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    imageUrl?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    product?: Product;
    variantAttributeValues?: ProductAttributeValue[];

    constructor(data?: IProductVariant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.variantId = _data["variantId"];
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.imageUrl = _data["imageUrl"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            if (Array.isArray(_data["variantAttributeValues"])) {
                this.variantAttributeValues = [] as any;
                for (let item of _data["variantAttributeValues"])
                    this.variantAttributeValues!.push(ProductAttributeValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductVariant {
        data = typeof data === 'object' ? data : {};
        let result = new ProductVariant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variantId"] = this.variantId;
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["imageUrl"] = this.imageUrl;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        if (Array.isArray(this.variantAttributeValues)) {
            data["variantAttributeValues"] = [];
            for (let item of this.variantAttributeValues)
                data["variantAttributeValues"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProductVariant {
    variantId?: string;
    productId?: string;
    sku: string;
    name: string;
    price: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    imageUrl?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    product?: Product;
    variantAttributeValues?: ProductAttributeValue[];
}

export class ProductTagAssignment implements IProductTagAssignment {
    productId?: string;
    tagId?: string;
    product?: Product;
    productTag?: ProductTag;

    constructor(data?: IProductTagAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.tagId = _data["tagId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.productTag = _data["productTag"] ? ProductTag.fromJS(_data["productTag"]) : undefined as any;
        }
    }

    static fromJS(data: any): ProductTagAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["tagId"] = this.tagId;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["productTag"] = this.productTag ? this.productTag.toJSON() : undefined as any;
        return data;
    }
}

export interface IProductTagAssignment {
    productId?: string;
    tagId?: string;
    product?: Product;
    productTag?: ProductTag;
}

export class ProductTag implements IProductTag {
    tagId?: string;
    name!: string;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    productTagAssignments?: ProductTagAssignment[];

    constructor(data?: IProductTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            if (Array.isArray(_data["productTagAssignments"])) {
                this.productTagAssignments = [] as any;
                for (let item of _data["productTagAssignments"])
                    this.productTagAssignments!.push(ProductTagAssignment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductTag {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        if (Array.isArray(this.productTagAssignments)) {
            data["productTagAssignments"] = [];
            for (let item of this.productTagAssignments)
                data["productTagAssignments"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProductTag {
    tagId?: string;
    name: string;
    slug?: string | undefined;
    description?: string | undefined;
    createdAt?: Date;
    productTagAssignments?: ProductTagAssignment[];
}

export class ProductQuestion implements IProductQuestion {
    questionId?: string;
    productId?: string;
    userId?: string | undefined;
    question!: string;
    answer?: string | undefined;
    answeredBy?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    product?: Product;
    user?: User | undefined;
    answeredByUser?: User | undefined;

    constructor(data?: IProductQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.productId = _data["productId"];
            this.userId = _data["userId"];
            this.question = _data["question"];
            this.answer = _data["answer"];
            this.answeredBy = _data["answeredBy"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.answeredByUser = _data["answeredByUser"] ? User.fromJS(_data["answeredByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): ProductQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new ProductQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["productId"] = this.productId;
        data["userId"] = this.userId;
        data["question"] = this.question;
        data["answer"] = this.answer;
        data["answeredBy"] = this.answeredBy;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["answeredByUser"] = this.answeredByUser ? this.answeredByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IProductQuestion {
    questionId?: string;
    productId?: string;
    userId?: string | undefined;
    question: string;
    answer?: string | undefined;
    answeredBy?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    product?: Product;
    user?: User | undefined;
    answeredByUser?: User | undefined;
}

export class ProductReview implements IProductReview {
    reviewId?: string;
    productId?: string;
    userId?: string;
    orderId?: string | undefined;
    rating!: number;
    title?: string | undefined;
    content?: string | undefined;
    isVerifiedPurchase?: boolean;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    product?: Product;
    user?: User;
    order?: Order | undefined;
    reviewImages?: ReviewImage[];
    reviewVotes?: ReviewVote[];
    reviewReports?: ReviewReport[];

    constructor(data?: IProductReview) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reviewId = _data["reviewId"];
            this.productId = _data["productId"];
            this.userId = _data["userId"];
            this.orderId = _data["orderId"];
            this.rating = _data["rating"];
            this.title = _data["title"];
            this.content = _data["content"];
            this.isVerifiedPurchase = _data["isVerifiedPurchase"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
            if (Array.isArray(_data["reviewImages"])) {
                this.reviewImages = [] as any;
                for (let item of _data["reviewImages"])
                    this.reviewImages!.push(ReviewImage.fromJS(item));
            }
            if (Array.isArray(_data["reviewVotes"])) {
                this.reviewVotes = [] as any;
                for (let item of _data["reviewVotes"])
                    this.reviewVotes!.push(ReviewVote.fromJS(item));
            }
            if (Array.isArray(_data["reviewReports"])) {
                this.reviewReports = [] as any;
                for (let item of _data["reviewReports"])
                    this.reviewReports!.push(ReviewReport.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductReview {
        data = typeof data === 'object' ? data : {};
        let result = new ProductReview();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reviewId"] = this.reviewId;
        data["productId"] = this.productId;
        data["userId"] = this.userId;
        data["orderId"] = this.orderId;
        data["rating"] = this.rating;
        data["title"] = this.title;
        data["content"] = this.content;
        data["isVerifiedPurchase"] = this.isVerifiedPurchase;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        if (Array.isArray(this.reviewImages)) {
            data["reviewImages"] = [];
            for (let item of this.reviewImages)
                data["reviewImages"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.reviewVotes)) {
            data["reviewVotes"] = [];
            for (let item of this.reviewVotes)
                data["reviewVotes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.reviewReports)) {
            data["reviewReports"] = [];
            for (let item of this.reviewReports)
                data["reviewReports"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProductReview {
    reviewId?: string;
    productId?: string;
    userId?: string;
    orderId?: string | undefined;
    rating: number;
    title?: string | undefined;
    content?: string | undefined;
    isVerifiedPurchase?: boolean;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    product?: Product;
    user?: User;
    order?: Order | undefined;
    reviewImages?: ReviewImage[];
    reviewVotes?: ReviewVote[];
    reviewReports?: ReviewReport[];
}

export class Order implements IOrder {
    orderId?: string;
    orderNumber!: string;
    userId?: string;
    orderDate?: Date;
    subTotal!: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount!: number;
    status?: number;
    paymentStatus?: number;
    paymentMethod?: number;
    shippingFirstName!: string;
    shippingLastName!: string;
    shippingEmail!: string;
    shippingPhone?: string | undefined;
    shippingAddress!: string;
    shippingCity!: string;
    shippingState!: string;
    shippingZipCode!: string;
    shippingCountry!: string;
    billingFirstName!: string;
    billingLastName!: string;
    billingEmail!: string;
    billingPhone?: string | undefined;
    billingAddress!: string;
    billingCity!: string;
    billingState!: string;
    billingZipCode!: string;
    billingCountry!: string;
    notes?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    deliveredAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string | undefined;
    user?: User;
    createdByUser?: User | undefined;
    orderItems?: OrderItem[];
    orderStatusHistories?: OrderStatusHistory[];
    orderPayments?: OrderPayment[];
    orderShipments?: OrderShipment[];
    orderRefunds?: OrderRefund[];

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.userId = _data["userId"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : undefined as any;
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.status = _data["status"];
            this.paymentStatus = _data["paymentStatus"];
            this.paymentMethod = _data["paymentMethod"];
            this.shippingFirstName = _data["shippingFirstName"];
            this.shippingLastName = _data["shippingLastName"];
            this.shippingEmail = _data["shippingEmail"];
            this.shippingPhone = _data["shippingPhone"];
            this.shippingAddress = _data["shippingAddress"];
            this.shippingCity = _data["shippingCity"];
            this.shippingState = _data["shippingState"];
            this.shippingZipCode = _data["shippingZipCode"];
            this.shippingCountry = _data["shippingCountry"];
            this.billingFirstName = _data["billingFirstName"];
            this.billingLastName = _data["billingLastName"];
            this.billingEmail = _data["billingEmail"];
            this.billingPhone = _data["billingPhone"];
            this.billingAddress = _data["billingAddress"];
            this.billingCity = _data["billingCity"];
            this.billingState = _data["billingState"];
            this.billingZipCode = _data["billingZipCode"];
            this.billingCountry = _data["billingCountry"];
            this.notes = _data["notes"];
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"] ? new Date(_data["estimatedDeliveryDate"].toString()) : undefined as any;
            this.deliveredAt = _data["deliveredAt"] ? new Date(_data["deliveredAt"].toString()) : undefined as any;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : undefined as any;
            if (Array.isArray(_data["orderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["orderItems"])
                    this.orderItems!.push(OrderItem.fromJS(item));
            }
            if (Array.isArray(_data["orderStatusHistories"])) {
                this.orderStatusHistories = [] as any;
                for (let item of _data["orderStatusHistories"])
                    this.orderStatusHistories!.push(OrderStatusHistory.fromJS(item));
            }
            if (Array.isArray(_data["orderPayments"])) {
                this.orderPayments = [] as any;
                for (let item of _data["orderPayments"])
                    this.orderPayments!.push(OrderPayment.fromJS(item));
            }
            if (Array.isArray(_data["orderShipments"])) {
                this.orderShipments = [] as any;
                for (let item of _data["orderShipments"])
                    this.orderShipments!.push(OrderShipment.fromJS(item));
            }
            if (Array.isArray(_data["orderRefunds"])) {
                this.orderRefunds = [] as any;
                for (let item of _data["orderRefunds"])
                    this.orderRefunds!.push(OrderRefund.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["userId"] = this.userId;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : undefined as any;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["status"] = this.status;
        data["paymentStatus"] = this.paymentStatus;
        data["paymentMethod"] = this.paymentMethod;
        data["shippingFirstName"] = this.shippingFirstName;
        data["shippingLastName"] = this.shippingLastName;
        data["shippingEmail"] = this.shippingEmail;
        data["shippingPhone"] = this.shippingPhone;
        data["shippingAddress"] = this.shippingAddress;
        data["shippingCity"] = this.shippingCity;
        data["shippingState"] = this.shippingState;
        data["shippingZipCode"] = this.shippingZipCode;
        data["shippingCountry"] = this.shippingCountry;
        data["billingFirstName"] = this.billingFirstName;
        data["billingLastName"] = this.billingLastName;
        data["billingEmail"] = this.billingEmail;
        data["billingPhone"] = this.billingPhone;
        data["billingAddress"] = this.billingAddress;
        data["billingCity"] = this.billingCity;
        data["billingState"] = this.billingState;
        data["billingZipCode"] = this.billingZipCode;
        data["billingCountry"] = this.billingCountry;
        data["notes"] = this.notes;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : undefined as any;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : undefined as any;
        if (Array.isArray(this.orderItems)) {
            data["orderItems"] = [];
            for (let item of this.orderItems)
                data["orderItems"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.orderStatusHistories)) {
            data["orderStatusHistories"] = [];
            for (let item of this.orderStatusHistories)
                data["orderStatusHistories"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.orderPayments)) {
            data["orderPayments"] = [];
            for (let item of this.orderPayments)
                data["orderPayments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.orderShipments)) {
            data["orderShipments"] = [];
            for (let item of this.orderShipments)
                data["orderShipments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.orderRefunds)) {
            data["orderRefunds"] = [];
            for (let item of this.orderRefunds)
                data["orderRefunds"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrder {
    orderId?: string;
    orderNumber: string;
    userId?: string;
    orderDate?: Date;
    subTotal: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount: number;
    status?: number;
    paymentStatus?: number;
    paymentMethod?: number;
    shippingFirstName: string;
    shippingLastName: string;
    shippingEmail: string;
    shippingPhone?: string | undefined;
    shippingAddress: string;
    shippingCity: string;
    shippingState: string;
    shippingZipCode: string;
    shippingCountry: string;
    billingFirstName: string;
    billingLastName: string;
    billingEmail: string;
    billingPhone?: string | undefined;
    billingAddress: string;
    billingCity: string;
    billingState: string;
    billingZipCode: string;
    billingCountry: string;
    notes?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    deliveredAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string | undefined;
    user?: User;
    createdByUser?: User | undefined;
    orderItems?: OrderItem[];
    orderStatusHistories?: OrderStatusHistory[];
    orderPayments?: OrderPayment[];
    orderShipments?: OrderShipment[];
    orderRefunds?: OrderRefund[];
}

export class OrderItem implements IOrderItem {
    orderItemId?: string;
    orderId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    productName!: string;
    productSku!: string;
    quantity?: number;
    unitPrice!: number;
    totalPrice!: number;
    order?: Order;
    product?: Product;
    productVariant?: ProductVariant | undefined;
    shipmentItems?: ShipmentItem[];

    constructor(data?: IOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderItemId = _data["orderItemId"];
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.quantity = _data["quantity"];
            this.unitPrice = _data["unitPrice"];
            this.totalPrice = _data["totalPrice"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.productVariant = _data["productVariant"] ? ProductVariant.fromJS(_data["productVariant"]) : undefined as any;
            if (Array.isArray(_data["shipmentItems"])) {
                this.shipmentItems = [] as any;
                for (let item of _data["shipmentItems"])
                    this.shipmentItems!.push(ShipmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["totalPrice"] = this.totalPrice;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["productVariant"] = this.productVariant ? this.productVariant.toJSON() : undefined as any;
        if (Array.isArray(this.shipmentItems)) {
            data["shipmentItems"] = [];
            for (let item of this.shipmentItems)
                data["shipmentItems"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderItem {
    orderItemId?: string;
    orderId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    productName: string;
    productSku: string;
    quantity?: number;
    unitPrice: number;
    totalPrice: number;
    order?: Order;
    product?: Product;
    productVariant?: ProductVariant | undefined;
    shipmentItems?: ShipmentItem[];
}

export class ShipmentItem implements IShipmentItem {
    shipmentItemId?: string;
    shipmentId?: string;
    orderItemId?: string;
    quantity?: number;
    orderShipment?: OrderShipment;
    orderItem?: OrderItem;

    constructor(data?: IShipmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentItemId = _data["shipmentItemId"];
            this.shipmentId = _data["shipmentId"];
            this.orderItemId = _data["orderItemId"];
            this.quantity = _data["quantity"];
            this.orderShipment = _data["orderShipment"] ? OrderShipment.fromJS(_data["orderShipment"]) : undefined as any;
            this.orderItem = _data["orderItem"] ? OrderItem.fromJS(_data["orderItem"]) : undefined as any;
        }
    }

    static fromJS(data: any): ShipmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentItemId"] = this.shipmentItemId;
        data["shipmentId"] = this.shipmentId;
        data["orderItemId"] = this.orderItemId;
        data["quantity"] = this.quantity;
        data["orderShipment"] = this.orderShipment ? this.orderShipment.toJSON() : undefined as any;
        data["orderItem"] = this.orderItem ? this.orderItem.toJSON() : undefined as any;
        return data;
    }
}

export interface IShipmentItem {
    shipmentItemId?: string;
    shipmentId?: string;
    orderItemId?: string;
    quantity?: number;
    orderShipment?: OrderShipment;
    orderItem?: OrderItem;
}

export class OrderShipment implements IOrderShipment {
    shipmentId?: string;
    orderId?: string;
    shipmentNumber?: string | undefined;
    carrierId?: string | undefined;
    trackingNumber?: string | undefined;
    shippedAt?: Date | undefined;
    deliveredAt?: Date | undefined;
    status?: number;
    shippingCost?: number | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    order?: Order;
    shipmentCarrier?: ShipmentCarrier | undefined;
    shipmentItems?: ShipmentItem[];

    constructor(data?: IOrderShipment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentId = _data["shipmentId"];
            this.orderId = _data["orderId"];
            this.shipmentNumber = _data["shipmentNumber"];
            this.carrierId = _data["carrierId"];
            this.trackingNumber = _data["trackingNumber"];
            this.shippedAt = _data["shippedAt"] ? new Date(_data["shippedAt"].toString()) : undefined as any;
            this.deliveredAt = _data["deliveredAt"] ? new Date(_data["deliveredAt"].toString()) : undefined as any;
            this.status = _data["status"];
            this.shippingCost = _data["shippingCost"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
            this.shipmentCarrier = _data["shipmentCarrier"] ? ShipmentCarrier.fromJS(_data["shipmentCarrier"]) : undefined as any;
            if (Array.isArray(_data["shipmentItems"])) {
                this.shipmentItems = [] as any;
                for (let item of _data["shipmentItems"])
                    this.shipmentItems!.push(ShipmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderShipment {
        data = typeof data === 'object' ? data : {};
        let result = new OrderShipment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentId"] = this.shipmentId;
        data["orderId"] = this.orderId;
        data["shipmentNumber"] = this.shipmentNumber;
        data["carrierId"] = this.carrierId;
        data["trackingNumber"] = this.trackingNumber;
        data["shippedAt"] = this.shippedAt ? this.shippedAt.toISOString() : undefined as any;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : undefined as any;
        data["status"] = this.status;
        data["shippingCost"] = this.shippingCost;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        data["shipmentCarrier"] = this.shipmentCarrier ? this.shipmentCarrier.toJSON() : undefined as any;
        if (Array.isArray(this.shipmentItems)) {
            data["shipmentItems"] = [];
            for (let item of this.shipmentItems)
                data["shipmentItems"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderShipment {
    shipmentId?: string;
    orderId?: string;
    shipmentNumber?: string | undefined;
    carrierId?: string | undefined;
    trackingNumber?: string | undefined;
    shippedAt?: Date | undefined;
    deliveredAt?: Date | undefined;
    status?: number;
    shippingCost?: number | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    order?: Order;
    shipmentCarrier?: ShipmentCarrier | undefined;
    shipmentItems?: ShipmentItem[];
}

export class ShipmentCarrier implements IShipmentCarrier {
    carrierId?: string;
    name!: string;
    code?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    createdAt?: Date;
    orderShipments?: OrderShipment[];

    constructor(data?: IShipmentCarrier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.carrierId = _data["carrierId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            if (Array.isArray(_data["orderShipments"])) {
                this.orderShipments = [] as any;
                for (let item of _data["orderShipments"])
                    this.orderShipments!.push(OrderShipment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShipmentCarrier {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentCarrier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carrierId"] = this.carrierId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        if (Array.isArray(this.orderShipments)) {
            data["orderShipments"] = [];
            for (let item of this.orderShipments)
                data["orderShipments"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IShipmentCarrier {
    carrierId?: string;
    name: string;
    code?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    createdAt?: Date;
    orderShipments?: OrderShipment[];
}

export class OrderStatusHistory implements IOrderStatusHistory {
    historyId?: string;
    orderId?: string;
    fromStatus?: number | undefined;
    toStatus!: number;
    comment?: string | undefined;
    createdAt?: Date;
    createdBy?: string;
    order?: Order;
    createdByUser?: User;
    oldStatus?: number | undefined;
    newStatus?: number;
    changedByUser?: User | undefined;

    constructor(data?: IOrderStatusHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.historyId = _data["historyId"];
            this.orderId = _data["orderId"];
            this.fromStatus = _data["fromStatus"];
            this.toStatus = _data["toStatus"];
            this.comment = _data["comment"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : undefined as any;
            this.oldStatus = _data["oldStatus"];
            this.newStatus = _data["newStatus"];
            this.changedByUser = _data["changedByUser"] ? User.fromJS(_data["changedByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): OrderStatusHistory {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatusHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["historyId"] = this.historyId;
        data["orderId"] = this.orderId;
        data["fromStatus"] = this.fromStatus;
        data["toStatus"] = this.toStatus;
        data["comment"] = this.comment;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : undefined as any;
        data["oldStatus"] = this.oldStatus;
        data["newStatus"] = this.newStatus;
        data["changedByUser"] = this.changedByUser ? this.changedByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IOrderStatusHistory {
    historyId?: string;
    orderId?: string;
    fromStatus?: number | undefined;
    toStatus: number;
    comment?: string | undefined;
    createdAt?: Date;
    createdBy?: string;
    order?: Order;
    createdByUser?: User;
    oldStatus?: number | undefined;
    newStatus?: number;
    changedByUser?: User | undefined;
}

export class OrderPayment implements IOrderPayment {
    paymentId?: string;
    orderId?: string;
    paymentMethod?: number;
    transactionId?: string | undefined;
    gatewayResponse?: string | undefined;
    amount!: number;
    currency!: string;
    status?: number;
    paidAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    processedBy?: string | undefined;
    order?: Order;
    processedByUser?: User | undefined;
    orderRefunds?: OrderRefund[];

    constructor(data?: IOrderPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.orderId = _data["orderId"];
            this.paymentMethod = _data["paymentMethod"];
            this.transactionId = _data["transactionId"];
            this.gatewayResponse = _data["gatewayResponse"];
            this.amount = _data["amount"];
            this.currency = _data["currency"];
            this.status = _data["status"];
            this.paidAt = _data["paidAt"] ? new Date(_data["paidAt"].toString()) : undefined as any;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.processedBy = _data["processedBy"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
            this.processedByUser = _data["processedByUser"] ? User.fromJS(_data["processedByUser"]) : undefined as any;
            if (Array.isArray(_data["orderRefunds"])) {
                this.orderRefunds = [] as any;
                for (let item of _data["orderRefunds"])
                    this.orderRefunds!.push(OrderRefund.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderPayment {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["orderId"] = this.orderId;
        data["paymentMethod"] = this.paymentMethod;
        data["transactionId"] = this.transactionId;
        data["gatewayResponse"] = this.gatewayResponse;
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        data["status"] = this.status;
        data["paidAt"] = this.paidAt ? this.paidAt.toISOString() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["processedBy"] = this.processedBy;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        data["processedByUser"] = this.processedByUser ? this.processedByUser.toJSON() : undefined as any;
        if (Array.isArray(this.orderRefunds)) {
            data["orderRefunds"] = [];
            for (let item of this.orderRefunds)
                data["orderRefunds"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderPayment {
    paymentId?: string;
    orderId?: string;
    paymentMethod?: number;
    transactionId?: string | undefined;
    gatewayResponse?: string | undefined;
    amount: number;
    currency: string;
    status?: number;
    paidAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    processedBy?: string | undefined;
    order?: Order;
    processedByUser?: User | undefined;
    orderRefunds?: OrderRefund[];
}

export class OrderRefund implements IOrderRefund {
    refundId?: string;
    orderId?: string;
    paymentId?: string | undefined;
    amount!: number;
    reason?: string | undefined;
    status?: number;
    requestedAt?: Date;
    processedAt?: Date | undefined;
    processedBy?: string | undefined;
    requestedBy?: string | undefined;
    order?: Order;
    orderPayment?: OrderPayment | undefined;
    processedByUser?: User | undefined;
    requestedByUser?: User | undefined;

    constructor(data?: IOrderRefund) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refundId = _data["refundId"];
            this.orderId = _data["orderId"];
            this.paymentId = _data["paymentId"];
            this.amount = _data["amount"];
            this.reason = _data["reason"];
            this.status = _data["status"];
            this.requestedAt = _data["requestedAt"] ? new Date(_data["requestedAt"].toString()) : undefined as any;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : undefined as any;
            this.processedBy = _data["processedBy"];
            this.requestedBy = _data["requestedBy"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
            this.orderPayment = _data["orderPayment"] ? OrderPayment.fromJS(_data["orderPayment"]) : undefined as any;
            this.processedByUser = _data["processedByUser"] ? User.fromJS(_data["processedByUser"]) : undefined as any;
            this.requestedByUser = _data["requestedByUser"] ? User.fromJS(_data["requestedByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): OrderRefund {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRefund();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refundId"] = this.refundId;
        data["orderId"] = this.orderId;
        data["paymentId"] = this.paymentId;
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        data["status"] = this.status;
        data["requestedAt"] = this.requestedAt ? this.requestedAt.toISOString() : undefined as any;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : undefined as any;
        data["processedBy"] = this.processedBy;
        data["requestedBy"] = this.requestedBy;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        data["orderPayment"] = this.orderPayment ? this.orderPayment.toJSON() : undefined as any;
        data["processedByUser"] = this.processedByUser ? this.processedByUser.toJSON() : undefined as any;
        data["requestedByUser"] = this.requestedByUser ? this.requestedByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IOrderRefund {
    refundId?: string;
    orderId?: string;
    paymentId?: string | undefined;
    amount: number;
    reason?: string | undefined;
    status?: number;
    requestedAt?: Date;
    processedAt?: Date | undefined;
    processedBy?: string | undefined;
    requestedBy?: string | undefined;
    order?: Order;
    orderPayment?: OrderPayment | undefined;
    processedByUser?: User | undefined;
    requestedByUser?: User | undefined;
}

export class ReviewImage implements IReviewImage {
    imageId?: string;
    reviewId?: string;
    imageUrl!: string;
    createdAt?: Date;
    productReview?: ProductReview;

    constructor(data?: IReviewImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
            this.reviewId = _data["reviewId"];
            this.imageUrl = _data["imageUrl"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.productReview = _data["productReview"] ? ProductReview.fromJS(_data["productReview"]) : undefined as any;
        }
    }

    static fromJS(data: any): ReviewImage {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        data["reviewId"] = this.reviewId;
        data["imageUrl"] = this.imageUrl;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["productReview"] = this.productReview ? this.productReview.toJSON() : undefined as any;
        return data;
    }
}

export interface IReviewImage {
    imageId?: string;
    reviewId?: string;
    imageUrl: string;
    createdAt?: Date;
    productReview?: ProductReview;
}

export class ReviewVote implements IReviewVote {
    voteId?: string;
    reviewId?: string;
    userId?: string;
    helpful?: boolean;
    createdAt?: Date;
    productReview?: ProductReview;
    user?: User;

    constructor(data?: IReviewVote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.voteId = _data["voteId"];
            this.reviewId = _data["reviewId"];
            this.userId = _data["userId"];
            this.helpful = _data["helpful"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.productReview = _data["productReview"] ? ProductReview.fromJS(_data["productReview"]) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): ReviewVote {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewVote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["voteId"] = this.voteId;
        data["reviewId"] = this.reviewId;
        data["userId"] = this.userId;
        data["helpful"] = this.helpful;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["productReview"] = this.productReview ? this.productReview.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IReviewVote {
    voteId?: string;
    reviewId?: string;
    userId?: string;
    helpful?: boolean;
    createdAt?: Date;
    productReview?: ProductReview;
    user?: User;
}

export class ReviewReport implements IReviewReport {
    reportId?: string;
    reviewId?: string;
    userId?: string;
    reason?: string | undefined;
    createdAt?: Date;
    processed?: boolean;
    processedAt?: Date | undefined;
    processedBy?: string | undefined;
    productReview?: ProductReview;
    user?: User;
    processedByUser?: User | undefined;

    constructor(data?: IReviewReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportId = _data["reportId"];
            this.reviewId = _data["reviewId"];
            this.userId = _data["userId"];
            this.reason = _data["reason"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.processed = _data["processed"];
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : undefined as any;
            this.processedBy = _data["processedBy"];
            this.productReview = _data["productReview"] ? ProductReview.fromJS(_data["productReview"]) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.processedByUser = _data["processedByUser"] ? User.fromJS(_data["processedByUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): ReviewReport {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewReport();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportId"] = this.reportId;
        data["reviewId"] = this.reviewId;
        data["userId"] = this.userId;
        data["reason"] = this.reason;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["processed"] = this.processed;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : undefined as any;
        data["processedBy"] = this.processedBy;
        data["productReview"] = this.productReview ? this.productReview.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["processedByUser"] = this.processedByUser ? this.processedByUser.toJSON() : undefined as any;
        return data;
    }
}

export interface IReviewReport {
    reportId?: string;
    reviewId?: string;
    userId?: string;
    reason?: string | undefined;
    createdAt?: Date;
    processed?: boolean;
    processedAt?: Date | undefined;
    processedBy?: string | undefined;
    productReview?: ProductReview;
    user?: User;
    processedByUser?: User | undefined;
}

export class Wishlist implements IWishlist {
    wishlistId?: string;
    userId?: string;
    name!: string;
    isDefault?: boolean;
    isPublic?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    user?: User;
    wishlistItems?: WishlistItem[];

    constructor(data?: IWishlist) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wishlistId = _data["wishlistId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.isPublic = _data["isPublic"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            if (Array.isArray(_data["wishlistItems"])) {
                this.wishlistItems = [] as any;
                for (let item of _data["wishlistItems"])
                    this.wishlistItems!.push(WishlistItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Wishlist {
        data = typeof data === 'object' ? data : {};
        let result = new Wishlist();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wishlistId"] = this.wishlistId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["isPublic"] = this.isPublic;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        if (Array.isArray(this.wishlistItems)) {
            data["wishlistItems"] = [];
            for (let item of this.wishlistItems)
                data["wishlistItems"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IWishlist {
    wishlistId?: string;
    userId?: string;
    name: string;
    isDefault?: boolean;
    isPublic?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    user?: User;
    wishlistItems?: WishlistItem[];
}

export class WishlistItem implements IWishlistItem {
    wishlistItemId?: string;
    wishlistId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    createdAt?: Date;
    wishlist?: Wishlist;
    product?: Product;
    productVariant?: ProductVariant | undefined;

    constructor(data?: IWishlistItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wishlistItemId = _data["wishlistItemId"];
            this.wishlistId = _data["wishlistId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.wishlist = _data["wishlist"] ? Wishlist.fromJS(_data["wishlist"]) : undefined as any;
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : undefined as any;
            this.productVariant = _data["productVariant"] ? ProductVariant.fromJS(_data["productVariant"]) : undefined as any;
        }
    }

    static fromJS(data: any): WishlistItem {
        data = typeof data === 'object' ? data : {};
        let result = new WishlistItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wishlistItemId"] = this.wishlistItemId;
        data["wishlistId"] = this.wishlistId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["wishlist"] = this.wishlist ? this.wishlist.toJSON() : undefined as any;
        data["product"] = this.product ? this.product.toJSON() : undefined as any;
        data["productVariant"] = this.productVariant ? this.productVariant.toJSON() : undefined as any;
        return data;
    }
}

export interface IWishlistItem {
    wishlistItemId?: string;
    wishlistId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    createdAt?: Date;
    wishlist?: Wishlist;
    product?: Product;
    productVariant?: ProductVariant | undefined;
}

export class AbandonedCart implements IAbandonedCart {
    abandonedId?: string;
    cartId?: string;
    userId?: string | undefined;
    abandonedAt?: Date;
    notified?: boolean;
    shoppingCart?: ShoppingCart;
    user?: User | undefined;

    constructor(data?: IAbandonedCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.abandonedId = _data["abandonedId"];
            this.cartId = _data["cartId"];
            this.userId = _data["userId"];
            this.abandonedAt = _data["abandonedAt"] ? new Date(_data["abandonedAt"].toString()) : undefined as any;
            this.notified = _data["notified"];
            this.shoppingCart = _data["shoppingCart"] ? ShoppingCart.fromJS(_data["shoppingCart"]) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): AbandonedCart {
        data = typeof data === 'object' ? data : {};
        let result = new AbandonedCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["abandonedId"] = this.abandonedId;
        data["cartId"] = this.cartId;
        data["userId"] = this.userId;
        data["abandonedAt"] = this.abandonedAt ? this.abandonedAt.toISOString() : undefined as any;
        data["notified"] = this.notified;
        data["shoppingCart"] = this.shoppingCart ? this.shoppingCart.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IAbandonedCart {
    abandonedId?: string;
    cartId?: string;
    userId?: string | undefined;
    abandonedAt?: Date;
    notified?: boolean;
    shoppingCart?: ShoppingCart;
    user?: User | undefined;
}

export class CouponUsage implements ICouponUsage {
    usageId?: string;
    couponId?: string;
    userId?: string;
    orderId?: string;
    discountAmount!: number;
    usedAt?: Date;
    coupon?: Coupon;
    user?: User;
    order?: Order;

    constructor(data?: ICouponUsage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usageId = _data["usageId"];
            this.couponId = _data["couponId"];
            this.userId = _data["userId"];
            this.orderId = _data["orderId"];
            this.discountAmount = _data["discountAmount"];
            this.usedAt = _data["usedAt"] ? new Date(_data["usedAt"].toString()) : undefined as any;
            this.coupon = _data["coupon"] ? Coupon.fromJS(_data["coupon"]) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : undefined as any;
        }
    }

    static fromJS(data: any): CouponUsage {
        data = typeof data === 'object' ? data : {};
        let result = new CouponUsage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageId"] = this.usageId;
        data["couponId"] = this.couponId;
        data["userId"] = this.userId;
        data["orderId"] = this.orderId;
        data["discountAmount"] = this.discountAmount;
        data["usedAt"] = this.usedAt ? this.usedAt.toISOString() : undefined as any;
        data["coupon"] = this.coupon ? this.coupon.toJSON() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        data["order"] = this.order ? this.order.toJSON() : undefined as any;
        return data;
    }
}

export interface ICouponUsage {
    usageId?: string;
    couponId?: string;
    userId?: string;
    orderId?: string;
    discountAmount: number;
    usedAt?: Date;
    coupon?: Coupon;
    user?: User;
    order?: Order;
}

export class Coupon implements ICoupon {
    couponId?: string;
    code!: string;
    name!: string;
    description?: string | undefined;
    discountType?: number;
    discountValue!: number;
    minOrderAmount?: number | undefined;
    maxDiscountAmount?: number | undefined;
    usageLimit?: number | undefined;
    usageCount?: number;
    userUsageLimit?: number;
    validFrom?: Date;
    validTo?: Date;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    createdByUser?: User;
    updatedByUser?: User | undefined;
    couponUsages?: CouponUsage[];

    constructor(data?: ICoupon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponId = _data["couponId"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.discountType = _data["discountType"];
            this.discountValue = _data["discountValue"];
            this.minOrderAmount = _data["minOrderAmount"];
            this.maxDiscountAmount = _data["maxDiscountAmount"];
            this.usageLimit = _data["usageLimit"];
            this.usageCount = _data["usageCount"];
            this.userUsageLimit = _data["userUsageLimit"];
            this.validFrom = _data["validFrom"] ? new Date(_data["validFrom"].toString()) : undefined as any;
            this.validTo = _data["validTo"] ? new Date(_data["validTo"].toString()) : undefined as any;
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.updatedBy = _data["updatedBy"];
            this.createdByUser = _data["createdByUser"] ? User.fromJS(_data["createdByUser"]) : undefined as any;
            this.updatedByUser = _data["updatedByUser"] ? User.fromJS(_data["updatedByUser"]) : undefined as any;
            if (Array.isArray(_data["couponUsages"])) {
                this.couponUsages = [] as any;
                for (let item of _data["couponUsages"])
                    this.couponUsages!.push(CouponUsage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Coupon {
        data = typeof data === 'object' ? data : {};
        let result = new Coupon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponId"] = this.couponId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["description"] = this.description;
        data["discountType"] = this.discountType;
        data["discountValue"] = this.discountValue;
        data["minOrderAmount"] = this.minOrderAmount;
        data["maxDiscountAmount"] = this.maxDiscountAmount;
        data["usageLimit"] = this.usageLimit;
        data["usageCount"] = this.usageCount;
        data["userUsageLimit"] = this.userUsageLimit;
        data["validFrom"] = this.validFrom ? this.validFrom.toISOString() : undefined as any;
        data["validTo"] = this.validTo ? this.validTo.toISOString() : undefined as any;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["updatedBy"] = this.updatedBy;
        data["createdByUser"] = this.createdByUser ? this.createdByUser.toJSON() : undefined as any;
        data["updatedByUser"] = this.updatedByUser ? this.updatedByUser.toJSON() : undefined as any;
        if (Array.isArray(this.couponUsages)) {
            data["couponUsages"] = [];
            for (let item of this.couponUsages)
                data["couponUsages"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICoupon {
    couponId?: string;
    code: string;
    name: string;
    description?: string | undefined;
    discountType?: number;
    discountValue: number;
    minOrderAmount?: number | undefined;
    maxDiscountAmount?: number | undefined;
    usageLimit?: number | undefined;
    usageCount?: number;
    userUsageLimit?: number;
    validFrom?: Date;
    validTo?: Date;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    createdBy?: string;
    updatedBy?: string | undefined;
    createdByUser?: User;
    updatedByUser?: User | undefined;
    couponUsages?: CouponUsage[];
}

export class RewardPoint implements IRewardPoint {
    rewardId?: string;
    userId?: string;
    points?: number;
    reason?: string | undefined;
    createdAt?: Date;
    expiresAt?: Date | undefined;
    user?: User;

    constructor(data?: IRewardPoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rewardId = _data["rewardId"];
            this.userId = _data["userId"];
            this.points = _data["points"];
            this.reason = _data["reason"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : undefined as any;
        }
    }

    static fromJS(data: any): RewardPoint {
        data = typeof data === 'object' ? data : {};
        let result = new RewardPoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rewardId"] = this.rewardId;
        data["userId"] = this.userId;
        data["points"] = this.points;
        data["reason"] = this.reason;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["user"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface IRewardPoint {
    rewardId?: string;
    userId?: string;
    points?: number;
    reason?: string | undefined;
    createdAt?: Date;
    expiresAt?: Date | undefined;
    user?: User;
}

export class PagedRequest implements IPagedRequest {
    page?: number;
    pageSize?: number;
    search?: string | undefined;
    sortBy?: string | undefined;
    sortDirection?: SortDirection;
    filters?: FilterCriteria[];
    hasFilters?: boolean;
    hasSearch?: boolean;
    hasSorting?: boolean;

    constructor(data?: IPagedRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.search = _data["search"];
            this.sortBy = _data["sortBy"];
            this.sortDirection = _data["sortDirection"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(FilterCriteria.fromJS(item));
            }
            this.hasFilters = _data["hasFilters"];
            this.hasSearch = _data["hasSearch"];
            this.hasSorting = _data["hasSorting"];
        }
    }

    static fromJS(data: any): PagedRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagedRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["search"] = this.search;
        data["sortBy"] = this.sortBy;
        data["sortDirection"] = this.sortDirection;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item ? item.toJSON() : undefined as any);
        }
        data["hasFilters"] = this.hasFilters;
        data["hasSearch"] = this.hasSearch;
        data["hasSorting"] = this.hasSorting;
        return data;
    }
}

export interface IPagedRequest {
    page?: number;
    pageSize?: number;
    search?: string | undefined;
    sortBy?: string | undefined;
    sortDirection?: SortDirection;
    filters?: FilterCriteria[];
    hasFilters?: boolean;
    hasSearch?: boolean;
    hasSorting?: boolean;
}

export class ResultOfAuditLog implements IResultOfAuditLog {
    isSuccess?: boolean;
    data?: AuditLog;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfAuditLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? AuditLog.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfAuditLog {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfAuditLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfAuditLog {
    isSuccess?: boolean;
    data?: AuditLog;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfInteger implements IResultOfInteger {
    isSuccess?: boolean;
    data?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfInteger {
    isSuccess?: boolean;
    data?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfDictionaryOfStringAndInteger implements IResultOfDictionaryOfStringAndInteger {
    isSuccess?: boolean;
    data?: { [key: string]: number; } | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfDictionaryOfStringAndInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (_data["data"]) {
                this.data = {} as any;
                for (let key in _data["data"]) {
                    if (_data["data"].hasOwnProperty(key))
                        (this.data as any)![key] = _data["data"][key];
                }
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfDictionaryOfStringAndInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfDictionaryOfStringAndInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (this.data) {
            data["data"] = {};
            for (let key in this.data) {
                if (this.data.hasOwnProperty(key))
                    (data["data"] as any)[key] = (this.data as any)[key];
            }
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfDictionaryOfStringAndInteger {
    isSuccess?: boolean;
    data?: { [key: string]: number; } | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfRegisterResponse implements IResultOfRegisterResponse {
    isSuccess?: boolean;
    data?: RegisterResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? RegisterResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfRegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfRegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfRegisterResponse {
    isSuccess?: boolean;
    data?: RegisterResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class RegisterResponse implements IRegisterResponse {
    userId?: string;
    email?: string;
    username?: string;
    role?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.role = _data["role"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): RegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["username"] = this.username;
        data["role"] = this.role;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IRegisterResponse {
    userId?: string;
    email?: string;
    username?: string;
    role?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;
}

export class RegisterCommand implements IRegisterCommand {
    email?: string;
    username?: string;
    password?: string;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterCommand {
    email?: string;
    username?: string;
    password?: string;
}

export class ResultOfLoginResponse implements IResultOfLoginResponse {
    isSuccess?: boolean;
    data?: LoginResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? LoginResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfLoginResponse {
    isSuccess?: boolean;
    data?: LoginResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class LoginResponse implements ILoginResponse {
    userId?: string;
    username?: string;
    role?: string;
    email?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            this.role = _data["role"];
            this.email = _data["email"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        data["role"] = this.role;
        data["email"] = this.email;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ILoginResponse {
    userId?: string;
    username?: string;
    role?: string;
    email?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;
}

export class LoginCommand implements ILoginCommand {
    emailOrUsername?: string;
    password?: string;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailOrUsername = _data["emailOrUsername"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailOrUsername"] = this.emailOrUsername;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    emailOrUsername?: string;
    password?: string;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string;
    resetToken?: string;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetToken = _data["resetToken"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetToken"] = this.resetToken;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string;
    resetToken?: string;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export class LogoutCommand implements ILogoutCommand {
    refreshToken?: string;

    constructor(data?: ILogoutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): LogoutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ILogoutCommand {
    refreshToken?: string;
}

export class ResultOfRefreshTokenResponse implements IResultOfRefreshTokenResponse {
    isSuccess?: boolean;
    data?: RefreshTokenResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfRefreshTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? RefreshTokenResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfRefreshTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfRefreshTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfRefreshTokenResponse {
    isSuccess?: boolean;
    data?: RefreshTokenResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class RefreshTokenResponse implements IRefreshTokenResponse {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: Date;

    constructor(data?: IRefreshTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): RefreshTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IRefreshTokenResponse {
    accessToken?: string;
    refreshToken?: string;
    expiresAt?: Date;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
    refreshToken?: string;

    constructor(data?: IRefreshTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshTokenCommand {
    refreshToken?: string;
}

export class CreateBrandCommand implements ICreateBrandCommand {
    description?: string;
    logoUrl?: string;
    name?: string;
    slug?: string;
    website?: string | undefined;
    status?: number;

    constructor(data?: ICreateBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.website = _data["website"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["website"] = this.website;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateBrandCommand {
    description?: string;
    logoUrl?: string;
    name?: string;
    slug?: string;
    website?: string | undefined;
    status?: number;
}

export class UpdateBrandCommand implements IUpdateBrandCommand {
    brandId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    logoUrl?: string | undefined;
    website?: string | undefined;
    status?: number | undefined;

    constructor(data?: IUpdateBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.website = _data["website"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateBrandCommand {
    brandId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    logoUrl?: string | undefined;
    website?: string | undefined;
    status?: number | undefined;
}

export class UpdateBrandStatusCommand implements IUpdateBrandStatusCommand {
    brandId?: string;
    status?: number;

    constructor(data?: IUpdateBrandStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateBrandStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateBrandStatusCommand {
    brandId?: string;
    status?: number;
}

export class ResultOfShoppingCartDto implements IResultOfShoppingCartDto {
    isSuccess?: boolean;
    data?: ShoppingCartDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfShoppingCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ShoppingCartDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfShoppingCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfShoppingCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfShoppingCartDto {
    isSuccess?: boolean;
    data?: ShoppingCartDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ShoppingCartDto implements IShoppingCartDto {
    cartId?: string;
    userId?: string | undefined;
    sessionId?: string | undefined;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: ShoppingCartItemDto[];

    constructor(data?: IShoppingCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartId = _data["cartId"];
            this.userId = _data["userId"];
            this.sessionId = _data["sessionId"];
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.couponCode = _data["couponCode"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShoppingCartItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShoppingCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartId"] = this.cartId;
        data["userId"] = this.userId;
        data["sessionId"] = this.sessionId;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["couponCode"] = this.couponCode;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IShoppingCartDto {
    cartId?: string;
    userId?: string | undefined;
    sessionId?: string | undefined;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: ShoppingCartItemDto[];
}

export class ResultOfCartSummaryDto implements IResultOfCartSummaryDto {
    isSuccess?: boolean;
    data?: CartSummaryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCartSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CartSummaryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCartSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCartSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCartSummaryDto {
    isSuccess?: boolean;
    data?: CartSummaryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CartSummaryDto implements ICartSummaryDto {
    itemCount?: number;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    isValid?: boolean;
    validationErrors?: string[];

    constructor(data?: ICartSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemCount = _data["itemCount"];
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.couponCode = _data["couponCode"];
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): CartSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CartSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCount"] = this.itemCount;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["couponCode"] = this.couponCode;
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface ICartSummaryDto {
    itemCount?: number;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    isValid?: boolean;
    validationErrors?: string[];
}

export class AddToCartRequest implements IAddToCartRequest {
    userId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    quantity?: number;

    constructor(data?: IAddToCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IAddToCartRequest {
    userId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    quantity?: number;
}

export class UpdateQuantityRequest implements IUpdateQuantityRequest {
    quantity?: number;

    constructor(data?: IUpdateQuantityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UpdateQuantityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuantityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUpdateQuantityRequest {
    quantity?: number;
}

export class ResultOfWishlistDto implements IResultOfWishlistDto {
    isSuccess?: boolean;
    data?: WishlistDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfWishlistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? WishlistDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfWishlistDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfWishlistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfWishlistDto {
    isSuccess?: boolean;
    data?: WishlistDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class WishlistDto implements IWishlistDto {
    wishlistId?: string;
    userId?: string;
    name?: string | undefined;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: WishlistItemDto[];

    constructor(data?: IWishlistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wishlistId = _data["wishlistId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WishlistItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WishlistDto {
        data = typeof data === 'object' ? data : {};
        let result = new WishlistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wishlistId"] = this.wishlistId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IWishlistDto {
    wishlistId?: string;
    userId?: string;
    name?: string | undefined;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: WishlistItemDto[];
}

export class WishlistItemDto implements IWishlistItemDto {
    wishlistItemId?: string;
    wishlistId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productPrice?: number;
    productDiscountPrice?: number | undefined;
    productStockQuantity?: number;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    createdAt?: Date;

    constructor(data?: IWishlistItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wishlistItemId = _data["wishlistItemId"];
            this.wishlistId = _data["wishlistId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.productImageUrl = _data["productImageUrl"];
            this.productPrice = _data["productPrice"];
            this.productDiscountPrice = _data["productDiscountPrice"];
            this.productStockQuantity = _data["productStockQuantity"];
            this.productVariantId = _data["productVariantId"];
            this.variantName = _data["variantName"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): WishlistItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new WishlistItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wishlistItemId"] = this.wishlistItemId;
        data["wishlistId"] = this.wishlistId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["productImageUrl"] = this.productImageUrl;
        data["productPrice"] = this.productPrice;
        data["productDiscountPrice"] = this.productDiscountPrice;
        data["productStockQuantity"] = this.productStockQuantity;
        data["productVariantId"] = this.productVariantId;
        data["variantName"] = this.variantName;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IWishlistItemDto {
    wishlistItemId?: string;
    wishlistId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productPrice?: number;
    productDiscountPrice?: number | undefined;
    productStockQuantity?: number;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    createdAt?: Date;
}

export class ResultOfPagedResultOfWishlistItemDto implements IResultOfPagedResultOfWishlistItemDto {
    isSuccess?: boolean;
    data?: PagedResultOfWishlistItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfWishlistItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfWishlistItemDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfWishlistItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfWishlistItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfWishlistItemDto {
    isSuccess?: boolean;
    data?: PagedResultOfWishlistItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfWishlistItemDto implements IPagedResultOfWishlistItemDto {
    items?: WishlistItemDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfWishlistItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WishlistItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfWishlistItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfWishlistItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfWishlistItemDto {
    items?: WishlistItemDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class AddToWishlistRequest implements IAddToWishlistRequest {
    productId?: string;
    variantId?: string | undefined;

    constructor(data?: IAddToWishlistRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.variantId = _data["variantId"];
        }
    }

    static fromJS(data: any): AddToWishlistRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddToWishlistRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["variantId"] = this.variantId;
        return data;
    }
}

export interface IAddToWishlistRequest {
    productId?: string;
    variantId?: string | undefined;
}

export class ResultOfPagedResultOfCategoryDto implements IResultOfPagedResultOfCategoryDto {
    isSuccess?: boolean;
    data?: PagedResultOfCategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfCategoryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfCategoryDto {
    isSuccess?: boolean;
    data?: PagedResultOfCategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfCategoryDto implements IPagedResultOfCategoryDto {
    items?: CategoryDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfCategoryDto {
    items?: CategoryDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategoryName?: string | undefined;
    displayOrder?: number;
    status?: number;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    subCategories?: CategoryDto[];
    productCount?: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.displayOrder = _data["displayOrder"];
            this.status = _data["status"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(CategoryDto.fromJS(item));
            }
            this.productCount = _data["productCount"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["displayOrder"] = this.displayOrder;
        data["status"] = this.status;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item ? item.toJSON() : undefined as any);
        }
        data["productCount"] = this.productCount;
        return data;
    }
}

export interface ICategoryDto {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategoryName?: string | undefined;
    displayOrder?: number;
    status?: number;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    subCategories?: CategoryDto[];
    productCount?: number;
}

export class ResultOfListOfCategoryDto implements IResultOfListOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfCategoryDto implements IResultOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CategoryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfCreateCategoryResponse implements IResultOfCreateCategoryResponse {
    isSuccess?: boolean;
    data?: CreateCategoryResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateCategoryResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateCategoryResponse {
    isSuccess?: boolean;
    data?: CreateCategoryResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateCategoryResponse extends CategoryDto implements ICreateCategoryResponse {

    constructor(data?: ICreateCategoryResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateCategoryResponse extends ICategoryDto {
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.image = _data["image"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.status = _data["status"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["image"] = this.image;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["parentCategoryId"] = this.parentCategoryId;
        data["status"] = this.status;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateCategoryCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    image?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;
}

export class ResultOfUpdateCategoryResponse implements IResultOfUpdateCategoryResponse {
    isSuccess?: boolean;
    data?: UpdateCategoryResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateCategoryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateCategoryResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateCategoryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateCategoryResponse {
    isSuccess?: boolean;
    data?: UpdateCategoryResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateCategoryResponse extends CategoryDto implements IUpdateCategoryResponse {

    constructor(data?: IUpdateCategoryResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateCategoryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateCategoryResponse extends ICategoryDto {
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.status = _data["status"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["parentCategoryId"] = this.parentCategoryId;
        data["status"] = this.status;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;
}

export class UpdateCategoryStatusCommand implements IUpdateCategoryStatusCommand {
    categoryId?: string;
    status?: number;

    constructor(data?: IUpdateCategoryStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateCategoryStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateCategoryStatusCommand {
    categoryId?: string;
    status?: number;
}

export class ResultOfString implements IResultOfString {
    isSuccess?: boolean;
    data?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfString {
    isSuccess?: boolean;
    data?: string | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfObject implements IResultOfObject {
    isSuccess?: boolean;
    data?: any | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfObject {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfObject {
    isSuccess?: boolean;
    data?: any | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfString implements IResultOfListOfString {
    isSuccess?: boolean;
    data?: string[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfString {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfString {
    isSuccess?: boolean;
    data?: string[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfOrderDto implements IResultOfOrderDto {
    isSuccess?: boolean;
    data?: OrderDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderDto {
    isSuccess?: boolean;
    data?: OrderDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class OrderDto implements IOrderDto {
    orderId?: string;
    orderNumber?: string;
    userId?: string;
    userName?: string;
    userEmail?: string;
    orderDate?: Date;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    createdByName?: string | undefined;
    totalAmount?: number;
    status?: number;
    statusName?: string;
    paymentStatus?: number;
    paymentStatusName?: string;
    paymentMethod?: number;
    paymentMethodName?: string;
    notes?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    deliveredAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    shippingFullAddress?: string;
    billingFullAddress?: string;
    items?: OrderItemDto[];

    constructor(data?: IOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.userEmail = _data["userEmail"];
            this.orderDate = _data["orderDate"] ? new Date(_data["orderDate"].toString()) : undefined as any;
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.createdByName = _data["createdByName"];
            this.totalAmount = _data["totalAmount"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.paymentStatus = _data["paymentStatus"];
            this.paymentStatusName = _data["paymentStatusName"];
            this.paymentMethod = _data["paymentMethod"];
            this.paymentMethodName = _data["paymentMethodName"];
            this.notes = _data["notes"];
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"] ? new Date(_data["estimatedDeliveryDate"].toString()) : undefined as any;
            this.deliveredAt = _data["deliveredAt"] ? new Date(_data["deliveredAt"].toString()) : undefined as any;
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.shippingFullAddress = _data["shippingFullAddress"];
            this.billingFullAddress = _data["billingFullAddress"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["userEmail"] = this.userEmail;
        data["orderDate"] = this.orderDate ? this.orderDate.toISOString() : undefined as any;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["createdByName"] = this.createdByName;
        data["totalAmount"] = this.totalAmount;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["paymentStatus"] = this.paymentStatus;
        data["paymentStatusName"] = this.paymentStatusName;
        data["paymentMethod"] = this.paymentMethod;
        data["paymentMethodName"] = this.paymentMethodName;
        data["notes"] = this.notes;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : undefined as any;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : undefined as any;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["shippingFullAddress"] = this.shippingFullAddress;
        data["billingFullAddress"] = this.billingFullAddress;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderDto {
    orderId?: string;
    orderNumber?: string;
    userId?: string;
    userName?: string;
    userEmail?: string;
    orderDate?: Date;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    createdByName?: string | undefined;
    totalAmount?: number;
    status?: number;
    statusName?: string;
    paymentStatus?: number;
    paymentStatusName?: string;
    paymentMethod?: number;
    paymentMethodName?: string;
    notes?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    deliveredAt?: Date | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    shippingFullAddress?: string;
    billingFullAddress?: string;
    items?: OrderItemDto[];
}

export class OrderItemDto implements IOrderItemDto {
    orderItemId?: string;
    orderId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    unitPrice?: number;
    quantity?: number;
    totalPrice?: number;
    createdAt?: Date;

    constructor(data?: IOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderItemId = _data["orderItemId"];
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.productImageUrl = _data["productImageUrl"];
            this.productVariantId = _data["productVariantId"];
            this.variantName = _data["variantName"];
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
            this.totalPrice = _data["totalPrice"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): OrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["productImageUrl"] = this.productImageUrl;
        data["productVariantId"] = this.productVariantId;
        data["variantName"] = this.variantName;
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        data["totalPrice"] = this.totalPrice;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IOrderItemDto {
    orderItemId?: string;
    orderId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    unitPrice?: number;
    quantity?: number;
    totalPrice?: number;
    createdAt?: Date;
}

export class CreateOrderRequest implements ICreateOrderRequest {
    userId?: string;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    paymentMethod?: number;
    shippingAddress?: ShippingAddressDto;
    billingAddress?: BillingAddressDto;
    notes?: string | undefined;
    items?: CreateOrderItemRequest[];

    constructor(data?: ICreateOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.paymentMethod = _data["paymentMethod"];
            this.shippingAddress = _data["shippingAddress"] ? ShippingAddressDto.fromJS(_data["shippingAddress"]) : undefined as any;
            this.billingAddress = _data["billingAddress"] ? BillingAddressDto.fromJS(_data["billingAddress"]) : undefined as any;
            this.notes = _data["notes"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreateOrderItemRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["paymentMethod"] = this.paymentMethod;
        data["shippingAddress"] = this.shippingAddress ? this.shippingAddress.toJSON() : undefined as any;
        data["billingAddress"] = this.billingAddress ? this.billingAddress.toJSON() : undefined as any;
        data["notes"] = this.notes;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateOrderRequest {
    userId?: string;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    paymentMethod?: number;
    shippingAddress?: ShippingAddressDto;
    billingAddress?: BillingAddressDto;
    notes?: string | undefined;
    items?: CreateOrderItemRequest[];
}

export class ShippingAddressDto implements IShippingAddressDto {
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string | undefined;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;

    constructor(data?: IShippingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): ShippingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IShippingAddressDto {
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string | undefined;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;
}

export class BillingAddressDto implements IBillingAddressDto {
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string | undefined;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;

    constructor(data?: IBillingAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.address = _data["address"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): BillingAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IBillingAddressDto {
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string | undefined;
    address?: string;
    city?: string;
    state?: string;
    zipCode?: string;
    country?: string;
}

export class CreateOrderItemRequest implements ICreateOrderItemRequest {
    orderId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    unitPrice?: number;
    quantity?: number;

    constructor(data?: ICreateOrderItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateOrderItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateOrderItemRequest {
    orderId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    unitPrice?: number;
    quantity?: number;
}

export class ResultOfPagedResultOfOrderDto implements IResultOfPagedResultOfOrderDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfOrderDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfOrderDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfOrderDto implements IPagedResultOfOrderDto {
    items?: OrderDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfOrderDto {
    items?: OrderDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfOrderDetailDto implements IResultOfOrderDetailDto {
    isSuccess?: boolean;
    data?: OrderDetailDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderDetailDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderDetailDto {
    isSuccess?: boolean;
    data?: OrderDetailDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class OrderDetailDto extends OrderDto implements IOrderDetailDto {
    statusHistory?: OrderStatusHistoryDto[];
    payments?: OrderPaymentDto[];
    shipments?: OrderShipmentDto[];
    refunds?: OrderRefundDto[];

    constructor(data?: IOrderDetailDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["statusHistory"])) {
                this.statusHistory = [] as any;
                for (let item of _data["statusHistory"])
                    this.statusHistory!.push(OrderStatusHistoryDto.fromJS(item));
            }
            if (Array.isArray(_data["payments"])) {
                this.payments = [] as any;
                for (let item of _data["payments"])
                    this.payments!.push(OrderPaymentDto.fromJS(item));
            }
            if (Array.isArray(_data["shipments"])) {
                this.shipments = [] as any;
                for (let item of _data["shipments"])
                    this.shipments!.push(OrderShipmentDto.fromJS(item));
            }
            if (Array.isArray(_data["refunds"])) {
                this.refunds = [] as any;
                for (let item of _data["refunds"])
                    this.refunds!.push(OrderRefundDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): OrderDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statusHistory)) {
            data["statusHistory"] = [];
            for (let item of this.statusHistory)
                data["statusHistory"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.payments)) {
            data["payments"] = [];
            for (let item of this.payments)
                data["payments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.shipments)) {
            data["shipments"] = [];
            for (let item of this.shipments)
                data["shipments"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.refunds)) {
            data["refunds"] = [];
            for (let item of this.refunds)
                data["refunds"].push(item ? item.toJSON() : undefined as any);
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOrderDetailDto extends IOrderDto {
    statusHistory?: OrderStatusHistoryDto[];
    payments?: OrderPaymentDto[];
    shipments?: OrderShipmentDto[];
    refunds?: OrderRefundDto[];
}

export class OrderStatusHistoryDto implements IOrderStatusHistoryDto {
    orderStatusHistoryId?: string;
    orderId?: string;
    status?: number;
    statusName?: string;
    notes?: string | undefined;
    createdAt?: Date;
    createdBy?: string | undefined;
    createdByName?: string | undefined;

    constructor(data?: IOrderStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderStatusHistoryId = _data["orderStatusHistoryId"];
            this.orderId = _data["orderId"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.createdBy = _data["createdBy"];
            this.createdByName = _data["createdByName"];
        }
    }

    static fromJS(data: any): OrderStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderStatusHistoryId"] = this.orderStatusHistoryId;
        data["orderId"] = this.orderId;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["createdBy"] = this.createdBy;
        data["createdByName"] = this.createdByName;
        return data;
    }
}

export interface IOrderStatusHistoryDto {
    orderStatusHistoryId?: string;
    orderId?: string;
    status?: number;
    statusName?: string;
    notes?: string | undefined;
    createdAt?: Date;
    createdBy?: string | undefined;
    createdByName?: string | undefined;
}

export class OrderPaymentDto implements IOrderPaymentDto {
    orderPaymentId?: string;
    orderId?: string;
    orderNumber?: string;
    paymentMethod?: number;
    paymentMethodName?: string;
    paymentStatusName?: string;
    amount?: number;
    transactionId?: string | undefined;
    paymentGateway?: string | undefined;
    status?: number;
    statusName?: string;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    processedAt?: Date | undefined;
    processedByName?: string | undefined;

    constructor(data?: IOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderPaymentId = _data["orderPaymentId"];
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.paymentMethod = _data["paymentMethod"];
            this.paymentMethodName = _data["paymentMethodName"];
            this.paymentStatusName = _data["paymentStatusName"];
            this.amount = _data["amount"];
            this.transactionId = _data["transactionId"];
            this.paymentGateway = _data["paymentGateway"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : undefined as any;
            this.processedByName = _data["processedByName"];
        }
    }

    static fromJS(data: any): OrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderPaymentId"] = this.orderPaymentId;
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["paymentMethod"] = this.paymentMethod;
        data["paymentMethodName"] = this.paymentMethodName;
        data["paymentStatusName"] = this.paymentStatusName;
        data["amount"] = this.amount;
        data["transactionId"] = this.transactionId;
        data["paymentGateway"] = this.paymentGateway;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : undefined as any;
        data["processedByName"] = this.processedByName;
        return data;
    }
}

export interface IOrderPaymentDto {
    orderPaymentId?: string;
    orderId?: string;
    orderNumber?: string;
    paymentMethod?: number;
    paymentMethodName?: string;
    paymentStatusName?: string;
    amount?: number;
    transactionId?: string | undefined;
    paymentGateway?: string | undefined;
    status?: number;
    statusName?: string;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    processedAt?: Date | undefined;
    processedByName?: string | undefined;
}

export class OrderShipmentDto implements IOrderShipmentDto {
    orderShipmentId?: string;
    orderId?: string;
    orderNumber?: string;
    shipmentCarrierId?: string | undefined;
    carrierName?: string | undefined;
    trackingNumber?: string | undefined;
    shippedAt?: Date | undefined;
    estimatedDeliveryDate?: Date | undefined;
    deliveredAt?: Date | undefined;
    status?: number;
    statusName?: string;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    shippingAddress?: string;
    items?: ShipmentItemDto[];

    constructor(data?: IOrderShipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderShipmentId = _data["orderShipmentId"];
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.shipmentCarrierId = _data["shipmentCarrierId"];
            this.carrierName = _data["carrierName"];
            this.trackingNumber = _data["trackingNumber"];
            this.shippedAt = _data["shippedAt"] ? new Date(_data["shippedAt"].toString()) : undefined as any;
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"] ? new Date(_data["estimatedDeliveryDate"].toString()) : undefined as any;
            this.deliveredAt = _data["deliveredAt"] ? new Date(_data["deliveredAt"].toString()) : undefined as any;
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.shippingAddress = _data["shippingAddress"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShipmentItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderShipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderShipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderShipmentId"] = this.orderShipmentId;
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["shipmentCarrierId"] = this.shipmentCarrierId;
        data["carrierName"] = this.carrierName;
        data["trackingNumber"] = this.trackingNumber;
        data["shippedAt"] = this.shippedAt ? this.shippedAt.toISOString() : undefined as any;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : undefined as any;
        data["deliveredAt"] = this.deliveredAt ? this.deliveredAt.toISOString() : undefined as any;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["shippingAddress"] = this.shippingAddress;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IOrderShipmentDto {
    orderShipmentId?: string;
    orderId?: string;
    orderNumber?: string;
    shipmentCarrierId?: string | undefined;
    carrierName?: string | undefined;
    trackingNumber?: string | undefined;
    shippedAt?: Date | undefined;
    estimatedDeliveryDate?: Date | undefined;
    deliveredAt?: Date | undefined;
    status?: number;
    statusName?: string;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    shippingAddress?: string;
    items?: ShipmentItemDto[];
}

export class ShipmentItemDto implements IShipmentItemDto {
    shipmentItemId?: string;
    orderShipmentId?: string;
    orderItemId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    quantity?: number;
    createdAt?: Date;

    constructor(data?: IShipmentItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentItemId = _data["shipmentItemId"];
            this.orderShipmentId = _data["orderShipmentId"];
            this.orderItemId = _data["orderItemId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.quantity = _data["quantity"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ShipmentItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentItemId"] = this.shipmentItemId;
        data["orderShipmentId"] = this.orderShipmentId;
        data["orderItemId"] = this.orderItemId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["quantity"] = this.quantity;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IShipmentItemDto {
    shipmentItemId?: string;
    orderShipmentId?: string;
    orderItemId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    quantity?: number;
    createdAt?: Date;
}

export class OrderRefundDto implements IOrderRefundDto {
    orderRefundId?: string;
    orderId?: string;
    orderNumber?: string;
    amount?: number;
    reason?: string;
    status?: number;
    statusName?: string;
    requestedAt?: Date;
    requestedBy?: string;
    requestedByName?: string | undefined;
    transactionId?: string | undefined;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    processedAt?: Date | undefined;
    processedBy?: string | undefined;
    processedByName?: string | undefined;

    constructor(data?: IOrderRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderRefundId = _data["orderRefundId"];
            this.orderId = _data["orderId"];
            this.orderNumber = _data["orderNumber"];
            this.amount = _data["amount"];
            this.reason = _data["reason"];
            this.status = _data["status"];
            this.statusName = _data["statusName"];
            this.requestedAt = _data["requestedAt"] ? new Date(_data["requestedAt"].toString()) : undefined as any;
            this.requestedBy = _data["requestedBy"];
            this.requestedByName = _data["requestedByName"];
            this.transactionId = _data["transactionId"];
            this.notes = _data["notes"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.processedAt = _data["processedAt"] ? new Date(_data["processedAt"].toString()) : undefined as any;
            this.processedBy = _data["processedBy"];
            this.processedByName = _data["processedByName"];
        }
    }

    static fromJS(data: any): OrderRefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderRefundId"] = this.orderRefundId;
        data["orderId"] = this.orderId;
        data["orderNumber"] = this.orderNumber;
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        data["status"] = this.status;
        data["statusName"] = this.statusName;
        data["requestedAt"] = this.requestedAt ? this.requestedAt.toISOString() : undefined as any;
        data["requestedBy"] = this.requestedBy;
        data["requestedByName"] = this.requestedByName;
        data["transactionId"] = this.transactionId;
        data["notes"] = this.notes;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["processedAt"] = this.processedAt ? this.processedAt.toISOString() : undefined as any;
        data["processedBy"] = this.processedBy;
        data["processedByName"] = this.processedByName;
        return data;
    }
}

export interface IOrderRefundDto {
    orderRefundId?: string;
    orderId?: string;
    orderNumber?: string;
    amount?: number;
    reason?: string;
    status?: number;
    statusName?: string;
    requestedAt?: Date;
    requestedBy?: string;
    requestedByName?: string | undefined;
    transactionId?: string | undefined;
    notes?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    processedAt?: Date | undefined;
    processedBy?: string | undefined;
    processedByName?: string | undefined;
}

export class UpdateOrderRequest implements IUpdateOrderRequest {
    status?: number;
    paymentStatus?: number;
    notes?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;

    constructor(data?: IUpdateOrderRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.paymentStatus = _data["paymentStatus"];
            this.notes = _data["notes"];
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"] ? new Date(_data["estimatedDeliveryDate"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateOrderRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["paymentStatus"] = this.paymentStatus;
        data["notes"] = this.notes;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : undefined as any;
        return data;
    }
}

export interface IUpdateOrderRequest {
    status?: number;
    paymentStatus?: number;
    notes?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
}

export class UpdateOrderStatusRequest implements IUpdateOrderStatusRequest {
    status?: number;

    constructor(data?: IUpdateOrderStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateOrderStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateOrderStatusRequest {
    status?: number;
}

export class ResultOfPagedResultOfOrderItemDto implements IResultOfPagedResultOfOrderItemDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfOrderItemDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfOrderItemDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfOrderItemDto implements IPagedResultOfOrderItemDto {
    items?: OrderItemDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfOrderItemDto {
    items?: OrderItemDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfOrderItemDto implements IResultOfOrderItemDto {
    isSuccess?: boolean;
    data?: OrderItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderItemDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderItemDto {
    isSuccess?: boolean;
    data?: OrderItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfOrderItemDto implements IResultOfListOfOrderItemDto {
    isSuccess?: boolean;
    data?: OrderItemDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfOrderItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderItemDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfOrderItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfOrderItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfOrderItemDto {
    isSuccess?: boolean;
    data?: OrderItemDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateOrderItemRequest implements IUpdateOrderItemRequest {
    unitPrice?: number;
    quantity?: number;

    constructor(data?: IUpdateOrderItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UpdateOrderItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUpdateOrderItemRequest {
    unitPrice?: number;
    quantity?: number;
}

export class ResultOfPagedResultOfOrderPaymentDto implements IResultOfPagedResultOfOrderPaymentDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderPaymentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfOrderPaymentDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfOrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfOrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfOrderPaymentDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderPaymentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfOrderPaymentDto implements IPagedResultOfOrderPaymentDto {
    items?: OrderPaymentDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderPaymentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfOrderPaymentDto {
    items?: OrderPaymentDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfOrderPaymentDto implements IResultOfOrderPaymentDto {
    isSuccess?: boolean;
    data?: OrderPaymentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderPaymentDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderPaymentDto {
    isSuccess?: boolean;
    data?: OrderPaymentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfOrderPaymentDto implements IResultOfListOfOrderPaymentDto {
    isSuccess?: boolean;
    data?: OrderPaymentDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfOrderPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderPaymentDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfOrderPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfOrderPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfOrderPaymentDto {
    isSuccess?: boolean;
    data?: OrderPaymentDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateOrderPaymentRequest implements ICreateOrderPaymentRequest {
    orderId?: string;
    paymentMethod?: number;
    amount?: number;
    transactionId?: string | undefined;
    paymentGateway?: string | undefined;
    status?: number;
    notes?: string | undefined;

    constructor(data?: ICreateOrderPaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.paymentMethod = _data["paymentMethod"];
            this.amount = _data["amount"];
            this.transactionId = _data["transactionId"];
            this.paymentGateway = _data["paymentGateway"];
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateOrderPaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderPaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["paymentMethod"] = this.paymentMethod;
        data["amount"] = this.amount;
        data["transactionId"] = this.transactionId;
        data["paymentGateway"] = this.paymentGateway;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateOrderPaymentRequest {
    orderId?: string;
    paymentMethod?: number;
    amount?: number;
    transactionId?: string | undefined;
    paymentGateway?: string | undefined;
    status?: number;
    notes?: string | undefined;
}

export class UpdateOrderPaymentRequest implements IUpdateOrderPaymentRequest {
    paymentMethod?: number;
    amount?: number;
    transactionId?: string | undefined;
    paymentGateway?: string | undefined;
    status?: number;
    notes?: string | undefined;

    constructor(data?: IUpdateOrderPaymentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentMethod = _data["paymentMethod"];
            this.amount = _data["amount"];
            this.transactionId = _data["transactionId"];
            this.paymentGateway = _data["paymentGateway"];
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateOrderPaymentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderPaymentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentMethod"] = this.paymentMethod;
        data["amount"] = this.amount;
        data["transactionId"] = this.transactionId;
        data["paymentGateway"] = this.paymentGateway;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IUpdateOrderPaymentRequest {
    paymentMethod?: number;
    amount?: number;
    transactionId?: string | undefined;
    paymentGateway?: string | undefined;
    status?: number;
    notes?: string | undefined;
}

export class UpdatePaymentStatusRequest implements IUpdatePaymentStatusRequest {
    status?: number;

    constructor(data?: IUpdatePaymentStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdatePaymentStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePaymentStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdatePaymentStatusRequest {
    status?: number;
}

export class ResultOfPagedResultOfOrderRefundDto implements IResultOfPagedResultOfOrderRefundDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderRefundDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfOrderRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfOrderRefundDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfOrderRefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfOrderRefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfOrderRefundDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderRefundDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfOrderRefundDto implements IPagedResultOfOrderRefundDto {
    items?: OrderRefundDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfOrderRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderRefundDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderRefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderRefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfOrderRefundDto {
    items?: OrderRefundDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfOrderRefundDto implements IResultOfOrderRefundDto {
    isSuccess?: boolean;
    data?: OrderRefundDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderRefundDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderRefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderRefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderRefundDto {
    isSuccess?: boolean;
    data?: OrderRefundDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfOrderRefundDto implements IResultOfListOfOrderRefundDto {
    isSuccess?: boolean;
    data?: OrderRefundDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfOrderRefundDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderRefundDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfOrderRefundDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfOrderRefundDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfOrderRefundDto {
    isSuccess?: boolean;
    data?: OrderRefundDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateOrderRefundRequest implements ICreateOrderRefundRequest {
    orderId?: string;
    paymentId?: string | undefined;
    amount?: number;
    reason?: string;
    requestedBy?: string;
    notes?: string | undefined;

    constructor(data?: ICreateOrderRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.paymentId = _data["paymentId"];
            this.amount = _data["amount"];
            this.reason = _data["reason"];
            this.requestedBy = _data["requestedBy"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): CreateOrderRefundRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderRefundRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["paymentId"] = this.paymentId;
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        data["requestedBy"] = this.requestedBy;
        data["notes"] = this.notes;
        return data;
    }
}

export interface ICreateOrderRefundRequest {
    orderId?: string;
    paymentId?: string | undefined;
    amount?: number;
    reason?: string;
    requestedBy?: string;
    notes?: string | undefined;
}

export class UpdateOrderRefundRequest implements IUpdateOrderRefundRequest {
    amount?: number;
    reason?: string;
    status?: number;
    transactionId?: string | undefined;
    notes?: string | undefined;

    constructor(data?: IUpdateOrderRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.reason = _data["reason"];
            this.status = _data["status"];
            this.transactionId = _data["transactionId"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateOrderRefundRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderRefundRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["reason"] = this.reason;
        data["status"] = this.status;
        data["transactionId"] = this.transactionId;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IUpdateOrderRefundRequest {
    amount?: number;
    reason?: string;
    status?: number;
    transactionId?: string | undefined;
    notes?: string | undefined;
}

export class ProcessRefundRequest implements IProcessRefundRequest {
    processedBy?: string;

    constructor(data?: IProcessRefundRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.processedBy = _data["processedBy"];
        }
    }

    static fromJS(data: any): ProcessRefundRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProcessRefundRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processedBy"] = this.processedBy;
        return data;
    }
}

export interface IProcessRefundRequest {
    processedBy?: string;
}

export class ResultOfPagedResultOfOrderShipmentDto implements IResultOfPagedResultOfOrderShipmentDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderShipmentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfOrderShipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfOrderShipmentDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfOrderShipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfOrderShipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfOrderShipmentDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderShipmentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfOrderShipmentDto implements IPagedResultOfOrderShipmentDto {
    items?: OrderShipmentDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfOrderShipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderShipmentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderShipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderShipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfOrderShipmentDto {
    items?: OrderShipmentDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfOrderShipmentDto implements IResultOfOrderShipmentDto {
    isSuccess?: boolean;
    data?: OrderShipmentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderShipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderShipmentDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderShipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderShipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderShipmentDto {
    isSuccess?: boolean;
    data?: OrderShipmentDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfOrderShipmentDto implements IResultOfListOfOrderShipmentDto {
    isSuccess?: boolean;
    data?: OrderShipmentDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfOrderShipmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderShipmentDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfOrderShipmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfOrderShipmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfOrderShipmentDto {
    isSuccess?: boolean;
    data?: OrderShipmentDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateOrderShipmentRequest implements ICreateOrderShipmentRequest {
    orderId?: string;
    shipmentCarrierId?: string | undefined;
    trackingNumber?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    notes?: string | undefined;
    items?: CreateShipmentItemRequest[];

    constructor(data?: ICreateOrderShipmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.shipmentCarrierId = _data["shipmentCarrierId"];
            this.trackingNumber = _data["trackingNumber"];
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"] ? new Date(_data["estimatedDeliveryDate"].toString()) : undefined as any;
            this.notes = _data["notes"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreateShipmentItemRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrderShipmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderShipmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["shipmentCarrierId"] = this.shipmentCarrierId;
        data["trackingNumber"] = this.trackingNumber;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : undefined as any;
        data["notes"] = this.notes;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateOrderShipmentRequest {
    orderId?: string;
    shipmentCarrierId?: string | undefined;
    trackingNumber?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    notes?: string | undefined;
    items?: CreateShipmentItemRequest[];
}

export class CreateShipmentItemRequest implements ICreateShipmentItemRequest {
    orderItemId?: string;
    quantity?: number;

    constructor(data?: ICreateShipmentItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderItemId = _data["orderItemId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreateShipmentItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShipmentItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreateShipmentItemRequest {
    orderItemId?: string;
    quantity?: number;
}

export class UpdateOrderShipmentRequest implements IUpdateOrderShipmentRequest {
    shipmentCarrierId?: string | undefined;
    trackingNumber?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    status?: number;
    notes?: string | undefined;

    constructor(data?: IUpdateOrderShipmentRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentCarrierId = _data["shipmentCarrierId"];
            this.trackingNumber = _data["trackingNumber"];
            this.estimatedDeliveryDate = _data["estimatedDeliveryDate"] ? new Date(_data["estimatedDeliveryDate"].toString()) : undefined as any;
            this.status = _data["status"];
            this.notes = _data["notes"];
        }
    }

    static fromJS(data: any): UpdateOrderShipmentRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrderShipmentRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentCarrierId"] = this.shipmentCarrierId;
        data["trackingNumber"] = this.trackingNumber;
        data["estimatedDeliveryDate"] = this.estimatedDeliveryDate ? this.estimatedDeliveryDate.toISOString() : undefined as any;
        data["status"] = this.status;
        data["notes"] = this.notes;
        return data;
    }
}

export interface IUpdateOrderShipmentRequest {
    shipmentCarrierId?: string | undefined;
    trackingNumber?: string | undefined;
    estimatedDeliveryDate?: Date | undefined;
    status?: number;
    notes?: string | undefined;
}

export class UpdateShipmentStatusRequest implements IUpdateShipmentStatusRequest {
    status?: number;

    constructor(data?: IUpdateShipmentStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateShipmentStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShipmentStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateShipmentStatusRequest {
    status?: number;
}

export class ResultOfPagedResultOfOrderStatusHistoryDto implements IResultOfPagedResultOfOrderStatusHistoryDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderStatusHistoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfOrderStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfOrderStatusHistoryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfOrderStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfOrderStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfOrderStatusHistoryDto {
    isSuccess?: boolean;
    data?: PagedResultOfOrderStatusHistoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfOrderStatusHistoryDto implements IPagedResultOfOrderStatusHistoryDto {
    items?: OrderStatusHistoryDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfOrderStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrderStatusHistoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfOrderStatusHistoryDto {
    items?: OrderStatusHistoryDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfOrderStatusHistoryDto implements IResultOfOrderStatusHistoryDto {
    isSuccess?: boolean;
    data?: OrderStatusHistoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfOrderStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? OrderStatusHistoryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfOrderStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfOrderStatusHistoryDto {
    isSuccess?: boolean;
    data?: OrderStatusHistoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfOrderStatusHistoryDto implements IResultOfListOfOrderStatusHistoryDto {
    isSuccess?: boolean;
    data?: OrderStatusHistoryDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfOrderStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(OrderStatusHistoryDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfOrderStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfOrderStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfOrderStatusHistoryDto {
    isSuccess?: boolean;
    data?: OrderStatusHistoryDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateOrderStatusHistoryRequest implements ICreateOrderStatusHistoryRequest {
    orderId?: string;
    fromStatus?: number | undefined;
    toStatus?: number;
    comment?: string | undefined;
    createdBy?: string;

    constructor(data?: ICreateOrderStatusHistoryRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.fromStatus = _data["fromStatus"];
            this.toStatus = _data["toStatus"];
            this.comment = _data["comment"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): CreateOrderStatusHistoryRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderStatusHistoryRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["fromStatus"] = this.fromStatus;
        data["toStatus"] = this.toStatus;
        data["comment"] = this.comment;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface ICreateOrderStatusHistoryRequest {
    orderId?: string;
    fromStatus?: number | undefined;
    toStatus?: number;
    comment?: string | undefined;
    createdBy?: string;
}

export class AddStatusChangeRequest implements IAddStatusChangeRequest {
    orderId?: string;
    fromStatus?: number;
    toStatus?: number;
    comment?: string | undefined;
    createdBy?: string;

    constructor(data?: IAddStatusChangeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.fromStatus = _data["fromStatus"];
            this.toStatus = _data["toStatus"];
            this.comment = _data["comment"];
            this.createdBy = _data["createdBy"];
        }
    }

    static fromJS(data: any): AddStatusChangeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddStatusChangeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["fromStatus"] = this.fromStatus;
        data["toStatus"] = this.toStatus;
        data["comment"] = this.comment;
        data["createdBy"] = this.createdBy;
        return data;
    }
}

export interface IAddStatusChangeRequest {
    orderId?: string;
    fromStatus?: number;
    toStatus?: number;
    comment?: string | undefined;
    createdBy?: string;
}

export class ResultOfPagedResultOfProductAttributeDto implements IResultOfPagedResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductAttributeDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductAttributeDto implements IPagedResultOfProductAttributeDto {
    items?: ProductAttributeDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAttributeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductAttributeDto {
    items?: ProductAttributeDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductAttributeDto implements IProductAttributeDto {
    productAttributeId?: string;
    name?: string;
    description?: string | undefined;
    dataType?: string;
    isRequired?: boolean;
    isSearchable?: boolean;
    isFilterable?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productAttributeId = _data["productAttributeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataType = _data["dataType"];
            this.isRequired = _data["isRequired"];
            this.isSearchable = _data["isSearchable"];
            this.isFilterable = _data["isFilterable"];
            this.displayOrder = _data["displayOrder"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productAttributeId"] = this.productAttributeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataType"] = this.dataType;
        data["isRequired"] = this.isRequired;
        data["isSearchable"] = this.isSearchable;
        data["isFilterable"] = this.isFilterable;
        data["displayOrder"] = this.displayOrder;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductAttributeDto {
    productAttributeId?: string;
    name?: string;
    description?: string | undefined;
    dataType?: string;
    isRequired?: boolean;
    isSearchable?: boolean;
    isFilterable?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export class ResultOfProductAttributeDto implements IResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: ProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductAttributeDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: ProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfCreateProductAttributeResponse implements IResultOfCreateProductAttributeResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductAttributeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductAttributeResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductAttributeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductAttributeResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductAttributeResponse extends ProductAttributeDto implements ICreateProductAttributeResponse {

    constructor(data?: ICreateProductAttributeResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductAttributeResponse extends IProductAttributeDto {
}

export class CreateProductAttributeCommand implements ICreateProductAttributeCommand {
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;

    constructor(data?: ICreateProductAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.attributeType = _data["attributeType"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateProductAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["attributeType"] = this.attributeType;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateProductAttributeCommand {
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;
}

export class ResultOfUpdateProductAttributeResponse implements IResultOfUpdateProductAttributeResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductAttributeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductAttributeResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductAttributeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductAttributeResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductAttributeResponse extends ProductAttributeDto implements IUpdateProductAttributeResponse {

    constructor(data?: IUpdateProductAttributeResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductAttributeResponse extends IProductAttributeDto {
}

export class UpdateProductAttributeCommand implements IUpdateProductAttributeCommand {
    attributeId?: string;
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;

    constructor(data?: IUpdateProductAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.attributeType = _data["attributeType"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["attributeType"] = this.attributeType;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateProductAttributeCommand {
    attributeId?: string;
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;
}

export class ResultOfProductAttributeValueDto implements IResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: ProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductAttributeValueDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: ProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ProductAttributeValueDto implements IProductAttributeValueDto {
    productAttributeValueId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    productAttributeId?: string;
    productAttributeName?: string;
    value?: string;
    createdAt?: Date;

    constructor(data?: IProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productAttributeValueId = _data["productAttributeValueId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.productAttributeId = _data["productAttributeId"];
            this.productAttributeName = _data["productAttributeName"];
            this.value = _data["value"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productAttributeValueId"] = this.productAttributeValueId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["productAttributeId"] = this.productAttributeId;
        data["productAttributeName"] = this.productAttributeName;
        data["value"] = this.value;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductAttributeValueDto {
    productAttributeValueId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    productAttributeId?: string;
    productAttributeName?: string;
    value?: string;
    createdAt?: Date;
}

export class ResultOfPagedResultOfProductAttributeValueDto implements IResultOfPagedResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductAttributeValueDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductAttributeValueDto implements IPagedResultOfProductAttributeValueDto {
    items?: ProductAttributeValueDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAttributeValueDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductAttributeValueDto {
    items?: ProductAttributeValueDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfCreateProductAttributeValueResponse implements IResultOfCreateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductAttributeValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductAttributeValueResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductAttributeValueResponse extends ProductAttributeValueDto implements ICreateProductAttributeValueResponse {

    constructor(data?: ICreateProductAttributeValueResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductAttributeValueResponse extends IProductAttributeValueDto {
}

export class CreateProductAttributeValueCommand implements ICreateProductAttributeValueCommand {
    productId?: string;
    attributeId?: string;
    value?: string;

    constructor(data?: ICreateProductAttributeValueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.attributeId = _data["attributeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateProductAttributeValueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeValueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["attributeId"] = this.attributeId;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateProductAttributeValueCommand {
    productId?: string;
    attributeId?: string;
    value?: string;
}

export class ResultOfUpdateProductAttributeValueResponse implements IResultOfUpdateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductAttributeValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductAttributeValueResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductAttributeValueResponse extends ProductAttributeValueDto implements IUpdateProductAttributeValueResponse {

    constructor(data?: IUpdateProductAttributeValueResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductAttributeValueResponse extends IProductAttributeValueDto {
}

export class UpdateProductAttributeValueCommand implements IUpdateProductAttributeValueCommand {
    valueId?: string;
    productId?: string;
    attributeId?: string;
    value?: string;

    constructor(data?: IUpdateProductAttributeValueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueId = _data["valueId"];
            this.productId = _data["productId"];
            this.attributeId = _data["attributeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeValueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeValueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueId"] = this.valueId;
        data["productId"] = this.productId;
        data["attributeId"] = this.attributeId;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateProductAttributeValueCommand {
    valueId?: string;
    productId?: string;
    attributeId?: string;
    value?: string;
}

export class ResultOfCreateProductResponse implements IResultOfCreateProductResponse {
    isSuccess?: boolean;
    data?: CreateProductResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductResponse {
    isSuccess?: boolean;
    data?: CreateProductResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ProductBaseResponse implements IProductBaseResponse {
    productId?: string;
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    categoryName?: string;
    brandId?: string | undefined;
    brandName?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    primaryImageUrl?: string | undefined;
    images?: ProductImageDto[];
    variants?: ProductVariantDto[];
    tags?: ProductTagDto[];
    averageRating?: number | undefined;
    reviewCount?: number;

    constructor(data?: IProductBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.isDigital = _data["isDigital"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.primaryImageUrl = _data["primaryImageUrl"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(ProductVariantDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ProductTagDto.fromJS(item));
            }
            this.averageRating = _data["averageRating"];
            this.reviewCount = _data["reviewCount"];
        }
    }

    static fromJS(data: any): ProductBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["isDigital"] = this.isDigital;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["primaryImageUrl"] = this.primaryImageUrl;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item ? item.toJSON() : undefined as any);
        }
        data["averageRating"] = this.averageRating;
        data["reviewCount"] = this.reviewCount;
        return data;
    }
}

export interface IProductBaseResponse {
    productId?: string;
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    categoryName?: string;
    brandId?: string | undefined;
    brandName?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    primaryImageUrl?: string | undefined;
    images?: ProductImageDto[];
    variants?: ProductVariantDto[];
    tags?: ProductTagDto[];
    averageRating?: number | undefined;
    reviewCount?: number;
}

export class CreateProductResponse extends ProductBaseResponse implements ICreateProductResponse {

    constructor(data?: ICreateProductResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductResponse extends IProductBaseResponse {
}

export class ProductImageDto implements IProductImageDto {
    productImageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
    createdAt?: Date;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productImageId = _data["productImageId"];
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productImageId"] = this.productImageId;
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductImageDto {
    productImageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
    createdAt?: Date;
}

export class ProductVariantDto implements IProductVariantDto {
    productVariantId?: string;
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    imageUrl?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    attributes?: ProductAttributeValueDto[];

    constructor(data?: IProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productVariantId = _data["productVariantId"];
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.imageUrl = _data["imageUrl"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductAttributeValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productVariantId"] = this.productVariantId;
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["imageUrl"] = this.imageUrl;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProductVariantDto {
    productVariantId?: string;
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    imageUrl?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    attributes?: ProductAttributeValueDto[];
}

export class ProductTagDto implements IProductTagDto {
    productTagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    color?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    productCount?: number;

    constructor(data?: IProductTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productTagId = _data["productTagId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.color = _data["color"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.productCount = _data["productCount"];
        }
    }

    static fromJS(data: any): ProductTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTagId"] = this.productTagId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["color"] = this.color;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["productCount"] = this.productCount;
        return data;
    }
}

export interface IProductTagDto {
    productTagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    color?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    productCount?: number;
}

export class CreateProductVariantRequest implements ICreateProductVariantRequest {
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
    imageUrl?: string | undefined;
    imageFile?: FileUploadDto | undefined;
    attributes?: CreateProductAttributeValueRequest[];

    constructor(data?: ICreateProductVariantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.status = _data["status"];
            this.imageUrl = _data["imageUrl"];
            this.imageFile = _data["imageFile"] ? FileUploadDto.fromJS(_data["imageFile"]) : undefined as any;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(CreateProductAttributeValueRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductVariantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductVariantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["status"] = this.status;
        data["imageUrl"] = this.imageUrl;
        data["imageFile"] = this.imageFile ? this.imageFile.toJSON() : undefined as any;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateProductVariantRequest {
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
    imageUrl?: string | undefined;
    imageFile?: FileUploadDto | undefined;
    attributes?: CreateProductAttributeValueRequest[];
}

export class FileUploadDto implements IFileUploadDto {
    content?: string;
    fileName?: string;
    contentType?: string;

    constructor(data?: IFileUploadDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): FileUploadDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileUploadDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        return data;
    }
}

export interface IFileUploadDto {
    content?: string;
    fileName?: string;
    contentType?: string;
}

export class CreateProductAttributeValueRequest implements ICreateProductAttributeValueRequest {
    productId?: string;
    productAttributeId?: string;
    value?: string;

    constructor(data?: ICreateProductAttributeValueRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productAttributeId = _data["productAttributeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateProductAttributeValueRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeValueRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productAttributeId"] = this.productAttributeId;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateProductAttributeValueRequest {
    productId?: string;
    productAttributeId?: string;
    value?: string;
}

export class CreateProductCommand implements ICreateProductCommand {
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    images?: CreateProductImageRequest[] | undefined;
    variants?: CreateProductVariantRequest[] | undefined;
    attributes?: CreateProductAttributeValueRequest[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.categoryId = _data["categoryId"];
            this.brandId = _data["brandId"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.isDigital = _data["isDigital"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateProductImageRequest.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(CreateProductVariantRequest.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(CreateProductAttributeValueRequest.fromJS(item));
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["categoryId"] = this.categoryId;
        data["brandId"] = this.brandId;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["isDigital"] = this.isDigital;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateProductCommand {
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    images?: CreateProductImageRequest[] | undefined;
    variants?: CreateProductVariantRequest[] | undefined;
    attributes?: CreateProductAttributeValueRequest[] | undefined;
    tagIds?: string[] | undefined;
}

export class CreateProductImageRequest implements ICreateProductImageRequest {
    productId?: string;
    imageUrl?: string | undefined;
    imageFile?: string | undefined;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;

    constructor(data?: ICreateProductImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.imageFile = _data["imageFile"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): CreateProductImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["imageFile"] = this.imageFile;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICreateProductImageRequest {
    productId?: string;
    imageUrl?: string | undefined;
    imageFile?: string | undefined;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
}

export class ResultOfPagedResultOfProductBaseResponse implements IResultOfPagedResultOfProductBaseResponse {
    isSuccess?: boolean;
    data?: PagedResultOfProductBaseResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductBaseResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductBaseResponse {
    isSuccess?: boolean;
    data?: PagedResultOfProductBaseResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductBaseResponse implements IPagedResultOfProductBaseResponse {
    items?: ProductBaseResponse[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductBaseResponse.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductBaseResponse {
    items?: ProductBaseResponse[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfGetProductByIdResponse implements IResultOfGetProductByIdResponse {
    isSuccess?: boolean;
    data?: GetProductByIdResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfGetProductByIdResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? GetProductByIdResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfGetProductByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetProductByIdResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfGetProductByIdResponse {
    isSuccess?: boolean;
    data?: GetProductByIdResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class GetProductByIdResponse extends ProductBaseResponse implements IGetProductByIdResponse {

    constructor(data?: IGetProductByIdResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetProductByIdResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductByIdResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetProductByIdResponse extends IProductBaseResponse {
}

export class ResultOfGetProductBySkuResponse implements IResultOfGetProductBySkuResponse {
    isSuccess?: boolean;
    data?: GetProductBySkuResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfGetProductBySkuResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? GetProductBySkuResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfGetProductBySkuResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetProductBySkuResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfGetProductBySkuResponse {
    isSuccess?: boolean;
    data?: GetProductBySkuResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class GetProductBySkuResponse extends ProductBaseResponse implements IGetProductBySkuResponse {

    constructor(data?: IGetProductBySkuResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetProductBySkuResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductBySkuResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetProductBySkuResponse extends IProductBaseResponse {
}

export class ResultOfGetProductBySlugResponse implements IResultOfGetProductBySlugResponse {
    isSuccess?: boolean;
    data?: GetProductBySlugResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfGetProductBySlugResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? GetProductBySlugResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfGetProductBySlugResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetProductBySlugResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfGetProductBySlugResponse {
    isSuccess?: boolean;
    data?: GetProductBySlugResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class GetProductBySlugResponse extends ProductBaseResponse implements IGetProductBySlugResponse {

    constructor(data?: IGetProductBySlugResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetProductBySlugResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetProductBySlugResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetProductBySlugResponse extends IProductBaseResponse {
}

export class ResultOfUpdateProductResponse implements IResultOfUpdateProductResponse {
    isSuccess?: boolean;
    data?: UpdateProductResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductResponse {
    isSuccess?: boolean;
    data?: UpdateProductResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductResponse extends ProductBaseResponse implements IUpdateProductResponse {

    constructor(data?: IUpdateProductResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductResponse extends IProductBaseResponse {
}

export class UpdateProductCommand implements IUpdateProductCommand {
    productId?: string;
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.categoryId = _data["categoryId"];
            this.brandId = _data["brandId"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.isDigital = _data["isDigital"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["categoryId"] = this.categoryId;
        data["brandId"] = this.brandId;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["isDigital"] = this.isDigital;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        return data;
    }
}

export interface IUpdateProductCommand {
    productId?: string;
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
}

export class UpdateProductStatusCommand implements IUpdateProductStatusCommand {
    productId?: string;
    status?: number;

    constructor(data?: IUpdateProductStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateProductStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateProductStatusCommand {
    productId?: string;
    status?: number;
}

export class UpdateProductStockCommand implements IUpdateProductStockCommand {
    productId?: string;
    stockQuantity?: number;

    constructor(data?: IUpdateProductStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.stockQuantity = _data["stockQuantity"];
        }
    }

    static fromJS(data: any): UpdateProductStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["stockQuantity"] = this.stockQuantity;
        return data;
    }
}

export interface IUpdateProductStockCommand {
    productId?: string;
    stockQuantity?: number;
}

export class ResultOfGetFeaturedProductsResponse implements IResultOfGetFeaturedProductsResponse {
    isSuccess?: boolean;
    data?: GetFeaturedProductsResponse;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfGetFeaturedProductsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? GetFeaturedProductsResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfGetFeaturedProductsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetFeaturedProductsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfGetFeaturedProductsResponse {
    isSuccess?: boolean;
    data?: GetFeaturedProductsResponse;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class GetFeaturedProductsResponse extends ProductBaseResponse implements IGetFeaturedProductsResponse {

    constructor(data?: IGetFeaturedProductsResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetFeaturedProductsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetFeaturedProductsResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetFeaturedProductsResponse extends IProductBaseResponse {
}

export class ResultOfGetActiveProductsResponse implements IResultOfGetActiveProductsResponse {
    isSuccess?: boolean;
    data?: GetActiveProductsResponse;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfGetActiveProductsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? GetActiveProductsResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfGetActiveProductsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfGetActiveProductsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfGetActiveProductsResponse {
    isSuccess?: boolean;
    data?: GetActiveProductsResponse;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class GetActiveProductsResponse extends ProductBaseResponse implements IGetActiveProductsResponse {

    constructor(data?: IGetActiveProductsResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): GetActiveProductsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetActiveProductsResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IGetActiveProductsResponse extends IProductBaseResponse {
}

export class ResultOfSearchProductsResponse implements IResultOfSearchProductsResponse {
    isSuccess?: boolean;
    data?: SearchProductsResponse;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfSearchProductsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? SearchProductsResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfSearchProductsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfSearchProductsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfSearchProductsResponse {
    isSuccess?: boolean;
    data?: SearchProductsResponse;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class SearchProductsResponse extends ProductBaseResponse implements ISearchProductsResponse {

    constructor(data?: ISearchProductsResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): SearchProductsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchProductsResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ISearchProductsResponse extends IProductBaseResponse {
}

export class ResultOfProductImageDto implements IResultOfProductImageDto {
    isSuccess?: boolean;
    data?: ProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductImageDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductImageDto {
    isSuccess?: boolean;
    data?: ProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfPagedResultOfProductImageDto implements IResultOfPagedResultOfProductImageDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductImageDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductImageDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductImageDto implements IPagedResultOfProductImageDto {
    items?: ProductImageDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductImageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductImageDto {
    items?: ProductImageDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfCreateProductImageResponse implements IResultOfCreateProductImageResponse {
    isSuccess?: boolean;
    data?: CreateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductImageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductImageResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductImageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductImageResponse {
    isSuccess?: boolean;
    data?: CreateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductImageResponse extends ProductImageDto implements ICreateProductImageResponse {

    constructor(data?: ICreateProductImageResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductImageResponse extends IProductImageDto {
}

export class CreateProductImageCommand implements ICreateProductImageCommand {
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;

    constructor(data?: ICreateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.isPrimary = _data["isPrimary"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["isPrimary"] = this.isPrimary;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateProductImageCommand {
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;
}

export class ResultOfUpdateProductImageResponse implements IResultOfUpdateProductImageResponse {
    isSuccess?: boolean;
    data?: UpdateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductImageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductImageResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductImageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductImageResponse {
    isSuccess?: boolean;
    data?: UpdateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductImageResponse extends ProductImageDto implements IUpdateProductImageResponse {

    constructor(data?: IUpdateProductImageResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductImageResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductImageResponse extends IProductImageDto {
}

export class UpdateProductImageCommand implements IUpdateProductImageCommand {
    imageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;

    constructor(data?: IUpdateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.isPrimary = _data["isPrimary"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["isPrimary"] = this.isPrimary;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateProductImageCommand {
    imageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;
}

export class ResultOfProductQuestionDto implements IResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: ProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductQuestionDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: ProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ProductQuestionDto implements IProductQuestionDto {
    productQuestionId?: string;
    productId?: string;
    productName?: string;
    userId?: string;
    userName?: string;
    question?: string;
    answer?: string | undefined;
    answeredAt?: Date | undefined;
    answeredBy?: string | undefined;
    answeredByName?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productQuestionId = _data["productQuestionId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.question = _data["question"];
            this.answer = _data["answer"];
            this.answeredAt = _data["answeredAt"] ? new Date(_data["answeredAt"].toString()) : undefined as any;
            this.answeredBy = _data["answeredBy"];
            this.answeredByName = _data["answeredByName"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productQuestionId"] = this.productQuestionId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["question"] = this.question;
        data["answer"] = this.answer;
        data["answeredAt"] = this.answeredAt ? this.answeredAt.toISOString() : undefined as any;
        data["answeredBy"] = this.answeredBy;
        data["answeredByName"] = this.answeredByName;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductQuestionDto {
    productQuestionId?: string;
    productId?: string;
    productName?: string;
    userId?: string;
    userName?: string;
    question?: string;
    answer?: string | undefined;
    answeredAt?: Date | undefined;
    answeredBy?: string | undefined;
    answeredByName?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export class ResultOfPagedResultOfProductQuestionDto implements IResultOfPagedResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductQuestionDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductQuestionDto implements IPagedResultOfProductQuestionDto {
    items?: ProductQuestionDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductQuestionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductQuestionDto {
    items?: ProductQuestionDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfCreateProductQuestionResponse implements IResultOfCreateProductQuestionResponse {
    isSuccess?: boolean;
    data?: CreateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductQuestionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductQuestionResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductQuestionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductQuestionResponse {
    isSuccess?: boolean;
    data?: CreateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductQuestionResponse extends ProductQuestionDto implements ICreateProductQuestionResponse {

    constructor(data?: ICreateProductQuestionResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductQuestionResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductQuestionResponse extends IProductQuestionDto {
}

export class CreateProductQuestionCommand implements ICreateProductQuestionCommand {
    productId?: string;
    userId?: string;
    question?: string;
    status?: number;

    constructor(data?: ICreateProductQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.userId = _data["userId"];
            this.question = _data["question"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateProductQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["userId"] = this.userId;
        data["question"] = this.question;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateProductQuestionCommand {
    productId?: string;
    userId?: string;
    question?: string;
    status?: number;
}

export class ResultOfUpdateProductQuestionResponse implements IResultOfUpdateProductQuestionResponse {
    isSuccess?: boolean;
    data?: UpdateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductQuestionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductQuestionResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductQuestionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductQuestionResponse {
    isSuccess?: boolean;
    data?: UpdateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductQuestionResponse extends ProductQuestionDto implements IUpdateProductQuestionResponse {

    constructor(data?: IUpdateProductQuestionResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductQuestionResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductQuestionResponse extends IProductQuestionDto {
}

export class UpdateProductQuestionCommand implements IUpdateProductQuestionCommand {
    questionId?: string;
    question?: string;
    status?: number;

    constructor(data?: IUpdateProductQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.question = _data["question"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateProductQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["question"] = this.question;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateProductQuestionCommand {
    questionId?: string;
    question?: string;
    status?: number;
}

export class AnswerProductQuestionCommand implements IAnswerProductQuestionCommand {
    questionId?: string;
    answer?: string;
    answeredBy?: string;

    constructor(data?: IAnswerProductQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.answer = _data["answer"];
            this.answeredBy = _data["answeredBy"];
        }
    }

    static fromJS(data: any): AnswerProductQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerProductQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["answer"] = this.answer;
        data["answeredBy"] = this.answeredBy;
        return data;
    }
}

export interface IAnswerProductQuestionCommand {
    questionId?: string;
    answer?: string;
    answeredBy?: string;
}

export class AssignTagToProductCommand implements IAssignTagToProductCommand {
    productId?: string;
    tagId?: string;

    constructor(data?: IAssignTagToProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.tagId = _data["tagId"];
        }
    }

    static fromJS(data: any): AssignTagToProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTagToProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["tagId"] = this.tagId;
        return data;
    }
}

export interface IAssignTagToProductCommand {
    productId?: string;
    tagId?: string;
}

export class CreateProductTagCommand implements ICreateProductTagCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateProductTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateProductTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateProductTagCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdateProductTagCommand implements IUpdateProductTagCommand {
    tagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateProductTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateProductTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateProductTagCommand {
    tagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdateProductVariantRequest implements IUpdateProductVariantRequest {
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    imageUrl?: string | undefined;
    imageFile?: FileUploadDto | undefined;
    status?: number;

    constructor(data?: IUpdateProductVariantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.imageUrl = _data["imageUrl"];
            this.imageFile = _data["imageFile"] ? FileUploadDto.fromJS(_data["imageFile"]) : undefined as any;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateProductVariantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductVariantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["imageUrl"] = this.imageUrl;
        data["imageFile"] = this.imageFile ? this.imageFile.toJSON() : undefined as any;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateProductVariantRequest {
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    imageUrl?: string | undefined;
    imageFile?: FileUploadDto | undefined;
    status?: number;
}

export class UpdateProductVariantStockCommand implements IUpdateProductVariantStockCommand {
    variantId?: string;
    quantity?: number;

    constructor(data?: IUpdateProductVariantStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.variantId = _data["variantId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UpdateProductVariantStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductVariantStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variantId"] = this.variantId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUpdateProductVariantStockCommand {
    variantId?: string;
    quantity?: number;
}

export class ResultOfProductVariantDto implements IResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: ProductVariantDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductVariantDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: ProductVariantDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfPagedResultOfProductVariantDto implements IResultOfPagedResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductVariantDto;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductVariantDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductVariantDto;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductVariantDto implements IPagedResultOfProductVariantDto {
    items?: ProductVariantDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductVariantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductVariantDto {
    items?: ProductVariantDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CreatePurchaseOrderCommand implements ICreatePurchaseOrderCommand {
    expectedDate?: Date | undefined;
    items?: CreatePurchaseOrderItemRequest[];

    constructor(data?: ICreatePurchaseOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expectedDate = _data["expectedDate"] ? new Date(_data["expectedDate"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CreatePurchaseOrderItemRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePurchaseOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedDate"] = this.expectedDate ? this.expectedDate.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreatePurchaseOrderCommand {
    expectedDate?: Date | undefined;
    items?: CreatePurchaseOrderItemRequest[];
}

export class CreatePurchaseOrderItemRequest implements ICreatePurchaseOrderItemRequest {
    productId?: string;
    unitCost?: number;
    quantity?: number;

    constructor(data?: ICreatePurchaseOrderItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.unitCost = _data["unitCost"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): CreatePurchaseOrderItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePurchaseOrderItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["unitCost"] = this.unitCost;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface ICreatePurchaseOrderItemRequest {
    productId?: string;
    unitCost?: number;
    quantity?: number;
}

export class UpdatePurchaseOrderStatusCommand implements IUpdatePurchaseOrderStatusCommand {
    purchaseOrderId?: string;
    status?: number;

    constructor(data?: IUpdatePurchaseOrderStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseOrderId = _data["purchaseOrderId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdatePurchaseOrderStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePurchaseOrderStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseOrderId"] = this.purchaseOrderId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdatePurchaseOrderStatusCommand {
    purchaseOrderId?: string;
    status?: number;
}

export class ResultOfListOfRefreshToken implements IResultOfListOfRefreshToken {
    isSuccess?: boolean;
    data?: RefreshToken[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfRefreshToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(RefreshToken.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfRefreshToken {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfRefreshToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfRefreshToken {
    isSuccess?: boolean;
    data?: RefreshToken[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfPagedResultOfShipmentCarrierDto implements IResultOfPagedResultOfShipmentCarrierDto {
    isSuccess?: boolean;
    data?: PagedResultOfShipmentCarrierDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfShipmentCarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfShipmentCarrierDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfShipmentCarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfShipmentCarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfShipmentCarrierDto {
    isSuccess?: boolean;
    data?: PagedResultOfShipmentCarrierDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfShipmentCarrierDto implements IPagedResultOfShipmentCarrierDto {
    items?: ShipmentCarrierDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfShipmentCarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShipmentCarrierDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfShipmentCarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfShipmentCarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfShipmentCarrierDto {
    items?: ShipmentCarrierDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ShipmentCarrierDto implements IShipmentCarrierDto {
    shipmentCarrierId?: string;
    name?: string;
    code?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IShipmentCarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shipmentCarrierId = _data["shipmentCarrierId"];
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ShipmentCarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShipmentCarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipmentCarrierId"] = this.shipmentCarrierId;
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IShipmentCarrierDto {
    shipmentCarrierId?: string;
    name?: string;
    code?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export class ResultOfListOfShipmentCarrierDto implements IResultOfListOfShipmentCarrierDto {
    isSuccess?: boolean;
    data?: ShipmentCarrierDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfShipmentCarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShipmentCarrierDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfShipmentCarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfShipmentCarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfShipmentCarrierDto {
    isSuccess?: boolean;
    data?: ShipmentCarrierDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfShipmentCarrierDto implements IResultOfShipmentCarrierDto {
    isSuccess?: boolean;
    data?: ShipmentCarrierDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfShipmentCarrierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ShipmentCarrierDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfShipmentCarrierDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfShipmentCarrierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfShipmentCarrierDto {
    isSuccess?: boolean;
    data?: ShipmentCarrierDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateShipmentCarrierRequest implements ICreateShipmentCarrierRequest {
    name?: string;
    code?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICreateShipmentCarrierRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateShipmentCarrierRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShipmentCarrierRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateShipmentCarrierRequest {
    name?: string;
    code?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
}

export class UpdateShipmentCarrierRequest implements IUpdateShipmentCarrierRequest {
    name?: string;
    code?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateShipmentCarrierRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.code = _data["code"];
            this.description = _data["description"];
            this.website = _data["website"];
            this.phone = _data["phone"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateShipmentCarrierRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateShipmentCarrierRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["code"] = this.code;
        data["description"] = this.description;
        data["website"] = this.website;
        data["phone"] = this.phone;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateShipmentCarrierRequest {
    name?: string;
    code?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    phone?: string | undefined;
    isActive?: boolean;
}

export class ResultOfPagedResultOfUserAddress implements IResultOfPagedResultOfUserAddress {
    isSuccess?: boolean;
    data?: PagedResultOfUserAddress | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfUserAddress.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfUserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfUserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfUserAddress {
    isSuccess?: boolean;
    data?: PagedResultOfUserAddress | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfUserAddress implements IPagedResultOfUserAddress {
    items?: UserAddress[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserAddress.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfUserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfUserAddress {
    items?: UserAddress[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfUserAddress implements IResultOfUserAddress {
    isSuccess?: boolean;
    data?: UserAddress;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUserAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UserAddress.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUserAddress {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUserAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUserAddress {
    isSuccess?: boolean;
    data?: UserAddress;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateUserAddressCommand implements ICreateUserAddressCommand {
    userId?: string;
    addressLine1?: string;
    addressLine2?: string | undefined;
    city?: string;
    state?: string;
    country?: string;
    postalCode?: string;
    addressType?: number;
    isDefault?: boolean;

    constructor(data?: ICreateUserAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postalCode = _data["postalCode"];
            this.addressType = _data["addressType"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): CreateUserAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postalCode"] = this.postalCode;
        data["addressType"] = this.addressType;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface ICreateUserAddressCommand {
    userId?: string;
    addressLine1?: string;
    addressLine2?: string | undefined;
    city?: string;
    state?: string;
    country?: string;
    postalCode?: string;
    addressType?: number;
    isDefault?: boolean;
}

export class UpdateUserAddressCommand implements IUpdateUserAddressCommand {
    addressId?: string;
    userId?: string;
    addressLine1?: string;
    addressLine2?: string | undefined;
    city?: string;
    state?: string;
    country?: string;
    postalCode?: string;
    addressType?: number;
    isDefault?: boolean;

    constructor(data?: IUpdateUserAddressCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addressId = _data["addressId"];
            this.userId = _data["userId"];
            this.addressLine1 = _data["addressLine1"];
            this.addressLine2 = _data["addressLine2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.country = _data["country"];
            this.postalCode = _data["postalCode"];
            this.addressType = _data["addressType"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): UpdateUserAddressCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserAddressCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressId"] = this.addressId;
        data["userId"] = this.userId;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["postalCode"] = this.postalCode;
        data["addressType"] = this.addressType;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IUpdateUserAddressCommand {
    addressId?: string;
    userId?: string;
    addressLine1?: string;
    addressLine2?: string | undefined;
    city?: string;
    state?: string;
    country?: string;
    postalCode?: string;
    addressType?: number;
    isDefault?: boolean;
}

export class ResultOfUser implements IResultOfUser {
    isSuccess?: boolean;
    data?: User;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? User.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUser {
    isSuccess?: boolean;
    data?: User;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateUserCommand implements ICreateUserCommand {
    email?: string;
    username?: string;
    passwordHash?: string;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.username = _data["username"];
            this.passwordHash = _data["passwordHash"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        data["passwordHash"] = this.passwordHash;
        return data;
    }
}

export interface ICreateUserCommand {
    email?: string;
    username?: string;
    passwordHash?: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    userId?: string;
    email?: string | undefined;
    username?: string | undefined;
    passwordHash?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.username = _data["username"];
            this.passwordHash = _data["passwordHash"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.dateOfBirth = _data["dateOfBirth"] ? new Date(_data["dateOfBirth"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["username"] = this.username;
        data["passwordHash"] = this.passwordHash;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : undefined as any;
        return data;
    }
}

export interface IUpdateUserCommand {
    userId?: string;
    email?: string | undefined;
    username?: string | undefined;
    passwordHash?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    dateOfBirth?: Date | undefined;
}

export class AssignUserRoleCommand implements IAssignUserRoleCommand {
    userId?: string;
    roleId?: string;
    assignedBy?: string;

    constructor(data?: IAssignUserRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.assignedBy = _data["assignedBy"];
        }
    }

    static fromJS(data: any): AssignUserRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignUserRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["assignedBy"] = this.assignedBy;
        return data;
    }
}

export interface IAssignUserRoleCommand {
    userId?: string;
    roleId?: string;
    assignedBy?: string;
}

export class RemoveUserRoleCommand implements IRemoveUserRoleCommand {
    userId?: string;
    roleId?: string;

    constructor(data?: IRemoveUserRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): RemoveUserRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveUserRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IRemoveUserRoleCommand {
    userId?: string;
    roleId?: string;
}

export class ResultOfPagedResultOfUserRoleAssignment implements IResultOfPagedResultOfUserRoleAssignment {
    isSuccess?: boolean;
    data?: PagedResultOfUserRoleAssignment | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfUserRoleAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfUserRoleAssignment.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfUserRoleAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfUserRoleAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfUserRoleAssignment {
    isSuccess?: boolean;
    data?: PagedResultOfUserRoleAssignment | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfUserRoleAssignment implements IPagedResultOfUserRoleAssignment {
    items?: UserRoleAssignment[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfUserRoleAssignment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRoleAssignment.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfUserRoleAssignment {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserRoleAssignment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfUserRoleAssignment {
    items?: UserRoleAssignment[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfPagedResultOfUserRole implements IResultOfPagedResultOfUserRole {
    isSuccess?: boolean;
    data?: PagedResultOfUserRole | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfUserRole.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfUserRole {
    isSuccess?: boolean;
    data?: PagedResultOfUserRole | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfUserRole implements IPagedResultOfUserRole {
    items?: UserRole[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserRole.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfUserRole {
    items?: UserRole[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfUserRole implements IResultOfUserRole {
    isSuccess?: boolean;
    data?: UserRole;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UserRole.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUserRole {
    isSuccess?: boolean;
    data?: UserRole;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfListOfUserRole implements IResultOfListOfUserRole {
    isSuccess?: boolean;
    data?: UserRole[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(UserRole.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfUserRole {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfUserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfUserRole {
    isSuccess?: boolean;
    data?: UserRole[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateUserRoleCommand implements ICreateUserRoleCommand {
    roleName?: string;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: ICreateUserRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateUserRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateUserRoleCommand {
    roleName?: string;
    description?: string | undefined;
    isActive?: boolean;
}

export class UpdateUserRoleCommand implements IUpdateUserRoleCommand {
    roleId?: string;
    roleName?: string;
    description?: string | undefined;
    isActive?: boolean;

    constructor(data?: IUpdateUserRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): UpdateUserRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IUpdateUserRoleCommand {
    roleId?: string;
    roleName?: string;
    description?: string | undefined;
    isActive?: boolean;
}

export class ResultOfPagedResultOfUserSession implements IResultOfPagedResultOfUserSession {
    isSuccess?: boolean;
    data?: PagedResultOfUserSession | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfUserSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfUserSession.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfUserSession {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfUserSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfUserSession {
    isSuccess?: boolean;
    data?: PagedResultOfUserSession | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfUserSession implements IPagedResultOfUserSession {
    items?: UserSession[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfUserSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserSession.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfUserSession {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUserSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfUserSession {
    items?: UserSession[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}