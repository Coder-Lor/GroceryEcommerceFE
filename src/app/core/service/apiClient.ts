//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.1.0 (NJsonSchema v11.5.1.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    registerAccount(request: RegisterCommand): Observable<ResultOfRegisterResponse> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfRegisterResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfRegisterResponse>;
        }));
    }

    protected processRegisterAccount(response: HttpResponseBase): Observable<ResultOfRegisterResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfRegisterResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(request: LoginCommand): Observable<ResultOfLoginResponse> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfLoginResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfLoginResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResultOfLoginResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfLoginResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    forgotPassword(request: ForgotPasswordCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(request: ResetPasswordCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class BrandClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getBrandsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandsPaging(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCountByBrand(brandId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/product-count/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCountByBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCountByBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductCountByBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrandById(brandId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBrand(brandId: string, request: UpdateBrandCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteBrand(brandId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrandByName(name: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getBrandBySlug(slug: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/slug/{slug}";
        if (slug === undefined || slug === null)
            throw new globalThis.Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBrandBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBrandBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetBrandBySlug(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createBrand(request: CreateBrandCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBrand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBrand(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateBrand(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateBrandStatus(brandId: string, request: UpdateBrandStatusCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Brand/status/{brandId}";
        if (brandId === undefined || brandId === null)
            throw new globalThis.Error("The parameter 'brandId' must be defined.");
        url_ = url_.replace("{brandId}", encodeURIComponent("" + brandId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBrandStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBrandStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateBrandStatus(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CartClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getShoppingCart(userId: string): Observable<ResultOfShoppingCartDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShoppingCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShoppingCartDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShoppingCartDto>;
        }));
    }

    protected processGetShoppingCart(response: HttpResponseBase): Observable<ResultOfShoppingCartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShoppingCartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createShoppingCart(userId: string): Observable<ResultOfShoppingCartDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShoppingCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShoppingCartDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShoppingCartDto>;
        }));
    }

    protected processCreateShoppingCart(response: HttpResponseBase): Observable<ResultOfShoppingCartDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShoppingCartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clearShoppingCart(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearShoppingCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processClearShoppingCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCartTotal(userId: string): Observable<ResultOfDecimal> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/total";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCartTotal(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCartTotal(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfDecimal>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfDecimal>;
        }));
    }

    protected processGetCartTotal(response: HttpResponseBase): Observable<ResultOfDecimal> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfDecimal.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCartItemCount(userId: string): Observable<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/count";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCartItemCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCartItemCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        }));
    }

    protected processGetCartItemCount(response: HttpResponseBase): Observable<ResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCartSummary(userId: string): Observable<ResultOfCartSummaryDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/summary";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCartSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCartSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCartSummaryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCartSummaryDto>;
        }));
    }

    protected processGetCartSummary(response: HttpResponseBase): Observable<ResultOfCartSummaryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCartSummaryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getShoppingCartItems(userId: string): Observable<ResultOfListOfShoppingCartItemDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/items";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShoppingCartItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShoppingCartItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfShoppingCartItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfShoppingCartItemDto>;
        }));
    }

    protected processGetShoppingCartItems(response: HttpResponseBase): Observable<ResultOfListOfShoppingCartItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfShoppingCartItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addItemToCart(request: AddToCartRequest): Observable<ResultOfShoppingCartItemDto> {
        let url_ = this.baseUrl + "/api/Cart/items";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItemToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItemToCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfShoppingCartItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfShoppingCartItemDto>;
        }));
    }

    protected processAddItemToCart(response: HttpResponseBase): Observable<ResultOfShoppingCartItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfShoppingCartItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCartItemQuantity(itemId: string, request: UpdateQuantityRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/items/{itemId}/quantity";
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCartItemQuantity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCartItemQuantity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateCartItemQuantity(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItemFromCart(itemId: string, request: RemoveItemRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/items/{itemId}";
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemFromCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemFromCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItemFromCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItemByProduct(userId: string, productId: string, variantId: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/products/{productId}?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (variantId !== undefined && variantId !== null)
            url_ += "variantId=" + encodeURIComponent("" + variantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItemByProduct(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    validateCartItems(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/validate";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateCartItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateCartItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processValidateCartItems(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWishlist(userId: string): Observable<ResultOfWishlistDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfWishlistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfWishlistDto>;
        }));
    }

    protected processGetWishlist(response: HttpResponseBase): Observable<ResultOfWishlistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfWishlistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createWishlist(userId: string): Observable<ResultOfWishlistDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfWishlistDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfWishlistDto>;
        }));
    }

    protected processCreateWishlist(response: HttpResponseBase): Observable<ResultOfWishlistDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfWishlistDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getWishlistItems(userId: string): Observable<ResultOfListOfWishlistItemDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWishlistItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWishlistItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfWishlistItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfWishlistItemDto>;
        }));
    }

    protected processGetWishlistItems(response: HttpResponseBase): Observable<ResultOfListOfWishlistItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfWishlistItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addItemToWishlist(userId: string, request: AddToWishlistRequest): Observable<ResultOfWishlistItemDto> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItemToWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItemToWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfWishlistItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfWishlistItemDto>;
        }));
    }

    protected processAddItemToWishlist(response: HttpResponseBase): Observable<ResultOfWishlistItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfWishlistItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItemFromWishlist(userId: string, itemId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items/{itemId}";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemFromWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemFromWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItemFromWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeItemByProductFromWishlist(userId: string, productId: string, variantId: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/products/{productId}?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (variantId !== undefined && variantId !== null)
            url_ += "variantId=" + encodeURIComponent("" + variantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemByProductFromWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemByProductFromWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveItemByProductFromWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    isProductInWishlist(userId: string, productId: string, variantId: string | null | undefined): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/products/{productId}/check?";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (variantId !== undefined && variantId !== null)
            url_ += "variantId=" + encodeURIComponent("" + variantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsProductInWishlist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsProductInWishlist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processIsProductInWishlist(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    moveItemToCart(userId: string, itemId: string, request: MoveToCartRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/wishlist/items/{itemId}/move-to-cart";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (itemId === undefined || itemId === null)
            throw new globalThis.Error("The parameter 'itemId' must be defined.");
        url_ = url_.replace("{itemId}", encodeURIComponent("" + itemId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveItemToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveItemToCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processMoveItemToCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    mergeCarts(userId: string, request: MergeCartsRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/merge";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMergeCarts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMergeCarts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processMergeCarts(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    applyCoupon(userId: string, request: ApplyCouponRequest): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/coupon";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApplyCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApplyCoupon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processApplyCoupon(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeCoupon(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/coupon";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveCoupon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveCoupon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRemoveCoupon(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    saveCartForLater(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/save-for-later";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveCartForLater(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveCartForLater(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processSaveCartForLater(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    restoreSavedCart(userId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Cart/users/{userId}/restore";
        if (userId === undefined || userId === null)
            throw new globalThis.Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreSavedCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreSavedCart(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processRestoreSavedCart(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getCategoriesPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoriesPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoriesPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfCategoryDto>;
        }));
    }

    protected processGetCategoriesPaging(response: HttpResponseBase): Observable<ResultOfPagedResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductCountByCategory(categoryId: string): Observable<ResultOfInteger> {
        let url_ = this.baseUrl + "/api/Category/product-count/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductCountByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductCountByCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfInteger>;
        }));
    }

    protected processGetProductCountByCategory(response: HttpResponseBase): Observable<ResultOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfInteger.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSubCategories(categoryId: string): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/sub-categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetSubCategories(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryPath(categoryId: string): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/category-path/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryPath(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryPath(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetCategoryPath(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryTree(): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/category-tree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetCategoryTree(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRootCategories(): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/root-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRootCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRootCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetRootCategories(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getActiveCategories(): Observable<ResultOfListOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/active-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfListOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfListOfCategoryDto>;
        }));
    }

    protected processGetActiveCategories(response: HttpResponseBase): Observable<ResultOfListOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfListOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryById(categoryId: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processGetCategoryById(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategory(categoryId: string, request: UpdateCategoryCommand): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processUpdateCategory(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteCategory(categoryId: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryByName(name: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processGetCategoryByName(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getCategoryBySlug(slug: string): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/slug/{slug}";
        if (slug === undefined || slug === null)
            throw new globalThis.Error("The parameter 'slug' must be defined.");
        url_ = url_.replace("{slug}", encodeURIComponent("" + slug));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCategoryBySlug(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryBySlug(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processGetCategoryBySlug(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createCategory(request: CreateCategoryCommand): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processCreateCategory(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryExistsById(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryExistsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryExistsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryExistsById(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateCategoryStatus(categoryId: string, request: UpdateCategoryStatusCommand): Observable<ResultOfCategoryDto> {
        let url_ = this.baseUrl + "/api/Category/status/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCategoryStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCategoryStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCategoryDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCategoryDto>;
        }));
    }

    protected processUpdateCategoryStatus(response: HttpResponseBase): Observable<ResultOfCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryExistsByName(name: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/exists-by-name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryExistsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryExistsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryExistsByName(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryHasSubCategories(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/has-sub-categories/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryHasSubCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryHasSubCategories(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryHasSubCategories(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkCategoryInUse(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/in-use/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCategoryInUse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCategoryInUse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckCategoryInUse(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkIsRootCategory(categoryId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/Category/is-root/{categoryId}";
        if (categoryId === undefined || categoryId === null)
            throw new globalThis.Error("The parameter 'categoryId' must be defined.");
        url_ = url_.replace("{categoryId}", encodeURIComponent("" + categoryId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIsRootCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIsRootCategory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckIsRootCategory(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class FileUploadClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    uploadImage(file: FileParameter | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FileUpload/upload-image";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadMultipleImages(files: FileParameter[] | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FileUpload/upload-multiple-images";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadMultipleImages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadMultipleImages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUploadMultipleImages(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteImage(blobName: string | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/FileUpload/delete-image?";
        if (blobName === null)
            throw new globalThis.Error("The parameter 'blobName' cannot be null.");
        else if (blobName !== undefined)
            url_ += "blobName=" + encodeURIComponent("" + blobName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteImage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    checkAttributeExistsById(attributeId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/exists-by-id/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttributeExistsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttributeExistsById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckAttributeExistsById(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkAttributeExistsByName(name: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/exists-by-name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttributeExistsByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttributeExistsByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckAttributeExistsByName(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    checkAttributeInUse(attributeId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/in-use/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckAttributeInUse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckAttributeInUse(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processCheckAttributeInUse(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllAttributes(): Observable<ResultOfPagedResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        }));
    }

    protected processGetAllAttributes(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAttributeById(attributeId: string): Observable<ResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/by-id/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttributeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttributeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductAttributeDto>;
        }));
    }

    protected processGetAttributeById(response: HttpResponseBase): Observable<ResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAttributeByName(name: string): Observable<ResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/by-name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttributeByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttributeByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductAttributeDto>;
        }));
    }

    protected processGetAttributeByName(response: HttpResponseBase): Observable<ResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAttributesByType(attributeType: number | undefined, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/by-type?";
        if (attributeType === null)
            throw new globalThis.Error("The parameter 'attributeType' cannot be null.");
        else if (attributeType !== undefined)
            url_ += "attributeType=" + encodeURIComponent("" + attributeType) + "&";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttributesByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttributesByType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        }));
    }

    protected processGetAttributesByType(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRequiredAttributes(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeDto> {
        let url_ = this.baseUrl + "/api/ProductAttribute/required?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequiredAttributes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequiredAttributes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeDto>;
        }));
    }

    protected processGetRequiredAttributes(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createAttribute(command: CreateProductAttributeCommand): Observable<ResultOfCreateProductAttributeResponse> {
        let url_ = this.baseUrl + "/api/ProductAttribute/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductAttributeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductAttributeResponse>;
        }));
    }

    protected processCreateAttribute(response: HttpResponseBase): Observable<ResultOfCreateProductAttributeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductAttributeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateAttribute(command: UpdateProductAttributeCommand): Observable<ResultOfUpdateProductAttributeResponse> {
        let url_ = this.baseUrl + "/api/ProductAttribute/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductAttributeResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductAttributeResponse>;
        }));
    }

    protected processUpdateAttribute(response: HttpResponseBase): Observable<ResultOfUpdateProductAttributeResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductAttributeResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteAttribute(attributeId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttribute/delete/{attributeId}";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDeleteAttribute(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductAttributeValueClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getById(valueId: string): Observable<ResultOfProductAttributeValueDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/by-id/{valueId}";
        if (valueId === undefined || valueId === null)
            throw new globalThis.Error("The parameter 'valueId' must be defined.");
        url_ = url_.replace("{valueId}", encodeURIComponent("" + valueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductAttributeValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductAttributeValueDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductAttributeValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductAttributeValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/by-product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByAttribute(attributeId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/by-attribute/{attributeId}?";
        if (attributeId === undefined || attributeId === null)
            throw new globalThis.Error("The parameter 'attributeId' must be defined.");
        url_ = url_.replace("{attributeId}", encodeURIComponent("" + attributeId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByAttribute(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByAttribute(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductAttributeValueDto>;
        }));
    }

    protected processGetByAttribute(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductAttributeValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductAttributeValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductAttributeValueCommand): Observable<ResultOfCreateProductAttributeValueResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductAttributeValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductAttributeValueResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductAttributeValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductAttributeValueResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductAttributeValueCommand): Observable<ResultOfUpdateProductAttributeValueResponse> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductAttributeValueResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductAttributeValueResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductAttributeValueResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductAttributeValueResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(valueId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductAttributeValue/delete/{valueId}";
        if (valueId === undefined || valueId === null)
            throw new globalThis.Error("The parameter 'valueId' must be defined.");
        url_ = url_.replace("{valueId}", encodeURIComponent("" + valueId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    create(name: string | undefined, slug: string | null | undefined, sku: string | undefined, description: string | undefined, shortDescription: string | null | undefined, price: number | undefined, discountPrice: number | null | undefined, cost: number | null | undefined, stockQuantity: number | undefined, minStockLevel: number | undefined, weight: number | null | undefined, dimensions: string | null | undefined, categoryId: string | undefined, brandId: string | null | undefined, status: number | undefined, isFeatured: boolean | undefined, isDigital: boolean | undefined, metaTitle: string | null | undefined, metaDescription: string | null | undefined, imageFiles: FileParameter[] | null | undefined, imageAltTexts: string[] | null | undefined, imageDisplayOrders: number[] | null | undefined, imageIsPrimary: boolean[] | null | undefined, variants: CreateProductVariantRequest[] | null | undefined, attributes: CreateProductAttributeValueRequest[] | null | undefined, tagIds: string[] | null | undefined): Observable<ResultOfCreateProductResponse> {
        let url_ = this.baseUrl + "/api/Product/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new globalThis.Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (slug !== null && slug !== undefined)
            content_.append("Slug", slug.toString());
        if (sku === null || sku === undefined)
            throw new globalThis.Error("The parameter 'sku' cannot be null.");
        else
            content_.append("Sku", sku.toString());
        if (description === null || description === undefined)
            throw new globalThis.Error("The parameter 'description' cannot be null.");
        else
            content_.append("Description", description.toString());
        if (shortDescription !== null && shortDescription !== undefined)
            content_.append("ShortDescription", shortDescription.toString());
        if (price === null || price === undefined)
            throw new globalThis.Error("The parameter 'price' cannot be null.");
        else
            content_.append("Price", price.toString());
        if (discountPrice !== null && discountPrice !== undefined)
            content_.append("DiscountPrice", discountPrice.toString());
        if (cost !== null && cost !== undefined)
            content_.append("Cost", cost.toString());
        if (stockQuantity === null || stockQuantity === undefined)
            throw new globalThis.Error("The parameter 'stockQuantity' cannot be null.");
        else
            content_.append("StockQuantity", stockQuantity.toString());
        if (minStockLevel === null || minStockLevel === undefined)
            throw new globalThis.Error("The parameter 'minStockLevel' cannot be null.");
        else
            content_.append("MinStockLevel", minStockLevel.toString());
        if (weight !== null && weight !== undefined)
            content_.append("Weight", weight.toString());
        if (dimensions !== null && dimensions !== undefined)
            content_.append("Dimensions", dimensions.toString());
        if (categoryId === null || categoryId === undefined)
            throw new globalThis.Error("The parameter 'categoryId' cannot be null.");
        else
            content_.append("CategoryId", categoryId.toString());
        if (brandId !== null && brandId !== undefined)
            content_.append("BrandId", brandId.toString());
        if (status === null || status === undefined)
            throw new globalThis.Error("The parameter 'status' cannot be null.");
        else
            content_.append("Status", status.toString());
        if (isFeatured === null || isFeatured === undefined)
            throw new globalThis.Error("The parameter 'isFeatured' cannot be null.");
        else
            content_.append("IsFeatured", isFeatured.toString());
        if (isDigital === null || isDigital === undefined)
            throw new globalThis.Error("The parameter 'isDigital' cannot be null.");
        else
            content_.append("IsDigital", isDigital.toString());
        if (metaTitle !== null && metaTitle !== undefined)
            content_.append("MetaTitle", metaTitle.toString());
        if (metaDescription !== null && metaDescription !== undefined)
            content_.append("MetaDescription", metaDescription.toString());
        if (imageFiles !== null && imageFiles !== undefined)
            imageFiles.forEach(item_ => content_.append("ImageFiles", item_.data, item_.fileName ? item_.fileName : "ImageFiles") );
        if (imageAltTexts !== null && imageAltTexts !== undefined)
            imageAltTexts.forEach(item_ => content_.append("ImageAltTexts", item_.toString()));
        if (imageDisplayOrders !== null && imageDisplayOrders !== undefined)
            imageDisplayOrders.forEach(item_ => content_.append("ImageDisplayOrders", item_.toString()));
        if (imageIsPrimary !== null && imageIsPrimary !== undefined)
            imageIsPrimary.forEach(item_ => content_.append("ImageIsPrimary", item_.toString()));
        if (variants !== null && variants !== undefined)
            variants.forEach(item_ => content_.append("Variants", item_.toString()));
        if (attributes !== null && attributes !== undefined)
            attributes.forEach(item_ => content_.append("Attributes", item_.toString()));
        if (tagIds !== null && tagIds !== undefined)
            tagIds.forEach(item_ => content_.append("TagIds", item_.toString()));

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createWithUrls(command: CreateProductCommand): Observable<ResultOfCreateProductResponse> {
        let url_ = this.baseUrl + "/api/Product/create-with-urls";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWithUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWithUrls(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductResponse>;
        }));
    }

    protected processCreateWithUrls(response: HttpResponseBase): Observable<ResultOfCreateProductResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductImageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getById(imageId: string): Observable<ResultOfProductImageDto> {
        let url_ = this.baseUrl + "/api/ProductImage/by-id/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new globalThis.Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductImageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductImageDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductImageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductImageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductImageDto> {
        let url_ = this.baseUrl + "/api/ProductImage/by-product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductImageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductImageDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductImageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductImageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductImageCommand): Observable<ResultOfCreateProductImageResponse> {
        let url_ = this.baseUrl + "/api/ProductImage/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductImageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductImageResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductImageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductImageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductImageCommand): Observable<ResultOfUpdateProductImageResponse> {
        let url_ = this.baseUrl + "/api/ProductImage/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductImageResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductImageResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductImageResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductImageResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setPrimary(imageId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductImage/set-primary/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new globalThis.Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPrimary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPrimary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processSetPrimary(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(imageId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductImage/delete/{imageId}";
        if (imageId === undefined || imageId === null)
            throw new globalThis.Error("The parameter 'imageId' must be defined.");
        url_ = url_.replace("{imageId}", encodeURIComponent("" + imageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductQuestionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getById(questionId: string): Observable<ResultOfProductQuestionDto> {
        let url_ = this.baseUrl + "/api/ProductQuestion/by-id/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new globalThis.Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductQuestionDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductQuestionDto> {
        let url_ = this.baseUrl + "/api/ProductQuestion/by-product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUnanswered(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<ResultOfPagedResultOfProductQuestionDto> {
        let url_ = this.baseUrl + "/api/ProductQuestion/unanswered?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUnanswered(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUnanswered(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductQuestionDto>;
        }));
    }

    protected processGetUnanswered(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductQuestionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductQuestionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateProductQuestionCommand): Observable<ResultOfCreateProductQuestionResponse> {
        let url_ = this.baseUrl + "/api/ProductQuestion/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductQuestionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductQuestionResponse>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResultOfCreateProductQuestionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductQuestionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(command: UpdateProductQuestionCommand): Observable<ResultOfUpdateProductQuestionResponse> {
        let url_ = this.baseUrl + "/api/ProductQuestion/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductQuestionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductQuestionResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<ResultOfUpdateProductQuestionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductQuestionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    answer(command: AnswerProductQuestionCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductQuestion/answer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAnswer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAnswer(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processAnswer(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(questionId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductQuestion/delete/{questionId}";
        if (questionId === undefined || questionId === null)
            throw new globalThis.Error("The parameter 'questionId' must be defined.");
        url_ = url_.replace("{questionId}", encodeURIComponent("" + questionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductTagAssignmentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    assignTagToProduct(request: AssignTagToProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignTagToProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignTagToProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAssignTagToProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeTagFromProduct(productId: string, tagId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/{productId}/{tagId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveTagFromProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveTagFromProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveTagFromProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeAllTagsFromProduct(productId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/product/{productId}";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveAllTagsFromProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveAllTagsFromProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processRemoveAllTagsFromProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByTag(tagId: string, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTagAssignment/tag/{tagId}?";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetByTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductTagClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    getProductTagsPaging(page: number | undefined, pageSize: number | undefined, search: string | null | undefined, sortBy: string | null | undefined, sortDirection: SortDirection | undefined, filters: FilterCriteria[] | undefined, entityType: string | null | undefined, availableFields: SearchableField[] | null | undefined, hasFilters: boolean | undefined, hasSearch: boolean | undefined, hasSorting: boolean | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/paging?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (search !== undefined && search !== null)
            url_ += "Search=" + encodeURIComponent("" + search) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection === null)
            throw new globalThis.Error("The parameter 'sortDirection' cannot be null.");
        else if (sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (filters === null)
            throw new globalThis.Error("The parameter 'filters' cannot be null.");
        else if (filters !== undefined)
            filters && filters.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (entityType !== undefined && entityType !== null)
            url_ += "EntityType=" + encodeURIComponent("" + entityType) + "&";
        if (availableFields !== undefined && availableFields !== null)
            availableFields && availableFields.forEach((item, index) => {
                for (const attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "AvailableFields[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        if (hasFilters === null)
            throw new globalThis.Error("The parameter 'hasFilters' cannot be null.");
        else if (hasFilters !== undefined)
            url_ += "HasFilters=" + encodeURIComponent("" + hasFilters) + "&";
        if (hasSearch === null)
            throw new globalThis.Error("The parameter 'hasSearch' cannot be null.");
        else if (hasSearch !== undefined)
            url_ += "HasSearch=" + encodeURIComponent("" + hasSearch) + "&";
        if (hasSorting === null)
            throw new globalThis.Error("The parameter 'hasSorting' cannot be null.");
        else if (hasSorting !== undefined)
            url_ += "HasSorting=" + encodeURIComponent("" + hasSorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductTagsPaging(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTagById(tagId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/{tagId}";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductTagById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateProductTag(tagId: string, request: UpdateProductTagCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/{tagId}";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProductTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProductTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdateProductTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteProductTag(tagId: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/{tagId}";
        if (tagId === undefined || tagId === null)
            throw new globalThis.Error("The parameter 'tagId' must be defined.");
        url_ = url_.replace("{tagId}", encodeURIComponent("" + tagId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProductTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProductTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDeleteProductTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getProductTagByName(name: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag/name/{name}";
        if (name === undefined || name === null)
            throw new globalThis.Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProductTagByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductTagByName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processGetProductTagByName(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    createProductTag(request: CreateProductTagCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ProductTag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProductTag(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProductTag(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processCreateProductTag(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ProductVariantClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "https://localhost:44394";
    }

    createVariant(command: CreateProductVariantCommand): Observable<ResultOfCreateProductVariantResponse> {
        let url_ = this.baseUrl + "/api/ProductVariant/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfCreateProductVariantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfCreateProductVariantResponse>;
        }));
    }

    protected processCreateVariant(response: HttpResponseBase): Observable<ResultOfCreateProductVariantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfCreateProductVariantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVariant(command: UpdateProductVariantCommand): Observable<ResultOfUpdateProductVariantResponse> {
        let url_ = this.baseUrl + "/api/ProductVariant/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfUpdateProductVariantResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfUpdateProductVariantResponse>;
        }));
    }

    protected processUpdateVariant(response: HttpResponseBase): Observable<ResultOfUpdateProductVariantResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfUpdateProductVariantResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteVariant(variantId: string): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/delete/{variantId}";
        if (variantId === undefined || variantId === null)
            throw new globalThis.Error("The parameter 'variantId' must be defined.");
        url_ = url_.replace("{variantId}", encodeURIComponent("" + variantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteVariant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteVariant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processDeleteVariant(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateVariantStock(command: UpdateProductVariantStockCommand): Observable<ResultOfBoolean> {
        let url_ = this.baseUrl + "/api/ProductVariant/update-stock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateVariantStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateVariantStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfBoolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfBoolean>;
        }));
    }

    protected processUpdateVariantStock(response: HttpResponseBase): Observable<ResultOfBoolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfBoolean.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(variantId: string): Observable<ResultOfProductVariantDto> {
        let url_ = this.baseUrl + "/api/ProductVariant/by-id/{variantId}";
        if (variantId === undefined || variantId === null)
            throw new globalThis.Error("The parameter 'variantId' must be defined.");
        url_ = url_.replace("{variantId}", encodeURIComponent("" + variantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfProductVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfProductVariantDto>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResultOfProductVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfProductVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByProduct(productId: string, page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined): Observable<ResultOfPagedResultOfProductVariantDto> {
        let url_ = this.baseUrl + "/api/ProductVariant/product/{productId}?";
        if (productId === undefined || productId === null)
            throw new globalThis.Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByProduct(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
        }));
    }

    protected processGetByProduct(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getLowStock(page: number | undefined, pageSize: number | undefined, sortBy: string | null | undefined, sortDirection: string | null | undefined, threshold: number | undefined): Observable<ResultOfPagedResultOfProductVariantDto> {
        let url_ = this.baseUrl + "/api/ProductVariant/low-stock?";
        if (page === null)
            throw new globalThis.Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new globalThis.Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDirection !== undefined && sortDirection !== null)
            url_ += "sortDirection=" + encodeURIComponent("" + sortDirection) + "&";
        if (threshold === null)
            throw new globalThis.Error("The parameter 'threshold' cannot be null.");
        else if (threshold !== undefined)
            url_ += "threshold=" + encodeURIComponent("" + threshold) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLowStock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLowStock(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResultOfPagedResultOfProductVariantDto>;
        }));
    }

    protected processGetLowStock(response: HttpResponseBase): Observable<ResultOfPagedResultOfProductVariantDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPagedResultOfProductVariantDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ResultOfRegisterResponse implements IResultOfRegisterResponse {
    isSuccess?: boolean;
    data?: RegisterResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? RegisterResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfRegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfRegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfRegisterResponse {
    isSuccess?: boolean;
    data?: RegisterResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class RegisterResponse implements IRegisterResponse {
    userId?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): RegisterResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IRegisterResponse {
    userId?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;
}

export class RegisterCommand implements IRegisterCommand {
    email?: string;
    username?: string;
    password?: string;

    constructor(data?: IRegisterCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["username"] = this.username;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterCommand {
    email?: string;
    username?: string;
    password?: string;
}

export class ResultOfLoginResponse implements IResultOfLoginResponse {
    isSuccess?: boolean;
    data?: LoginResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfLoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? LoginResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfLoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfLoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfLoginResponse {
    isSuccess?: boolean;
    data?: LoginResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class LoginResponse implements ILoginResponse {
    userId?: string;
    email?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;

    constructor(data?: ILoginResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.email = _data["email"];
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): LoginResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["email"] = this.email;
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ILoginResponse {
    userId?: string;
    email?: string;
    token?: string;
    refreshToken?: string;
    expiresAt?: Date;
}

export class LoginCommand implements ILoginCommand {
    emailOrUsername?: string;
    password?: string;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailOrUsername = _data["emailOrUsername"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailOrUsername"] = this.emailOrUsername;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginCommand {
    emailOrUsername?: string;
    password?: string;
}

export class ResultOfBoolean implements IResultOfBoolean {
    isSuccess?: boolean;
    data?: boolean;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfBoolean) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfBoolean {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfBoolean();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfBoolean {
    isSuccess?: boolean;
    data?: boolean;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string;
    resetToken?: string;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetToken = _data["resetToken"];
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetToken"] = this.resetToken;
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string;
    resetToken?: string;
    oldPassword?: string | undefined;
    newPassword?: string | undefined;
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class FilterCriteria implements IFilterCriteria {
    fieldName?: string;
    value?: any;
    operator?: FilterOperator;

    constructor(data?: IFilterCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): FilterCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new FilterCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        data["operator"] = this.operator;
        return data;
    }
}

export interface IFilterCriteria {
    fieldName?: string;
    value?: any;
    operator?: FilterOperator;
}

export enum FilterOperator {
    Equals = 0,
    NotEquals = 1,
    Contains = 2,
    NotContains = 3,
    StartsWith = 4,
    EndsWith = 5,
    GreaterThan = 6,
    GreaterThanOrEqual = 7,
    LessThan = 8,
    LessThanOrEqual = 9,
    In = 10,
    NotIn = 11,
    IsNull = 12,
    IsNotNull = 13,
}

export class SearchableField implements ISearchableField {
    fieldName?: string;
    fieldType?: string;
    isSearchable?: boolean;
    isSortable?: boolean;
    isFilterable?: boolean;

    constructor(data?: ISearchableField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.fieldType = _data["fieldType"];
            this.isSearchable = _data["isSearchable"];
            this.isSortable = _data["isSortable"];
            this.isFilterable = _data["isFilterable"];
        }
    }

    static fromJS(data: any): SearchableField {
        data = typeof data === 'object' ? data : {};
        let result = new SearchableField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["fieldType"] = this.fieldType;
        data["isSearchable"] = this.isSearchable;
        data["isSortable"] = this.isSortable;
        data["isFilterable"] = this.isFilterable;
        return data;
    }
}

export interface ISearchableField {
    fieldName?: string;
    fieldType?: string;
    isSearchable?: boolean;
    isSortable?: boolean;
    isFilterable?: boolean;
}

export class CreateBrandCommand implements ICreateBrandCommand {
    description?: string;
    logoUrl?: string;
    name?: string;
    slug?: string;
    website?: string | undefined;
    status?: number;

    constructor(data?: ICreateBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.website = _data["website"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["website"] = this.website;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateBrandCommand {
    description?: string;
    logoUrl?: string;
    name?: string;
    slug?: string;
    website?: string | undefined;
    status?: number;
}

export class UpdateBrandCommand implements IUpdateBrandCommand {
    brandId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    logoUrl?: string | undefined;
    website?: string | undefined;
    status?: number | undefined;

    constructor(data?: IUpdateBrandCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.logoUrl = _data["logoUrl"];
            this.website = _data["website"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateBrandCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateBrandCommand {
    brandId?: string;
    name?: string | undefined;
    slug?: string | undefined;
    description?: string | undefined;
    logoUrl?: string | undefined;
    website?: string | undefined;
    status?: number | undefined;
}

export class UpdateBrandStatusCommand implements IUpdateBrandStatusCommand {
    brandId?: string;
    status?: number;

    constructor(data?: IUpdateBrandStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.brandId = _data["brandId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateBrandStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBrandStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["brandId"] = this.brandId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateBrandStatusCommand {
    brandId?: string;
    status?: number;
}

export class ResultOfShoppingCartDto implements IResultOfShoppingCartDto {
    isSuccess?: boolean;
    data?: ShoppingCartDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfShoppingCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ShoppingCartDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfShoppingCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfShoppingCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfShoppingCartDto {
    isSuccess?: boolean;
    data?: ShoppingCartDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ShoppingCartDto implements IShoppingCartDto {
    cartId?: string;
    userId?: string | undefined;
    sessionId?: string | undefined;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: ShoppingCartItemDto[];

    constructor(data?: IShoppingCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartId = _data["cartId"];
            this.userId = _data["userId"];
            this.sessionId = _data["sessionId"];
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.couponCode = _data["couponCode"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ShoppingCartItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShoppingCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartId"] = this.cartId;
        data["userId"] = this.userId;
        data["sessionId"] = this.sessionId;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["couponCode"] = this.couponCode;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IShoppingCartDto {
    cartId?: string;
    userId?: string | undefined;
    sessionId?: string | undefined;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: ShoppingCartItemDto[];
}

export class ShoppingCartItemDto implements IShoppingCartItemDto {
    cartItemId?: string;
    cartId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    unitPrice?: number;
    quantity?: number;
    totalPrice?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IShoppingCartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cartItemId = _data["cartItemId"];
            this.cartId = _data["cartId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.productImageUrl = _data["productImageUrl"];
            this.productVariantId = _data["productVariantId"];
            this.variantName = _data["variantName"];
            this.unitPrice = _data["unitPrice"];
            this.quantity = _data["quantity"];
            this.totalPrice = _data["totalPrice"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ShoppingCartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cartItemId"] = this.cartItemId;
        data["cartId"] = this.cartId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["productImageUrl"] = this.productImageUrl;
        data["productVariantId"] = this.productVariantId;
        data["variantName"] = this.variantName;
        data["unitPrice"] = this.unitPrice;
        data["quantity"] = this.quantity;
        data["totalPrice"] = this.totalPrice;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IShoppingCartItemDto {
    cartItemId?: string;
    cartId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    unitPrice?: number;
    quantity?: number;
    totalPrice?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export class ResultOfDecimal implements IResultOfDecimal {
    isSuccess?: boolean;
    data?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfDecimal) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfDecimal {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfDecimal();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfDecimal {
    isSuccess?: boolean;
    data?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfInteger implements IResultOfInteger {
    isSuccess?: boolean;
    data?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"];
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfInteger {
    isSuccess?: boolean;
    data?: number;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfCartSummaryDto implements IResultOfCartSummaryDto {
    isSuccess?: boolean;
    data?: CartSummaryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCartSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CartSummaryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCartSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCartSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCartSummaryDto {
    isSuccess?: boolean;
    data?: CartSummaryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CartSummaryDto implements ICartSummaryDto {
    itemCount?: number;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    isValid?: boolean;
    validationErrors?: string[];

    constructor(data?: ICartSummaryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemCount = _data["itemCount"];
            this.subTotal = _data["subTotal"];
            this.taxAmount = _data["taxAmount"];
            this.shippingAmount = _data["shippingAmount"];
            this.discountAmount = _data["discountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.couponCode = _data["couponCode"];
            this.isValid = _data["isValid"];
            if (Array.isArray(_data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of _data["validationErrors"])
                    this.validationErrors!.push(item);
            }
        }
    }

    static fromJS(data: any): CartSummaryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CartSummaryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCount"] = this.itemCount;
        data["subTotal"] = this.subTotal;
        data["taxAmount"] = this.taxAmount;
        data["shippingAmount"] = this.shippingAmount;
        data["discountAmount"] = this.discountAmount;
        data["totalAmount"] = this.totalAmount;
        data["couponCode"] = this.couponCode;
        data["isValid"] = this.isValid;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item);
        }
        return data;
    }
}

export interface ICartSummaryDto {
    itemCount?: number;
    subTotal?: number;
    taxAmount?: number;
    shippingAmount?: number;
    discountAmount?: number;
    totalAmount?: number;
    couponCode?: string | undefined;
    isValid?: boolean;
    validationErrors?: string[];
}

export class ResultOfListOfShoppingCartItemDto implements IResultOfListOfShoppingCartItemDto {
    isSuccess?: boolean;
    data?: ShoppingCartItemDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfShoppingCartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ShoppingCartItemDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfShoppingCartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfShoppingCartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfShoppingCartItemDto {
    isSuccess?: boolean;
    data?: ShoppingCartItemDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfShoppingCartItemDto implements IResultOfShoppingCartItemDto {
    isSuccess?: boolean;
    data?: ShoppingCartItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfShoppingCartItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ShoppingCartItemDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfShoppingCartItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfShoppingCartItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfShoppingCartItemDto {
    isSuccess?: boolean;
    data?: ShoppingCartItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class AddToCartRequest implements IAddToCartRequest {
    userId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    quantity?: number;

    constructor(data?: IAddToCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): AddToCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddToCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IAddToCartRequest {
    userId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    quantity?: number;
}

export class UpdateQuantityRequest implements IUpdateQuantityRequest {
    userId?: string;
    quantity?: number;

    constructor(data?: IUpdateQuantityRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UpdateQuantityRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateQuantityRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUpdateQuantityRequest {
    userId?: string;
    quantity?: number;
}

export class RemoveItemRequest implements IRemoveItemRequest {
    userId?: string;

    constructor(data?: IRemoveItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): RemoveItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IRemoveItemRequest {
    userId?: string;
}

export class ResultOfWishlistDto implements IResultOfWishlistDto {
    isSuccess?: boolean;
    data?: WishlistDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfWishlistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? WishlistDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfWishlistDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfWishlistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfWishlistDto {
    isSuccess?: boolean;
    data?: WishlistDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class WishlistDto implements IWishlistDto {
    wishlistId?: string;
    userId?: string;
    name?: string | undefined;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: WishlistItemDto[];

    constructor(data?: IWishlistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wishlistId = _data["wishlistId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.isDefault = _data["isDefault"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(WishlistItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WishlistDto {
        data = typeof data === 'object' ? data : {};
        let result = new WishlistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wishlistId"] = this.wishlistId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["isDefault"] = this.isDefault;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IWishlistDto {
    wishlistId?: string;
    userId?: string;
    name?: string | undefined;
    isDefault?: boolean;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    items?: WishlistItemDto[];
}

export class WishlistItemDto implements IWishlistItemDto {
    wishlistItemId?: string;
    wishlistId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productPrice?: number;
    productDiscountPrice?: number | undefined;
    productStockQuantity?: number;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    createdAt?: Date;

    constructor(data?: IWishlistItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.wishlistItemId = _data["wishlistItemId"];
            this.wishlistId = _data["wishlistId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.productSku = _data["productSku"];
            this.productImageUrl = _data["productImageUrl"];
            this.productPrice = _data["productPrice"];
            this.productDiscountPrice = _data["productDiscountPrice"];
            this.productStockQuantity = _data["productStockQuantity"];
            this.productVariantId = _data["productVariantId"];
            this.variantName = _data["variantName"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): WishlistItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new WishlistItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wishlistItemId"] = this.wishlistItemId;
        data["wishlistId"] = this.wishlistId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["productSku"] = this.productSku;
        data["productImageUrl"] = this.productImageUrl;
        data["productPrice"] = this.productPrice;
        data["productDiscountPrice"] = this.productDiscountPrice;
        data["productStockQuantity"] = this.productStockQuantity;
        data["productVariantId"] = this.productVariantId;
        data["variantName"] = this.variantName;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IWishlistItemDto {
    wishlistItemId?: string;
    wishlistId?: string;
    productId?: string;
    productName?: string;
    productSku?: string;
    productImageUrl?: string | undefined;
    productPrice?: number;
    productDiscountPrice?: number | undefined;
    productStockQuantity?: number;
    productVariantId?: string | undefined;
    variantName?: string | undefined;
    createdAt?: Date;
}

export class ResultOfListOfWishlistItemDto implements IResultOfListOfWishlistItemDto {
    isSuccess?: boolean;
    data?: WishlistItemDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfWishlistItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(WishlistItemDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfWishlistItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfWishlistItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfWishlistItemDto {
    isSuccess?: boolean;
    data?: WishlistItemDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfWishlistItemDto implements IResultOfWishlistItemDto {
    isSuccess?: boolean;
    data?: WishlistItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfWishlistItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? WishlistItemDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfWishlistItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfWishlistItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfWishlistItemDto {
    isSuccess?: boolean;
    data?: WishlistItemDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class AddToWishlistRequest implements IAddToWishlistRequest {
    productId?: string;
    variantId?: string | undefined;

    constructor(data?: IAddToWishlistRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.variantId = _data["variantId"];
        }
    }

    static fromJS(data: any): AddToWishlistRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AddToWishlistRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["variantId"] = this.variantId;
        return data;
    }
}

export interface IAddToWishlistRequest {
    productId?: string;
    variantId?: string | undefined;
}

export class MoveToCartRequest implements IMoveToCartRequest {
    quantity?: number;

    constructor(data?: IMoveToCartRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): MoveToCartRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MoveToCartRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IMoveToCartRequest {
    quantity?: number;
}

export class MergeCartsRequest implements IMergeCartsRequest {
    guestCartId?: string;

    constructor(data?: IMergeCartsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.guestCartId = _data["guestCartId"];
        }
    }

    static fromJS(data: any): MergeCartsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new MergeCartsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["guestCartId"] = this.guestCartId;
        return data;
    }
}

export interface IMergeCartsRequest {
    guestCartId?: string;
}

export class ApplyCouponRequest implements IApplyCouponRequest {
    couponCode?: string;

    constructor(data?: IApplyCouponRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponCode = _data["couponCode"];
        }
    }

    static fromJS(data: any): ApplyCouponRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyCouponRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponCode"] = this.couponCode;
        return data;
    }
}

export interface IApplyCouponRequest {
    couponCode?: string;
}

export class ResultOfPagedResultOfCategoryDto implements IResultOfPagedResultOfCategoryDto {
    isSuccess?: boolean;
    data?: PagedResultOfCategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfCategoryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfCategoryDto {
    isSuccess?: boolean;
    data?: PagedResultOfCategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfCategoryDto implements IPagedResultOfCategoryDto {
    items?: CategoryDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfCategoryDto {
    items?: CategoryDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class CategoryDto implements ICategoryDto {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategoryName?: string | undefined;
    displayOrder?: number;
    status?: number;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    subCategories?: CategoryDto[];
    productCount?: number;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.parentCategoryName = _data["parentCategoryName"];
            this.displayOrder = _data["displayOrder"];
            this.status = _data["status"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["subCategories"])) {
                this.subCategories = [] as any;
                for (let item of _data["subCategories"])
                    this.subCategories!.push(CategoryDto.fromJS(item));
            }
            this.productCount = _data["productCount"];
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["parentCategoryId"] = this.parentCategoryId;
        data["parentCategoryName"] = this.parentCategoryName;
        data["displayOrder"] = this.displayOrder;
        data["status"] = this.status;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.subCategories)) {
            data["subCategories"] = [];
            for (let item of this.subCategories)
                data["subCategories"].push(item ? item.toJSON() : undefined as any);
        }
        data["productCount"] = this.productCount;
        return data;
    }
}

export interface ICategoryDto {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    parentCategoryId?: string | undefined;
    parentCategoryName?: string | undefined;
    displayOrder?: number;
    status?: number;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    subCategories?: CategoryDto[];
    productCount?: number;
}

export class ResultOfListOfCategoryDto implements IResultOfListOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfListOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(CategoryDto.fromJS(item));
            }
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfListOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfListOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item ? item.toJSON() : undefined as any);
        }
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfListOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto[] | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfCategoryDto implements IResultOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CategoryDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCategoryDto {
    isSuccess?: boolean;
    data?: CategoryDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateCategoryCommand implements ICreateCategoryCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;

    constructor(data?: ICreateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.status = _data["status"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["parentCategoryId"] = this.parentCategoryId;
        data["status"] = this.status;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateCategoryCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;
}

export class UpdateCategoryCommand implements IUpdateCategoryCommand {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;

    constructor(data?: IUpdateCategoryCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.parentCategoryId = _data["parentCategoryId"];
            this.status = _data["status"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateCategoryCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["parentCategoryId"] = this.parentCategoryId;
        data["status"] = this.status;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateCategoryCommand {
    categoryId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    parentCategoryId?: string | undefined;
    status?: number;
    displayOrder?: number;
}

export class UpdateCategoryStatusCommand implements IUpdateCategoryStatusCommand {
    categoryId?: string;
    status?: number;

    constructor(data?: IUpdateCategoryStatusCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateCategoryStatusCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryStatusCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateCategoryStatusCommand {
    categoryId?: string;
    status?: number;
}

export class ResultOfPagedResultOfProductAttributeDto implements IResultOfPagedResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductAttributeDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductAttributeDto implements IPagedResultOfProductAttributeDto {
    items?: ProductAttributeDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAttributeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductAttributeDto {
    items?: ProductAttributeDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ProductAttributeDto implements IProductAttributeDto {
    productAttributeId?: string;
    name?: string;
    description?: string | undefined;
    dataType?: string;
    isRequired?: boolean;
    isSearchable?: boolean;
    isFilterable?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productAttributeId = _data["productAttributeId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.dataType = _data["dataType"];
            this.isRequired = _data["isRequired"];
            this.isSearchable = _data["isSearchable"];
            this.isFilterable = _data["isFilterable"];
            this.displayOrder = _data["displayOrder"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productAttributeId"] = this.productAttributeId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["dataType"] = this.dataType;
        data["isRequired"] = this.isRequired;
        data["isSearchable"] = this.isSearchable;
        data["isFilterable"] = this.isFilterable;
        data["displayOrder"] = this.displayOrder;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductAttributeDto {
    productAttributeId?: string;
    name?: string;
    description?: string | undefined;
    dataType?: string;
    isRequired?: boolean;
    isSearchable?: boolean;
    isFilterable?: boolean;
    displayOrder?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export class ResultOfProductAttributeDto implements IResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: ProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductAttributeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductAttributeDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductAttributeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductAttributeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductAttributeDto {
    isSuccess?: boolean;
    data?: ProductAttributeDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfCreateProductAttributeResponse implements IResultOfCreateProductAttributeResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductAttributeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductAttributeResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductAttributeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductAttributeResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductAttributeResponse extends ProductAttributeDto implements ICreateProductAttributeResponse {

    constructor(data?: ICreateProductAttributeResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductAttributeResponse extends IProductAttributeDto {
}

export class CreateProductAttributeCommand implements ICreateProductAttributeCommand {
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;

    constructor(data?: ICreateProductAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.attributeType = _data["attributeType"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateProductAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["attributeType"] = this.attributeType;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateProductAttributeCommand {
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;
}

export class ResultOfUpdateProductAttributeResponse implements IResultOfUpdateProductAttributeResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductAttributeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductAttributeResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductAttributeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductAttributeResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductAttributeResponse extends ProductAttributeDto implements IUpdateProductAttributeResponse {

    constructor(data?: IUpdateProductAttributeResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductAttributeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductAttributeResponse extends IProductAttributeDto {
}

export class UpdateProductAttributeCommand implements IUpdateProductAttributeCommand {
    attributeId?: string;
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;

    constructor(data?: IUpdateProductAttributeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.attributeId = _data["attributeId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.attributeType = _data["attributeType"];
            this.isRequired = _data["isRequired"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attributeId"] = this.attributeId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["attributeType"] = this.attributeType;
        data["isRequired"] = this.isRequired;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateProductAttributeCommand {
    attributeId?: string;
    name?: string;
    displayName?: string;
    attributeType?: number;
    isRequired?: boolean;
    displayOrder?: number;
}

export class ResultOfProductAttributeValueDto implements IResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: ProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductAttributeValueDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: ProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ProductAttributeValueDto implements IProductAttributeValueDto {
    productAttributeValueId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    productAttributeId?: string;
    productAttributeName?: string;
    value?: string;
    createdAt?: Date;

    constructor(data?: IProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productAttributeValueId = _data["productAttributeValueId"];
            this.productId = _data["productId"];
            this.productVariantId = _data["productVariantId"];
            this.productAttributeId = _data["productAttributeId"];
            this.productAttributeName = _data["productAttributeName"];
            this.value = _data["value"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productAttributeValueId"] = this.productAttributeValueId;
        data["productId"] = this.productId;
        data["productVariantId"] = this.productVariantId;
        data["productAttributeId"] = this.productAttributeId;
        data["productAttributeName"] = this.productAttributeName;
        data["value"] = this.value;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductAttributeValueDto {
    productAttributeValueId?: string;
    productId?: string;
    productVariantId?: string | undefined;
    productAttributeId?: string;
    productAttributeName?: string;
    value?: string;
    createdAt?: Date;
}

export class ResultOfPagedResultOfProductAttributeValueDto implements IResultOfPagedResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductAttributeValueDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductAttributeValueDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductAttributeValueDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductAttributeValueDto implements IPagedResultOfProductAttributeValueDto {
    items?: ProductAttributeValueDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductAttributeValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductAttributeValueDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductAttributeValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductAttributeValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductAttributeValueDto {
    items?: ProductAttributeValueDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfCreateProductAttributeValueResponse implements IResultOfCreateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductAttributeValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductAttributeValueResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: CreateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductAttributeValueResponse extends ProductAttributeValueDto implements ICreateProductAttributeValueResponse {

    constructor(data?: ICreateProductAttributeValueResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductAttributeValueResponse extends IProductAttributeValueDto {
}

export class CreateProductAttributeValueCommand implements ICreateProductAttributeValueCommand {
    productId?: string;
    attributeId?: string;
    value?: string;

    constructor(data?: ICreateProductAttributeValueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.attributeId = _data["attributeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateProductAttributeValueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeValueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["attributeId"] = this.attributeId;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateProductAttributeValueCommand {
    productId?: string;
    attributeId?: string;
    value?: string;
}

export class ResultOfUpdateProductAttributeValueResponse implements IResultOfUpdateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductAttributeValueResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductAttributeValueResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductAttributeValueResponse {
    isSuccess?: boolean;
    data?: UpdateProductAttributeValueResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductAttributeValueResponse extends ProductAttributeValueDto implements IUpdateProductAttributeValueResponse {

    constructor(data?: IUpdateProductAttributeValueResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductAttributeValueResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeValueResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductAttributeValueResponse extends IProductAttributeValueDto {
}

export class UpdateProductAttributeValueCommand implements IUpdateProductAttributeValueCommand {
    valueId?: string;
    productId?: string;
    attributeId?: string;
    value?: string;

    constructor(data?: IUpdateProductAttributeValueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.valueId = _data["valueId"];
            this.productId = _data["productId"];
            this.attributeId = _data["attributeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateProductAttributeValueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductAttributeValueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueId"] = this.valueId;
        data["productId"] = this.productId;
        data["attributeId"] = this.attributeId;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateProductAttributeValueCommand {
    valueId?: string;
    productId?: string;
    attributeId?: string;
    value?: string;
}

export class ResultOfCreateProductResponse implements IResultOfCreateProductResponse {
    isSuccess?: boolean;
    data?: CreateProductResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductResponse {
    isSuccess?: boolean;
    data?: CreateProductResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ProductBaseResponse implements IProductBaseResponse {
    productId?: string;
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    categoryName?: string;
    brandId?: string | undefined;
    brandName?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    primaryImageUrl?: string | undefined;
    images?: ProductImageDto[];
    variants?: ProductVariantDto[];
    tags?: ProductTagDto[];
    averageRating?: number | undefined;
    reviewCount?: number;

    constructor(data?: IProductBaseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            this.brandId = _data["brandId"];
            this.brandName = _data["brandName"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.isDigital = _data["isDigital"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.primaryImageUrl = _data["primaryImageUrl"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(ProductImageDto.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(ProductVariantDto.fromJS(item));
            }
            if (Array.isArray(_data["tags"])) {
                this.tags = [] as any;
                for (let item of _data["tags"])
                    this.tags!.push(ProductTagDto.fromJS(item));
            }
            this.averageRating = _data["averageRating"];
            this.reviewCount = _data["reviewCount"];
        }
    }

    static fromJS(data: any): ProductBaseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductBaseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["brandId"] = this.brandId;
        data["brandName"] = this.brandName;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["isDigital"] = this.isDigital;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["primaryImageUrl"] = this.primaryImageUrl;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tags)) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item ? item.toJSON() : undefined as any);
        }
        data["averageRating"] = this.averageRating;
        data["reviewCount"] = this.reviewCount;
        return data;
    }
}

export interface IProductBaseResponse {
    productId?: string;
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    categoryName?: string;
    brandId?: string | undefined;
    brandName?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    primaryImageUrl?: string | undefined;
    images?: ProductImageDto[];
    variants?: ProductVariantDto[];
    tags?: ProductTagDto[];
    averageRating?: number | undefined;
    reviewCount?: number;
}

export class CreateProductResponse extends ProductBaseResponse implements ICreateProductResponse {

    constructor(data?: ICreateProductResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductResponse extends IProductBaseResponse {
}

export class ProductImageDto implements IProductImageDto {
    productImageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
    createdAt?: Date;

    constructor(data?: IProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productImageId = _data["productImageId"];
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productImageId"] = this.productImageId;
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductImageDto {
    productImageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
    createdAt?: Date;
}

export class ProductVariantDto implements IProductVariantDto {
    productVariantId?: string;
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    attributes?: ProductAttributeValueDto[];

    constructor(data?: IProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productVariantId = _data["productVariantId"];
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(ProductAttributeValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productVariantId"] = this.productVariantId;
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface IProductVariantDto {
    productVariantId?: string;
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    attributes?: ProductAttributeValueDto[];
}

export class ProductTagDto implements IProductTagDto {
    productTagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    color?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    productCount?: number;

    constructor(data?: IProductTagDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productTagId = _data["productTagId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
            this.color = _data["color"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
            this.productCount = _data["productCount"];
        }
    }

    static fromJS(data: any): ProductTagDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTagDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTagId"] = this.productTagId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        data["color"] = this.color;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["productCount"] = this.productCount;
        return data;
    }
}

export interface IProductTagDto {
    productTagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
    color?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date | undefined;
    productCount?: number;
}

export class CreateProductVariantRequest implements ICreateProductVariantRequest {
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
    imageUrl?: string | undefined;
    attributes?: CreateProductAttributeValueRequest[];

    constructor(data?: ICreateProductVariantRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.status = _data["status"];
            this.imageUrl = _data["imageUrl"];
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(CreateProductAttributeValueRequest.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateProductVariantRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductVariantRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["status"] = this.status;
        data["imageUrl"] = this.imageUrl;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ICreateProductVariantRequest {
    productId?: string;
    sku?: string;
    name?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
    imageUrl?: string | undefined;
    attributes?: CreateProductAttributeValueRequest[];
}

export class CreateProductAttributeValueRequest implements ICreateProductAttributeValueRequest {
    productId?: string;
    productAttributeId?: string;
    value?: string;

    constructor(data?: ICreateProductAttributeValueRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.productAttributeId = _data["productAttributeId"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CreateProductAttributeValueRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductAttributeValueRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["productAttributeId"] = this.productAttributeId;
        data["value"] = this.value;
        return data;
    }
}

export interface ICreateProductAttributeValueRequest {
    productId?: string;
    productAttributeId?: string;
    value?: string;
}

export class CreateProductCommand implements ICreateProductCommand {
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    images?: CreateProductImageRequest[] | undefined;
    variants?: CreateProductVariantRequest[] | undefined;
    attributes?: CreateProductAttributeValueRequest[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.sku = _data["sku"];
            this.description = _data["description"];
            this.shortDescription = _data["shortDescription"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.cost = _data["cost"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.categoryId = _data["categoryId"];
            this.brandId = _data["brandId"];
            this.status = _data["status"];
            this.isFeatured = _data["isFeatured"];
            this.isDigital = _data["isDigital"];
            this.metaTitle = _data["metaTitle"];
            this.metaDescription = _data["metaDescription"];
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(CreateProductImageRequest.fromJS(item));
            }
            if (Array.isArray(_data["variants"])) {
                this.variants = [] as any;
                for (let item of _data["variants"])
                    this.variants!.push(CreateProductVariantRequest.fromJS(item));
            }
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(CreateProductAttributeValueRequest.fromJS(item));
            }
            if (Array.isArray(_data["tagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["tagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["sku"] = this.sku;
        data["description"] = this.description;
        data["shortDescription"] = this.shortDescription;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["cost"] = this.cost;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["categoryId"] = this.categoryId;
        data["brandId"] = this.brandId;
        data["status"] = this.status;
        data["isFeatured"] = this.isFeatured;
        data["isDigital"] = this.isDigital;
        data["metaTitle"] = this.metaTitle;
        data["metaDescription"] = this.metaDescription;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.variants)) {
            data["variants"] = [];
            for (let item of this.variants)
                data["variants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["tagIds"] = [];
            for (let item of this.tagIds)
                data["tagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateProductCommand {
    name?: string;
    slug?: string | undefined;
    sku?: string;
    description?: string;
    shortDescription?: string | undefined;
    price?: number;
    discountPrice?: number | undefined;
    cost?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    categoryId?: string;
    brandId?: string | undefined;
    status?: number;
    isFeatured?: boolean;
    isDigital?: boolean;
    metaTitle?: string | undefined;
    metaDescription?: string | undefined;
    images?: CreateProductImageRequest[] | undefined;
    variants?: CreateProductVariantRequest[] | undefined;
    attributes?: CreateProductAttributeValueRequest[] | undefined;
    tagIds?: string[] | undefined;
}

export class CreateProductImageRequest implements ICreateProductImageRequest {
    productId?: string;
    imageUrl?: string | undefined;
    imageFile?: string | undefined;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;

    constructor(data?: ICreateProductImageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.imageFile = _data["imageFile"];
            this.altText = _data["altText"];
            this.displayOrder = _data["displayOrder"];
            this.isPrimary = _data["isPrimary"];
        }
    }

    static fromJS(data: any): CreateProductImageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["imageFile"] = this.imageFile;
        data["altText"] = this.altText;
        data["displayOrder"] = this.displayOrder;
        data["isPrimary"] = this.isPrimary;
        return data;
    }
}

export interface ICreateProductImageRequest {
    productId?: string;
    imageUrl?: string | undefined;
    imageFile?: string | undefined;
    altText?: string | undefined;
    displayOrder?: number;
    isPrimary?: boolean;
}

export class ResultOfProductImageDto implements IResultOfProductImageDto {
    isSuccess?: boolean;
    data?: ProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductImageDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductImageDto {
    isSuccess?: boolean;
    data?: ProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfPagedResultOfProductImageDto implements IResultOfPagedResultOfProductImageDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductImageDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductImageDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductImageDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductImageDto implements IPagedResultOfProductImageDto {
    items?: ProductImageDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductImageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductImageDto {
    items?: ProductImageDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfCreateProductImageResponse implements IResultOfCreateProductImageResponse {
    isSuccess?: boolean;
    data?: CreateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductImageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductImageResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductImageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductImageResponse {
    isSuccess?: boolean;
    data?: CreateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductImageResponse extends ProductImageDto implements ICreateProductImageResponse {

    constructor(data?: ICreateProductImageResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductImageResponse extends IProductImageDto {
}

export class CreateProductImageCommand implements ICreateProductImageCommand {
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;

    constructor(data?: ICreateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.isPrimary = _data["isPrimary"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): CreateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["isPrimary"] = this.isPrimary;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface ICreateProductImageCommand {
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;
}

export class ResultOfUpdateProductImageResponse implements IResultOfUpdateProductImageResponse {
    isSuccess?: boolean;
    data?: UpdateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductImageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductImageResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductImageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductImageResponse {
    isSuccess?: boolean;
    data?: UpdateProductImageResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductImageResponse extends ProductImageDto implements IUpdateProductImageResponse {

    constructor(data?: IUpdateProductImageResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductImageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductImageResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductImageResponse extends IProductImageDto {
}

export class UpdateProductImageCommand implements IUpdateProductImageCommand {
    imageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;

    constructor(data?: IUpdateProductImageCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.imageId = _data["imageId"];
            this.productId = _data["productId"];
            this.imageUrl = _data["imageUrl"];
            this.altText = _data["altText"];
            this.isPrimary = _data["isPrimary"];
            this.displayOrder = _data["displayOrder"];
        }
    }

    static fromJS(data: any): UpdateProductImageCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductImageCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageId"] = this.imageId;
        data["productId"] = this.productId;
        data["imageUrl"] = this.imageUrl;
        data["altText"] = this.altText;
        data["isPrimary"] = this.isPrimary;
        data["displayOrder"] = this.displayOrder;
        return data;
    }
}

export interface IUpdateProductImageCommand {
    imageId?: string;
    productId?: string;
    imageUrl?: string;
    altText?: string | undefined;
    isPrimary?: boolean;
    displayOrder?: number;
}

export class ResultOfProductQuestionDto implements IResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: ProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductQuestionDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: ProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ProductQuestionDto implements IProductQuestionDto {
    productQuestionId?: string;
    productId?: string;
    productName?: string;
    userId?: string;
    userName?: string;
    question?: string;
    answer?: string | undefined;
    answeredAt?: Date | undefined;
    answeredBy?: string | undefined;
    answeredByName?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;

    constructor(data?: IProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productQuestionId = _data["productQuestionId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.question = _data["question"];
            this.answer = _data["answer"];
            this.answeredAt = _data["answeredAt"] ? new Date(_data["answeredAt"].toString()) : undefined as any;
            this.answeredBy = _data["answeredBy"];
            this.answeredByName = _data["answeredByName"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productQuestionId"] = this.productQuestionId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["question"] = this.question;
        data["answer"] = this.answer;
        data["answeredAt"] = this.answeredAt ? this.answeredAt.toISOString() : undefined as any;
        data["answeredBy"] = this.answeredBy;
        data["answeredByName"] = this.answeredByName;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IProductQuestionDto {
    productQuestionId?: string;
    productId?: string;
    productName?: string;
    userId?: string;
    userName?: string;
    question?: string;
    answer?: string | undefined;
    answeredAt?: Date | undefined;
    answeredBy?: string | undefined;
    answeredByName?: string | undefined;
    status?: number;
    createdAt?: Date;
    updatedAt?: Date | undefined;
}

export class ResultOfPagedResultOfProductQuestionDto implements IResultOfPagedResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductQuestionDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductQuestionDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductQuestionDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductQuestionDto implements IPagedResultOfProductQuestionDto {
    items?: ProductQuestionDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductQuestionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductQuestionDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductQuestionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductQuestionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductQuestionDto {
    items?: ProductQuestionDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class ResultOfCreateProductQuestionResponse implements IResultOfCreateProductQuestionResponse {
    isSuccess?: boolean;
    data?: CreateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductQuestionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductQuestionResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductQuestionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductQuestionResponse {
    isSuccess?: boolean;
    data?: CreateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductQuestionResponse extends ProductQuestionDto implements ICreateProductQuestionResponse {

    constructor(data?: ICreateProductQuestionResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductQuestionResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductQuestionResponse extends IProductQuestionDto {
}

export class CreateProductQuestionCommand implements ICreateProductQuestionCommand {
    productId?: string;
    userId?: string;
    question?: string;
    status?: number;

    constructor(data?: ICreateProductQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.userId = _data["userId"];
            this.question = _data["question"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateProductQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["userId"] = this.userId;
        data["question"] = this.question;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateProductQuestionCommand {
    productId?: string;
    userId?: string;
    question?: string;
    status?: number;
}

export class ResultOfUpdateProductQuestionResponse implements IResultOfUpdateProductQuestionResponse {
    isSuccess?: boolean;
    data?: UpdateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductQuestionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductQuestionResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductQuestionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductQuestionResponse {
    isSuccess?: boolean;
    data?: UpdateProductQuestionResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductQuestionResponse extends ProductQuestionDto implements IUpdateProductQuestionResponse {

    constructor(data?: IUpdateProductQuestionResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductQuestionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductQuestionResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductQuestionResponse extends IProductQuestionDto {
}

export class UpdateProductQuestionCommand implements IUpdateProductQuestionCommand {
    questionId?: string;
    question?: string;
    status?: number;

    constructor(data?: IUpdateProductQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.question = _data["question"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateProductQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["question"] = this.question;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateProductQuestionCommand {
    questionId?: string;
    question?: string;
    status?: number;
}

export class AnswerProductQuestionCommand implements IAnswerProductQuestionCommand {
    questionId?: string;
    answer?: string;
    answeredBy?: string;

    constructor(data?: IAnswerProductQuestionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.questionId = _data["questionId"];
            this.answer = _data["answer"];
            this.answeredBy = _data["answeredBy"];
        }
    }

    static fromJS(data: any): AnswerProductQuestionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerProductQuestionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["answer"] = this.answer;
        data["answeredBy"] = this.answeredBy;
        return data;
    }
}

export interface IAnswerProductQuestionCommand {
    questionId?: string;
    answer?: string;
    answeredBy?: string;
}

export class AssignTagToProductCommand implements IAssignTagToProductCommand {
    productId?: string;
    tagId?: string;

    constructor(data?: IAssignTagToProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.tagId = _data["tagId"];
        }
    }

    static fromJS(data: any): AssignTagToProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTagToProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["tagId"] = this.tagId;
        return data;
    }
}

export interface IAssignTagToProductCommand {
    productId?: string;
    tagId?: string;
}

export class CreateProductTagCommand implements ICreateProductTagCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: ICreateProductTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): CreateProductTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface ICreateProductTagCommand {
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class UpdateProductTagCommand implements IUpdateProductTagCommand {
    tagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;

    constructor(data?: IUpdateProductTagCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tagId = _data["tagId"];
            this.name = _data["name"];
            this.slug = _data["slug"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): UpdateProductTagCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductTagCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tagId"] = this.tagId;
        data["name"] = this.name;
        data["slug"] = this.slug;
        data["description"] = this.description;
        return data;
    }
}

export interface IUpdateProductTagCommand {
    tagId?: string;
    name?: string;
    slug?: string | undefined;
    description?: string | undefined;
}

export class ResultOfCreateProductVariantResponse implements IResultOfCreateProductVariantResponse {
    isSuccess?: boolean;
    data?: CreateProductVariantResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfCreateProductVariantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? CreateProductVariantResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfCreateProductVariantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfCreateProductVariantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfCreateProductVariantResponse {
    isSuccess?: boolean;
    data?: CreateProductVariantResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class CreateProductVariantResponse extends ProductVariantDto implements ICreateProductVariantResponse {

    constructor(data?: ICreateProductVariantResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): CreateProductVariantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductVariantResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface ICreateProductVariantResponse extends IProductVariantDto {
}

export class CreateProductVariantCommand implements ICreateProductVariantCommand {
    productId?: string;
    sku?: string;
    name?: string;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;

    constructor(data?: ICreateProductVariantCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateProductVariantCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductVariantCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateProductVariantCommand {
    productId?: string;
    sku?: string;
    name?: string;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
}

export class ResultOfUpdateProductVariantResponse implements IResultOfUpdateProductVariantResponse {
    isSuccess?: boolean;
    data?: UpdateProductVariantResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfUpdateProductVariantResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? UpdateProductVariantResponse.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfUpdateProductVariantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfUpdateProductVariantResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfUpdateProductVariantResponse {
    isSuccess?: boolean;
    data?: UpdateProductVariantResponse | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class UpdateProductVariantResponse extends ProductVariantDto implements IUpdateProductVariantResponse {

    constructor(data?: IUpdateProductVariantResponse) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): UpdateProductVariantResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductVariantResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateProductVariantResponse extends IProductVariantDto {
}

export class UpdateProductVariantCommand implements IUpdateProductVariantCommand {
    variantId?: string;
    sku?: string;
    name?: string;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;

    constructor(data?: IUpdateProductVariantCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.variantId = _data["variantId"];
            this.sku = _data["sku"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.discountPrice = _data["discountPrice"];
            this.stockQuantity = _data["stockQuantity"];
            this.minStockLevel = _data["minStockLevel"];
            this.weight = _data["weight"];
            this.dimensions = _data["dimensions"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateProductVariantCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductVariantCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variantId"] = this.variantId;
        data["sku"] = this.sku;
        data["name"] = this.name;
        data["price"] = this.price;
        data["discountPrice"] = this.discountPrice;
        data["stockQuantity"] = this.stockQuantity;
        data["minStockLevel"] = this.minStockLevel;
        data["weight"] = this.weight;
        data["dimensions"] = this.dimensions;
        data["status"] = this.status;
        return data;
    }
}

export interface IUpdateProductVariantCommand {
    variantId?: string;
    sku?: string;
    name?: string;
    price?: number;
    discountPrice?: number | undefined;
    stockQuantity?: number;
    minStockLevel?: number;
    weight?: number | undefined;
    dimensions?: string | undefined;
    status?: number;
}

export class UpdateProductVariantStockCommand implements IUpdateProductVariantStockCommand {
    variantId?: string;
    quantity?: number;

    constructor(data?: IUpdateProductVariantStockCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.variantId = _data["variantId"];
            this.quantity = _data["quantity"];
        }
    }

    static fromJS(data: any): UpdateProductVariantStockCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductVariantStockCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["variantId"] = this.variantId;
        data["quantity"] = this.quantity;
        return data;
    }
}

export interface IUpdateProductVariantStockCommand {
    variantId?: string;
    quantity?: number;
}

export class ResultOfProductVariantDto implements IResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: ProductVariantDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? ProductVariantDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: ProductVariantDto | undefined;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class ResultOfPagedResultOfProductVariantDto implements IResultOfPagedResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductVariantDto;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];

    constructor(data?: IResultOfPagedResultOfProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.data = _data["data"] ? PagedResultOfProductVariantDto.fromJS(_data["data"]) : undefined as any;
            this.errorMessage = _data["errorMessage"];
            this.errorCode = _data["errorCode"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): ResultOfPagedResultOfProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPagedResultOfProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["data"] = this.data ? this.data.toJSON() : undefined as any;
        data["errorMessage"] = this.errorMessage;
        data["errorCode"] = this.errorCode;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResultOfPagedResultOfProductVariantDto {
    isSuccess?: boolean;
    data?: PagedResultOfProductVariantDto;
    errorMessage?: string | undefined;
    errorCode?: string | undefined;
    errors?: string[];
}

export class PagedResultOfProductVariantDto implements IPagedResultOfProductVariantDto {
    items?: ProductVariantDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;

    constructor(data?: IPagedResultOfProductVariantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ProductVariantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
            this.page = _data["page"];
            this.pageSize = _data["pageSize"];
            this.totalPages = _data["totalPages"];
            this.hasPreviousPage = _data["hasPreviousPage"];
            this.hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): PagedResultOfProductVariantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfProductVariantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["totalCount"] = this.totalCount;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["totalPages"] = this.totalPages;
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IPagedResultOfProductVariantDto {
    items?: ProductVariantDto[];
    totalCount?: number;
    page?: number;
    pageSize?: number;
    totalPages?: number;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}